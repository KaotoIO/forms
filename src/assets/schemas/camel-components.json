{
	"activemq": {
		"properties": {
			"destinationType": {
				"title": "Destination Type",
				"description": "The kind of destination to use",
				"type": "string",
				"enum": [
					"queue",
					"topic",
					"temp-queue",
					"temp-topic"
				],
				"$comment": "group:common",
				"default": "queue"
			},
			"destinationName": {
				"title": "Destination Name",
				"description": "Name of the queue or topic to use as destination",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions with JMS 1.1.",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:jakarta.jms.ConnectionFactory"
			},
			"disableReplyTo": {
				"title": "Disable Reply To",
				"description": "Specifies whether Camel ignores the JMSReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the JMSReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"durableSubscriptionName": {
				"title": "Durable Subscription Name",
				"description": "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.",
				"type": "string",
				"$comment": "group:common"
			},
			"jmsMessageType": {
				"title": "Jms Message Type",
				"description": "Allows you to force the use of a specific jakarta.jms.Message implementation for sending JMS messages. Possible values are: Bytes, Map, Object, Stream, Text. By default, Camel would determine which JMS message type to use from the In body type. This option allows you to specify it.",
				"type": "string",
				"enum": [
					"Bytes",
					"Map",
					"Object",
					"Stream",
					"Text"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.jms.JmsMessageType"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "Provides an explicit ReplyTo destination (overrides any incoming value of Message.getJMSReplyTo() in consumer).",
				"type": "string",
				"$comment": "group:common"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"acknowledgementModeName": {
				"title": "Acknowledgement Mode Name",
				"description": "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
				"type": "string",
				"enum": [
					"SESSION_TRANSACTED",
					"CLIENT_ACKNOWLEDGE",
					"AUTO_ACKNOWLEDGE",
					"DUPS_OK_ACKNOWLEDGE"
				],
				"$comment": "group:consumer",
				"default": "AUTO_ACKNOWLEDGE"
			},
			"artemisConsumerPriority": {
				"title": "Artemis Consumer Priority",
				"description": "Consumer priorities allow you to ensure that high priority consumers receive messages while they are active. Normally, active consumers connected to a queue receive messages from it in a round-robin fashion. When consumer priorities are in use, messages are delivered round-robin if multiple active consumers exist with the same high priority. Messages will only going to lower priority consumers when the high priority consumers do not have credit available to consume the message, or those high priority consumers have declined to accept the message (for instance because it does not meet the criteria of any selectors associated with the consumer).",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"asyncConsumer": {
				"title": "Async Consumer",
				"description": "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"autoStartup": {
				"title": "Auto Startup",
				"description": "Specifies whether the consumer container should auto-startup.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"cacheLevel": {
				"title": "Cache Level",
				"description": "Sets the cache level by ID for the underlying JMS resources. See cacheLevelName option for more details.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"cacheLevelName": {
				"title": "Cache Level Name",
				"description": "Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER, CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.",
				"type": "string",
				"enum": [
					"CACHE_AUTO",
					"CACHE_CONNECTION",
					"CACHE_CONSUMER",
					"CACHE_NONE",
					"CACHE_SESSION"
				],
				"$comment": "group:consumer",
				"default": "CACHE_AUTO"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"maxConcurrentConsumers": {
				"title": "Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"replyToDeliveryPersistent": {
				"title": "Reply To Delivery Persistent",
				"description": "Specifies whether to use persistent delivery by default for replies.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"selector": {
				"title": "Selector",
				"description": "Sets the JMS selector to use",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscriptionDurable": {
				"title": "Subscription Durable",
				"description": "Set whether to make the subscription durable. The durable subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a durable subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"subscriptionName": {
				"title": "Subscription Name",
				"description": "Set the name of a subscription to create. To be applied in case of a topic (pub-sub domain) with a shared or durable subscription. The subscription name needs to be unique within this client's JMS client id. Default is the class name of the specified message listener. Note: Only 1 concurrent consumer (which is the default of this message listener container) is allowed for each subscription, except for a shared subscription (which requires JMS 2.0).",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscriptionShared": {
				"title": "Subscription Shared",
				"description": "Set whether to make the subscription shared. The shared subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a shared subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Note that shared subscriptions may also be durable, so this flag can (and often will) be combined with subscriptionDurable as well. Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well. Requires a JMS 2.0 compatible message broker.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"acceptMessagesWhileStopping": {
				"title": "Accept Messages While Stopping",
				"description": "Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option, if you start and stop JMS routes at runtime, while there are still messages enqueued on the queue. If this option is false, and you stop the JMS route, then messages may be rejected, and the JMS broker would have to attempt redeliveries, which yet again may be rejected, and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"allowReplyManagerQuickStop": {
				"title": "Allow Reply Manager Quick Stop",
				"description": "Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case JmsConfiguration#isAcceptMessagesWhileStopping is enabled, and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"consumerType": {
				"title": "Consumer Type",
				"description": "The consumer type to use, which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
				"type": "string",
				"enum": [
					"Simple",
					"Default",
					"Custom"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.ConsumerType",
				"default": "Default"
			},
			"defaultTaskExecutorType": {
				"title": "Default Task Executor Type",
				"description": "Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer, for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's ThreadPoolTaskExecutor with optimal values - cached thread-pool-like). If not set, it defaults to the previous behaviour, which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers.",
				"type": "string",
				"enum": [
					"ThreadPool",
					"SimpleAsync"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.DefaultTaskExecutorType"
			},
			"destinationOptions": {
				"title": "Destination Options",
				"description": "Destination Options are a way to provide extended configuration options to a JMS consumer without having to extend the JMS API. The options are encoded using URL query syntax in the destination name that the consumer is created on. See more details at https://activemq.apache.org/destination-options.",
				"type": "object",
				"$comment": "group:consumer (advanced)"
			},
			"eagerLoadingOfProperties": {
				"title": "Eager Loading Of Properties",
				"description": "Enables eager loading of JMS properties and payload as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties. See also the option eagerPoisonBody.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerPoisonBody": {
				"title": "Eager Poison Body",
				"description": "If eagerLoadingOfProperties is enabled and the JMS message payload (JMS body or JMS properties) is poison (cannot be read/mapped), then set this text as the message body instead so the message can be processed (the cause of the poison are already stored as exception on the Exchange). This can be turned off by setting eagerPoisonBody=false. See also the option eagerLoadingOfProperties.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "Poison JMS message due to ${exception.message}"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"exposeListenerSession": {
				"title": "Expose Listener Session",
				"description": "Specifies whether the listener session should be exposed when consuming messages.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"replyToConsumerType": {
				"title": "Reply To Consumer Type",
				"description": "The consumer type of the reply consumer (when doing request/reply), which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
				"type": "string",
				"enum": [
					"Simple",
					"Default",
					"Custom"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.ConsumerType",
				"default": "Default"
			},
			"replyToSameDestinationAllowed": {
				"title": "Reply To Same Destination Allowed",
				"description": "Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"taskExecutor": {
				"title": "Task Executor",
				"description": "Allows you to specify a custom task executor for consuming messages.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.springframework.core.task.TaskExecutor"
			},
			"deliveryDelay": {
				"title": "Delivery Delay",
				"description": "Sets delivery delay to use for send calls for JMS. This option requires JMS 2.0 compliant broker.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"deliveryMode": {
				"title": "Delivery Mode",
				"description": "Specifies the delivery mode to be used. Possible values are those defined by jakarta.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.",
				"type": "integer",
				"enum": [
					"1",
					"2"
				],
				"$comment": "group:producer"
			},
			"deliveryPersistent": {
				"title": "Delivery Persistent",
				"description": "Specifies whether persistent delivery is used by default.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"explicitQosEnabled": {
				"title": "Explicit Qos Enabled",
				"description": "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"formatDateHeadersToIso8601": {
				"title": "Format Date Headers To Iso8601",
				"description": "Sets whether JMS date properties should be formatted according to the ISO 8601 standard.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"preserveMessageQos": {
				"title": "Preserve Message Qos",
				"description": "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"priority": {
				"title": "Priority",
				"description": "Values greater than 1 specify the message priority when sending (where 1 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
				"type": "integer",
				"enum": [
					"1",
					"2",
					"3",
					"4",
					"5",
					"6",
					"7",
					"8",
					"9"
				],
				"$comment": "group:producer",
				"default": 4
			},
			"replyToConcurrentConsumers": {
				"title": "Reply To Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToMaxConcurrentConsumers": {
				"title": "Reply To Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"replyToOnTimeoutMaxConcurrentConsumers": {
				"title": "Reply To On Timeout Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToOverride": {
				"title": "Reply To Override",
				"description": "Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.",
				"type": "string",
				"$comment": "group:producer"
			},
			"replyToType": {
				"title": "Reply To Type",
				"description": "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary, Shared, or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details, and especially the notes about the implications if running in a clustered environment, and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive.",
				"type": "string",
				"enum": [
					"Temporary",
					"Shared",
					"Exclusive"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jms.ReplyToType"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "20000"
			},
			"timeToLive": {
				"title": "Time To Live",
				"description": "When sending messages, specifies the time-to-live of the message (in milliseconds).",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"allowAdditionalHeaders": {
				"title": "Allow Additional Headers",
				"description": "This option is used to allow additional headers which may have values that are invalid according to JMS specification. For example, some message systems, such as WMQ, do this with header names using prefix JMS_IBM_MQMD_ containing values with byte array or other invalid types. You can specify multiple header names separated by comma, and use as suffix for wildcard matching.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"alwaysCopyMessage": {
				"title": "Always Copy Message",
				"description": "If true, Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations, such as when a replyToDestinationSelectorName is set (incidentally, Camel will set the alwaysCopyMessage option to true, if a replyToDestinationSelectorName is set)",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"correlationProperty": {
				"title": "Correlation Property",
				"description": "When using InOut exchange pattern use this JMS property instead of JMSCorrelationID JMS property to correlate messages. If set messages will be correlated solely on the value of this property JMSCorrelationID property will be ignored and not set by Camel.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"disableTimeToLive": {
				"title": "Disable Time To Live",
				"description": "Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"forceSendOriginalMessage": {
				"title": "Force Send Original Message",
				"description": "When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"includeSentJMSMessageID": {
				"title": "Include Sent JMSMessage ID",
				"description": "Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"replyToCacheLevelName": {
				"title": "Reply To Cache Level Name",
				"description": "Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed, and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION.",
				"type": "string",
				"enum": [
					"CACHE_AUTO",
					"CACHE_CONNECTION",
					"CACHE_CONSUMER",
					"CACHE_NONE",
					"CACHE_SESSION"
				],
				"$comment": "group:producer (advanced)"
			},
			"replyToDestinationSelectorName": {
				"title": "Reply To Destination Selector Name",
				"description": "Sets the JMS Selector using the fixed name to be used so you can filter out your own replies from the others when using a shared queue (that is, if you are not using a temporary reply queue).",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"streamMessageTypeEnabled": {
				"title": "Stream Message Type Enabled",
				"description": "Sets whether StreamMessage type is enabled or not. Message payloads of streaming kind such as files, InputStream, etc will either by sent as BytesMessage or StreamMessage. This option controls which kind will be used. By default BytesMessage is used which enforces the entire message payload to be read into memory. By enabling this option the message payload is read into memory in chunks and each chunk is then written to the StreamMessage until no more data.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"allowSerializedHeaders": {
				"title": "Allow Serialized Headers",
				"description": "Controls whether or not to include serialized headers. Applies only when transferExchange is true. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"artemisStreamingEnabled": {
				"title": "Artemis Streaming Enabled",
				"description": "Whether optimizing for Apache Artemis streaming mode. This can reduce memory overhead when using Artemis with JMS StreamMessage types. This option must only be enabled if Apache Artemis is being used.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStartListener": {
				"title": "Async Start Listener",
				"description": "Whether to startup the JmsConsumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or fail-over. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStopListener": {
				"title": "Async Stop Listener",
				"description": "Whether to stop the JmsConsumer message listener asynchronously, when stopping a route.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"destinationResolver": {
				"title": "Destination Resolver",
				"description": "A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example, to lookup the real destination in a JNDI registry).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.jms.support.destination.DestinationResolver"
			},
			"errorHandler": {
				"title": "Error Handler",
				"description": "Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level, if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure, than having to code a custom errorHandler.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.util.ErrorHandler"
			},
			"exceptionListener": {
				"title": "Exception Listener",
				"description": "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.jms.ExceptionListener"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"idleConsumerLimit": {
				"title": "Idle Consumer Limit",
				"description": "Specify the limit for the number of consumers that are allowed to be idle at any given time.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"idleReceivesPerTaskLimit": {
				"title": "Idle Receives Per Task Limit",
				"description": "Marks the consumer as idle after the specified number of idle receives have been reached. An idle receive is counted from the moment a null message is returned by the receiver after the potential setReceiveTimeout elapsed. This gives the opportunity to check if the idle task count exceeds setIdleTaskExecutionLimit and based on that decide if the task needs to be re-scheduled or not, saving resources that would otherwise be held. This setting differs from setMaxMessagesPerTask where the task is released and re-scheduled after this limit is reached, no matter if the received messages were null or non-null messages. This setting alone can be inflexible if one desires to have a large enough batch for each task but requires a quick(er) release from the moment there are no more messages to process. This setting differs from setIdleTaskExecutionLimit where this limit decides after how many iterations of being marked as idle, a task is released. For example: If setMaxMessagesPerTask is set to '500' and #setIdleReceivesPerTaskLimit is set to '60' and setReceiveTimeout is set to '1000' and setIdleTaskExecutionLimit is set to '1', then 500 messages per task would be processed unless there is a subsequent number of 60 idle messages received, the task would be marked as idle and released. This also means that after the last message was processed, the task would be released after 60 seconds as long as no new messages appear.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"idleTaskExecutionLimit": {
				"title": "Idle Task Execution Limit",
				"description": "Specifies the limit for idle executions of a receive task, not having received any message within its execution. If this limit is reached, the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"includeAllJMSXProperties": {
				"title": "Include All JMSXProperties",
				"description": "Whether to include all JMSX prefixed properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"jmsKeyFormatStrategy": {
				"title": "Jms Key Format Strategy",
				"description": "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
				"type": "string",
				"enum": [
					"default",
					"passthrough"
				],
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.JmsKeyFormatStrategy"
			},
			"mapJmsMessage": {
				"title": "Map Jms Message",
				"description": "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as jakarta.jms.TextMessage to a String etc.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"maxMessagesPerTask": {
				"title": "Max Messages Per Task",
				"description": "The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max), then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": -1
			},
			"messageConverter": {
				"title": "Message Converter",
				"description": "To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a jakarta.jms.Message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.jms.support.converter.MessageConverter"
			},
			"messageCreatedStrategy": {
				"title": "Message Created Strategy",
				"description": "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of jakarta.jms.Message objects when Camel is sending a JMS message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.MessageCreatedStrategy"
			},
			"messageIdEnabled": {
				"title": "Message Id Enabled",
				"description": "When sending, specifies whether message IDs should be added. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"messageListenerContainerFactory": {
				"title": "Message Listener Container Factory",
				"description": "Registry ID of the MessageListenerContainerFactory used to determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use to consume messages. Setting this will automatically set consumerType to Custom.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.MessageListenerContainerFactory"
			},
			"messageTimestampEnabled": {
				"title": "Message Timestamp Enabled",
				"description": "Specifies whether timestamps should be enabled by default on sending messages. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint the timestamp must be set to its normal value.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"pubSubNoLocal": {
				"title": "Pub Sub No Local",
				"description": "Specifies whether to inhibit the delivery of messages published by its own connection.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"receiveTimeout": {
				"title": "Receive Timeout",
				"description": "The timeout for receiving messages (in milliseconds).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"recoveryInterval": {
				"title": "Recovery Interval",
				"description": "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "5000"
			},
			"requestTimeoutCheckerInterval": {
				"title": "Request Timeout Checker Interval",
				"description": "Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs, then you can lower this interval, to check more frequently. The timeout is determined by the option requestTimeout.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"temporaryQueueResolver": {
				"title": "Temporary Queue Resolver",
				"description": "A pluggable TemporaryQueueResolver that allows you to use your own resolver for creating temporary queues (some messaging systems has special requirements for creating temporary queues).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.TemporaryQueueResolver"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a jakarta.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transferExchange": {
				"title": "Transfer Exchange",
				"description": "You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side, so Camel knows the payloads is an Exchange and not a regular payload. Use this with caution as the data is using Java Object serialization and requires the receiver to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumers having to use compatible Camel versions!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"useMessageIDAsCorrelationID": {
				"title": "Use Message IDAs Correlation ID",
				"description": "Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"waitForProvisionCorrelationToBeUpdatedCounter": {
				"title": "Wait For Provision Correlation To Be Updated Counter",
				"description": "Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 50
			},
			"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime": {
				"title": "Wait For Provision Correlation To Be Updated Thread Sleeping Time",
				"description": "Interval in millis to sleep each time while waiting for provisional correlation id to be updated.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "100"
			},
			"waitForTemporaryReplyToToBeUpdatedCounter": {
				"title": "Wait For Temporary Reply To To Be Updated Counter",
				"description": "Number of times to wait for temporary replyTo queue to be created and ready when doing request/reply over JMS.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 200
			},
			"waitForTemporaryReplyToToBeUpdatedThreadSleepingTime": {
				"title": "Wait For Temporary Reply To To Be Updated Thread Sleeping Time",
				"description": "Interval in millis to sleep each time while waiting for temporary replyTo queue to be ready.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "100"
			},
			"errorHandlerLoggingLevel": {
				"title": "Error Handler Logging Level",
				"description": "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:logging",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"errorHandlerLogStackTrace": {
				"title": "Error Handler Log Stack Trace",
				"description": "Allows to control whether stack-traces should be logged or not, by the default errorHandler.",
				"type": "boolean",
				"$comment": "group:logging",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"transacted": {
				"title": "Transacted",
				"description": "Specifies whether to use transacted mode",
				"type": "boolean",
				"$comment": "group:transaction"
			},
			"transactedInOut": {
				"title": "Transacted In Out",
				"description": "Specifies whether InOut operations (request reply) default to using transacted mode If this flag is set to true, then Spring JmsTemplate will have sessionTransacted set to true, and the acknowledgeMode as transacted on the JmsTemplate used for InOut operations. Note from Spring JMS: that within a JTA transaction, the parameters passed to createQueue, createTopic methods are not taken into account. Depending on the Java EE transaction context, the container makes its own decisions on these values. Analogously, these parameters are not taken into account within a locally managed transaction either, since Spring JMS operates on an existing JMS Session in this case. Setting this flag to true will use a short local JMS transaction when running outside of a managed transaction, and a synchronized local JMS transaction in case of a managed transaction (other than an XA transaction) being present. This has the effect of a local JMS transaction being managed alongside the main transaction (which might be a native JDBC transaction), with the JMS transaction committing right after the main transaction.",
				"type": "boolean",
				"$comment": "group:transaction"
			},
			"lazyCreateTransactionManager": {
				"title": "Lazy Create Transaction Manager",
				"description": "If true, Camel will create a JmsTransactionManager, if there is no transactionManager injected when option transacted=true.",
				"type": "boolean",
				"$comment": "group:transaction (advanced)",
				"default": true
			},
			"transactionManager": {
				"title": "Transaction Manager",
				"description": "The Spring transaction manager to use.",
				"type": "string",
				"$comment": "group:transaction (advanced)",
				"format": "bean:org.springframework.transaction.PlatformTransactionManager"
			},
			"transactionName": {
				"title": "Transaction Name",
				"description": "The name of the transaction to use.",
				"type": "string",
				"$comment": "group:transaction (advanced)"
			},
			"transactionTimeout": {
				"title": "Transaction Timeout",
				"description": "The timeout value of the transaction (in seconds), if using transacted mode.",
				"type": "integer",
				"$comment": "group:transaction (advanced)",
				"default": -1
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"destinationName"
		]
	},
	"activemq6": {
		"properties": {
			"destinationType": {
				"title": "Destination Type",
				"description": "The kind of destination to use",
				"type": "string",
				"enum": [
					"queue",
					"topic",
					"temp-queue",
					"temp-topic"
				],
				"$comment": "group:common",
				"default": "queue"
			},
			"destinationName": {
				"title": "Destination Name",
				"description": "Name of the queue or topic to use as destination",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions with JMS 1.1.",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:jakarta.jms.ConnectionFactory"
			},
			"disableReplyTo": {
				"title": "Disable Reply To",
				"description": "Specifies whether Camel ignores the JMSReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the JMSReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"durableSubscriptionName": {
				"title": "Durable Subscription Name",
				"description": "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.",
				"type": "string",
				"$comment": "group:common"
			},
			"jmsMessageType": {
				"title": "Jms Message Type",
				"description": "Allows you to force the use of a specific jakarta.jms.Message implementation for sending JMS messages. Possible values are: Bytes, Map, Object, Stream, Text. By default, Camel would determine which JMS message type to use from the In body type. This option allows you to specify it.",
				"type": "string",
				"enum": [
					"Bytes",
					"Map",
					"Object",
					"Stream",
					"Text"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.jms.JmsMessageType"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "Provides an explicit ReplyTo destination (overrides any incoming value of Message.getJMSReplyTo() in consumer).",
				"type": "string",
				"$comment": "group:common"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"acknowledgementModeName": {
				"title": "Acknowledgement Mode Name",
				"description": "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
				"type": "string",
				"enum": [
					"SESSION_TRANSACTED",
					"CLIENT_ACKNOWLEDGE",
					"AUTO_ACKNOWLEDGE",
					"DUPS_OK_ACKNOWLEDGE"
				],
				"$comment": "group:consumer",
				"default": "AUTO_ACKNOWLEDGE"
			},
			"artemisConsumerPriority": {
				"title": "Artemis Consumer Priority",
				"description": "Consumer priorities allow you to ensure that high priority consumers receive messages while they are active. Normally, active consumers connected to a queue receive messages from it in a round-robin fashion. When consumer priorities are in use, messages are delivered round-robin if multiple active consumers exist with the same high priority. Messages will only going to lower priority consumers when the high priority consumers do not have credit available to consume the message, or those high priority consumers have declined to accept the message (for instance because it does not meet the criteria of any selectors associated with the consumer).",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"asyncConsumer": {
				"title": "Async Consumer",
				"description": "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"autoStartup": {
				"title": "Auto Startup",
				"description": "Specifies whether the consumer container should auto-startup.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"cacheLevel": {
				"title": "Cache Level",
				"description": "Sets the cache level by ID for the underlying JMS resources. See cacheLevelName option for more details.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"cacheLevelName": {
				"title": "Cache Level Name",
				"description": "Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER, CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.",
				"type": "string",
				"enum": [
					"CACHE_AUTO",
					"CACHE_CONNECTION",
					"CACHE_CONSUMER",
					"CACHE_NONE",
					"CACHE_SESSION"
				],
				"$comment": "group:consumer",
				"default": "CACHE_AUTO"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"maxConcurrentConsumers": {
				"title": "Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"replyToDeliveryPersistent": {
				"title": "Reply To Delivery Persistent",
				"description": "Specifies whether to use persistent delivery by default for replies.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"selector": {
				"title": "Selector",
				"description": "Sets the JMS selector to use",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscriptionDurable": {
				"title": "Subscription Durable",
				"description": "Set whether to make the subscription durable. The durable subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a durable subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"subscriptionName": {
				"title": "Subscription Name",
				"description": "Set the name of a subscription to create. To be applied in case of a topic (pub-sub domain) with a shared or durable subscription. The subscription name needs to be unique within this client's JMS client id. Default is the class name of the specified message listener. Note: Only 1 concurrent consumer (which is the default of this message listener container) is allowed for each subscription, except for a shared subscription (which requires JMS 2.0).",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscriptionShared": {
				"title": "Subscription Shared",
				"description": "Set whether to make the subscription shared. The shared subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a shared subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Note that shared subscriptions may also be durable, so this flag can (and often will) be combined with subscriptionDurable as well. Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well. Requires a JMS 2.0 compatible message broker.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"acceptMessagesWhileStopping": {
				"title": "Accept Messages While Stopping",
				"description": "Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option, if you start and stop JMS routes at runtime, while there are still messages enqueued on the queue. If this option is false, and you stop the JMS route, then messages may be rejected, and the JMS broker would have to attempt redeliveries, which yet again may be rejected, and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"allowReplyManagerQuickStop": {
				"title": "Allow Reply Manager Quick Stop",
				"description": "Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case JmsConfiguration#isAcceptMessagesWhileStopping is enabled, and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"consumerType": {
				"title": "Consumer Type",
				"description": "The consumer type to use, which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
				"type": "string",
				"enum": [
					"Simple",
					"Default",
					"Custom"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.ConsumerType",
				"default": "Default"
			},
			"defaultTaskExecutorType": {
				"title": "Default Task Executor Type",
				"description": "Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer, for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's ThreadPoolTaskExecutor with optimal values - cached thread-pool-like). If not set, it defaults to the previous behaviour, which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers.",
				"type": "string",
				"enum": [
					"ThreadPool",
					"SimpleAsync"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.DefaultTaskExecutorType"
			},
			"destinationOptions": {
				"title": "Destination Options",
				"description": "Destination Options are a way to provide extended configuration options to a JMS consumer without having to extend the JMS API. The options are encoded using URL query syntax in the destination name that the consumer is created on. See more details at https://activemq.apache.org/destination-options.",
				"type": "object",
				"$comment": "group:consumer (advanced)"
			},
			"eagerLoadingOfProperties": {
				"title": "Eager Loading Of Properties",
				"description": "Enables eager loading of JMS properties and payload as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties. See also the option eagerPoisonBody.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerPoisonBody": {
				"title": "Eager Poison Body",
				"description": "If eagerLoadingOfProperties is enabled and the JMS message payload (JMS body or JMS properties) is poison (cannot be read/mapped), then set this text as the message body instead so the message can be processed (the cause of the poison are already stored as exception on the Exchange). This can be turned off by setting eagerPoisonBody=false. See also the option eagerLoadingOfProperties.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "Poison JMS message due to ${exception.message}"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"exposeListenerSession": {
				"title": "Expose Listener Session",
				"description": "Specifies whether the listener session should be exposed when consuming messages.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"replyToConsumerType": {
				"title": "Reply To Consumer Type",
				"description": "The consumer type of the reply consumer (when doing request/reply), which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
				"type": "string",
				"enum": [
					"Simple",
					"Default",
					"Custom"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.ConsumerType",
				"default": "Default"
			},
			"replyToSameDestinationAllowed": {
				"title": "Reply To Same Destination Allowed",
				"description": "Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"taskExecutor": {
				"title": "Task Executor",
				"description": "Allows you to specify a custom task executor for consuming messages.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.springframework.core.task.TaskExecutor"
			},
			"deliveryDelay": {
				"title": "Delivery Delay",
				"description": "Sets delivery delay to use for send calls for JMS. This option requires JMS 2.0 compliant broker.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"deliveryMode": {
				"title": "Delivery Mode",
				"description": "Specifies the delivery mode to be used. Possible values are those defined by jakarta.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.",
				"type": "integer",
				"enum": [
					"1",
					"2"
				],
				"$comment": "group:producer"
			},
			"deliveryPersistent": {
				"title": "Delivery Persistent",
				"description": "Specifies whether persistent delivery is used by default.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"explicitQosEnabled": {
				"title": "Explicit Qos Enabled",
				"description": "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"formatDateHeadersToIso8601": {
				"title": "Format Date Headers To Iso8601",
				"description": "Sets whether JMS date properties should be formatted according to the ISO 8601 standard.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"preserveMessageQos": {
				"title": "Preserve Message Qos",
				"description": "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"priority": {
				"title": "Priority",
				"description": "Values greater than 1 specify the message priority when sending (where 1 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
				"type": "integer",
				"enum": [
					"1",
					"2",
					"3",
					"4",
					"5",
					"6",
					"7",
					"8",
					"9"
				],
				"$comment": "group:producer",
				"default": 4
			},
			"replyToConcurrentConsumers": {
				"title": "Reply To Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToMaxConcurrentConsumers": {
				"title": "Reply To Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"replyToOnTimeoutMaxConcurrentConsumers": {
				"title": "Reply To On Timeout Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToOverride": {
				"title": "Reply To Override",
				"description": "Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.",
				"type": "string",
				"$comment": "group:producer"
			},
			"replyToType": {
				"title": "Reply To Type",
				"description": "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary, Shared, or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details, and especially the notes about the implications if running in a clustered environment, and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive.",
				"type": "string",
				"enum": [
					"Temporary",
					"Shared",
					"Exclusive"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jms.ReplyToType"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "20000"
			},
			"timeToLive": {
				"title": "Time To Live",
				"description": "When sending messages, specifies the time-to-live of the message (in milliseconds).",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"allowAdditionalHeaders": {
				"title": "Allow Additional Headers",
				"description": "This option is used to allow additional headers which may have values that are invalid according to JMS specification. For example, some message systems, such as WMQ, do this with header names using prefix JMS_IBM_MQMD_ containing values with byte array or other invalid types. You can specify multiple header names separated by comma, and use as suffix for wildcard matching.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"alwaysCopyMessage": {
				"title": "Always Copy Message",
				"description": "If true, Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations, such as when a replyToDestinationSelectorName is set (incidentally, Camel will set the alwaysCopyMessage option to true, if a replyToDestinationSelectorName is set)",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"correlationProperty": {
				"title": "Correlation Property",
				"description": "When using InOut exchange pattern use this JMS property instead of JMSCorrelationID JMS property to correlate messages. If set messages will be correlated solely on the value of this property JMSCorrelationID property will be ignored and not set by Camel.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"disableTimeToLive": {
				"title": "Disable Time To Live",
				"description": "Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"forceSendOriginalMessage": {
				"title": "Force Send Original Message",
				"description": "When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"includeSentJMSMessageID": {
				"title": "Include Sent JMSMessage ID",
				"description": "Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"replyToCacheLevelName": {
				"title": "Reply To Cache Level Name",
				"description": "Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed, and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION.",
				"type": "string",
				"enum": [
					"CACHE_AUTO",
					"CACHE_CONNECTION",
					"CACHE_CONSUMER",
					"CACHE_NONE",
					"CACHE_SESSION"
				],
				"$comment": "group:producer (advanced)"
			},
			"replyToDestinationSelectorName": {
				"title": "Reply To Destination Selector Name",
				"description": "Sets the JMS Selector using the fixed name to be used so you can filter out your own replies from the others when using a shared queue (that is, if you are not using a temporary reply queue).",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"streamMessageTypeEnabled": {
				"title": "Stream Message Type Enabled",
				"description": "Sets whether StreamMessage type is enabled or not. Message payloads of streaming kind such as files, InputStream, etc will either by sent as BytesMessage or StreamMessage. This option controls which kind will be used. By default BytesMessage is used which enforces the entire message payload to be read into memory. By enabling this option the message payload is read into memory in chunks and each chunk is then written to the StreamMessage until no more data.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"allowSerializedHeaders": {
				"title": "Allow Serialized Headers",
				"description": "Controls whether or not to include serialized headers. Applies only when transferExchange is true. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"artemisStreamingEnabled": {
				"title": "Artemis Streaming Enabled",
				"description": "Whether optimizing for Apache Artemis streaming mode. This can reduce memory overhead when using Artemis with JMS StreamMessage types. This option must only be enabled if Apache Artemis is being used.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStartListener": {
				"title": "Async Start Listener",
				"description": "Whether to startup the JmsConsumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or fail-over. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStopListener": {
				"title": "Async Stop Listener",
				"description": "Whether to stop the JmsConsumer message listener asynchronously, when stopping a route.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"destinationResolver": {
				"title": "Destination Resolver",
				"description": "A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example, to lookup the real destination in a JNDI registry).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.jms.support.destination.DestinationResolver"
			},
			"errorHandler": {
				"title": "Error Handler",
				"description": "Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level, if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure, than having to code a custom errorHandler.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.util.ErrorHandler"
			},
			"exceptionListener": {
				"title": "Exception Listener",
				"description": "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.jms.ExceptionListener"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"idleConsumerLimit": {
				"title": "Idle Consumer Limit",
				"description": "Specify the limit for the number of consumers that are allowed to be idle at any given time.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"idleReceivesPerTaskLimit": {
				"title": "Idle Receives Per Task Limit",
				"description": "Marks the consumer as idle after the specified number of idle receives have been reached. An idle receive is counted from the moment a null message is returned by the receiver after the potential setReceiveTimeout elapsed. This gives the opportunity to check if the idle task count exceeds setIdleTaskExecutionLimit and based on that decide if the task needs to be re-scheduled or not, saving resources that would otherwise be held. This setting differs from setMaxMessagesPerTask where the task is released and re-scheduled after this limit is reached, no matter if the received messages were null or non-null messages. This setting alone can be inflexible if one desires to have a large enough batch for each task but requires a quick(er) release from the moment there are no more messages to process. This setting differs from setIdleTaskExecutionLimit where this limit decides after how many iterations of being marked as idle, a task is released. For example: If setMaxMessagesPerTask is set to '500' and #setIdleReceivesPerTaskLimit is set to '60' and setReceiveTimeout is set to '1000' and setIdleTaskExecutionLimit is set to '1', then 500 messages per task would be processed unless there is a subsequent number of 60 idle messages received, the task would be marked as idle and released. This also means that after the last message was processed, the task would be released after 60 seconds as long as no new messages appear.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"idleTaskExecutionLimit": {
				"title": "Idle Task Execution Limit",
				"description": "Specifies the limit for idle executions of a receive task, not having received any message within its execution. If this limit is reached, the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"includeAllJMSXProperties": {
				"title": "Include All JMSXProperties",
				"description": "Whether to include all JMSX prefixed properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"jmsKeyFormatStrategy": {
				"title": "Jms Key Format Strategy",
				"description": "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
				"type": "string",
				"enum": [
					"default",
					"passthrough"
				],
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.JmsKeyFormatStrategy"
			},
			"mapJmsMessage": {
				"title": "Map Jms Message",
				"description": "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as jakarta.jms.TextMessage to a String etc.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"maxMessagesPerTask": {
				"title": "Max Messages Per Task",
				"description": "The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max), then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": -1
			},
			"messageConverter": {
				"title": "Message Converter",
				"description": "To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a jakarta.jms.Message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.jms.support.converter.MessageConverter"
			},
			"messageCreatedStrategy": {
				"title": "Message Created Strategy",
				"description": "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of jakarta.jms.Message objects when Camel is sending a JMS message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.MessageCreatedStrategy"
			},
			"messageIdEnabled": {
				"title": "Message Id Enabled",
				"description": "When sending, specifies whether message IDs should be added. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"messageListenerContainerFactory": {
				"title": "Message Listener Container Factory",
				"description": "Registry ID of the MessageListenerContainerFactory used to determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use to consume messages. Setting this will automatically set consumerType to Custom.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.MessageListenerContainerFactory"
			},
			"messageTimestampEnabled": {
				"title": "Message Timestamp Enabled",
				"description": "Specifies whether timestamps should be enabled by default on sending messages. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint the timestamp must be set to its normal value.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"pubSubNoLocal": {
				"title": "Pub Sub No Local",
				"description": "Specifies whether to inhibit the delivery of messages published by its own connection.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"receiveTimeout": {
				"title": "Receive Timeout",
				"description": "The timeout for receiving messages (in milliseconds).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"recoveryInterval": {
				"title": "Recovery Interval",
				"description": "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "5000"
			},
			"requestTimeoutCheckerInterval": {
				"title": "Request Timeout Checker Interval",
				"description": "Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs, then you can lower this interval, to check more frequently. The timeout is determined by the option requestTimeout.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"temporaryQueueResolver": {
				"title": "Temporary Queue Resolver",
				"description": "A pluggable TemporaryQueueResolver that allows you to use your own resolver for creating temporary queues (some messaging systems has special requirements for creating temporary queues).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.TemporaryQueueResolver"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a jakarta.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transferExchange": {
				"title": "Transfer Exchange",
				"description": "You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side, so Camel knows the payloads is an Exchange and not a regular payload. Use this with caution as the data is using Java Object serialization and requires the receiver to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumers having to use compatible Camel versions!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"useMessageIDAsCorrelationID": {
				"title": "Use Message IDAs Correlation ID",
				"description": "Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"waitForProvisionCorrelationToBeUpdatedCounter": {
				"title": "Wait For Provision Correlation To Be Updated Counter",
				"description": "Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 50
			},
			"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime": {
				"title": "Wait For Provision Correlation To Be Updated Thread Sleeping Time",
				"description": "Interval in millis to sleep each time while waiting for provisional correlation id to be updated.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "100"
			},
			"waitForTemporaryReplyToToBeUpdatedCounter": {
				"title": "Wait For Temporary Reply To To Be Updated Counter",
				"description": "Number of times to wait for temporary replyTo queue to be created and ready when doing request/reply over JMS.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 200
			},
			"waitForTemporaryReplyToToBeUpdatedThreadSleepingTime": {
				"title": "Wait For Temporary Reply To To Be Updated Thread Sleeping Time",
				"description": "Interval in millis to sleep each time while waiting for temporary replyTo queue to be ready.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "100"
			},
			"errorHandlerLoggingLevel": {
				"title": "Error Handler Logging Level",
				"description": "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:logging",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"errorHandlerLogStackTrace": {
				"title": "Error Handler Log Stack Trace",
				"description": "Allows to control whether stack-traces should be logged or not, by the default errorHandler.",
				"type": "boolean",
				"$comment": "group:logging",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"transacted": {
				"title": "Transacted",
				"description": "Specifies whether to use transacted mode",
				"type": "boolean",
				"$comment": "group:transaction"
			},
			"transactedInOut": {
				"title": "Transacted In Out",
				"description": "Specifies whether InOut operations (request reply) default to using transacted mode If this flag is set to true, then Spring JmsTemplate will have sessionTransacted set to true, and the acknowledgeMode as transacted on the JmsTemplate used for InOut operations. Note from Spring JMS: that within a JTA transaction, the parameters passed to createQueue, createTopic methods are not taken into account. Depending on the Java EE transaction context, the container makes its own decisions on these values. Analogously, these parameters are not taken into account within a locally managed transaction either, since Spring JMS operates on an existing JMS Session in this case. Setting this flag to true will use a short local JMS transaction when running outside of a managed transaction, and a synchronized local JMS transaction in case of a managed transaction (other than an XA transaction) being present. This has the effect of a local JMS transaction being managed alongside the main transaction (which might be a native JDBC transaction), with the JMS transaction committing right after the main transaction.",
				"type": "boolean",
				"$comment": "group:transaction"
			},
			"lazyCreateTransactionManager": {
				"title": "Lazy Create Transaction Manager",
				"description": "If true, Camel will create a JmsTransactionManager, if there is no transactionManager injected when option transacted=true.",
				"type": "boolean",
				"$comment": "group:transaction (advanced)",
				"default": true
			},
			"transactionManager": {
				"title": "Transaction Manager",
				"description": "The Spring transaction manager to use.",
				"type": "string",
				"$comment": "group:transaction (advanced)",
				"format": "bean:org.springframework.transaction.PlatformTransactionManager"
			},
			"transactionName": {
				"title": "Transaction Name",
				"description": "The name of the transaction to use.",
				"type": "string",
				"$comment": "group:transaction (advanced)"
			},
			"transactionTimeout": {
				"title": "Transaction Timeout",
				"description": "The timeout value of the transaction (in seconds), if using transacted mode.",
				"type": "integer",
				"$comment": "group:transaction (advanced)",
				"default": -1
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"destinationName"
		]
	},
	"amqp": {
		"properties": {
			"destinationType": {
				"title": "Destination Type",
				"description": "The kind of destination to use",
				"type": "string",
				"enum": [
					"queue",
					"topic",
					"temp-queue",
					"temp-topic"
				],
				"$comment": "group:common",
				"default": "queue"
			},
			"destinationName": {
				"title": "Destination Name",
				"description": "Name of the queue or topic to use as destination",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions with JMS 1.1.",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:jakarta.jms.ConnectionFactory"
			},
			"disableReplyTo": {
				"title": "Disable Reply To",
				"description": "Specifies whether Camel ignores the JMSReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the JMSReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"durableSubscriptionName": {
				"title": "Durable Subscription Name",
				"description": "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.",
				"type": "string",
				"$comment": "group:common"
			},
			"jmsMessageType": {
				"title": "Jms Message Type",
				"description": "Allows you to force the use of a specific jakarta.jms.Message implementation for sending JMS messages. Possible values are: Bytes, Map, Object, Stream, Text. By default, Camel would determine which JMS message type to use from the In body type. This option allows you to specify it.",
				"type": "string",
				"enum": [
					"Bytes",
					"Map",
					"Object",
					"Stream",
					"Text"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.jms.JmsMessageType"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "Provides an explicit ReplyTo destination (overrides any incoming value of Message.getJMSReplyTo() in consumer).",
				"type": "string",
				"$comment": "group:common"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"acknowledgementModeName": {
				"title": "Acknowledgement Mode Name",
				"description": "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
				"type": "string",
				"enum": [
					"SESSION_TRANSACTED",
					"CLIENT_ACKNOWLEDGE",
					"AUTO_ACKNOWLEDGE",
					"DUPS_OK_ACKNOWLEDGE"
				],
				"$comment": "group:consumer",
				"default": "AUTO_ACKNOWLEDGE"
			},
			"artemisConsumerPriority": {
				"title": "Artemis Consumer Priority",
				"description": "Consumer priorities allow you to ensure that high priority consumers receive messages while they are active. Normally, active consumers connected to a queue receive messages from it in a round-robin fashion. When consumer priorities are in use, messages are delivered round-robin if multiple active consumers exist with the same high priority. Messages will only going to lower priority consumers when the high priority consumers do not have credit available to consume the message, or those high priority consumers have declined to accept the message (for instance because it does not meet the criteria of any selectors associated with the consumer).",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"asyncConsumer": {
				"title": "Async Consumer",
				"description": "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"autoStartup": {
				"title": "Auto Startup",
				"description": "Specifies whether the consumer container should auto-startup.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"cacheLevel": {
				"title": "Cache Level",
				"description": "Sets the cache level by ID for the underlying JMS resources. See cacheLevelName option for more details.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"cacheLevelName": {
				"title": "Cache Level Name",
				"description": "Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER, CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.",
				"type": "string",
				"enum": [
					"CACHE_AUTO",
					"CACHE_CONNECTION",
					"CACHE_CONSUMER",
					"CACHE_NONE",
					"CACHE_SESSION"
				],
				"$comment": "group:consumer",
				"default": "CACHE_AUTO"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"maxConcurrentConsumers": {
				"title": "Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"replyToDeliveryPersistent": {
				"title": "Reply To Delivery Persistent",
				"description": "Specifies whether to use persistent delivery by default for replies.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"selector": {
				"title": "Selector",
				"description": "Sets the JMS selector to use",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscriptionDurable": {
				"title": "Subscription Durable",
				"description": "Set whether to make the subscription durable. The durable subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a durable subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"subscriptionName": {
				"title": "Subscription Name",
				"description": "Set the name of a subscription to create. To be applied in case of a topic (pub-sub domain) with a shared or durable subscription. The subscription name needs to be unique within this client's JMS client id. Default is the class name of the specified message listener. Note: Only 1 concurrent consumer (which is the default of this message listener container) is allowed for each subscription, except for a shared subscription (which requires JMS 2.0).",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscriptionShared": {
				"title": "Subscription Shared",
				"description": "Set whether to make the subscription shared. The shared subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a shared subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Note that shared subscriptions may also be durable, so this flag can (and often will) be combined with subscriptionDurable as well. Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well. Requires a JMS 2.0 compatible message broker.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"acceptMessagesWhileStopping": {
				"title": "Accept Messages While Stopping",
				"description": "Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option, if you start and stop JMS routes at runtime, while there are still messages enqueued on the queue. If this option is false, and you stop the JMS route, then messages may be rejected, and the JMS broker would have to attempt redeliveries, which yet again may be rejected, and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"allowReplyManagerQuickStop": {
				"title": "Allow Reply Manager Quick Stop",
				"description": "Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case JmsConfiguration#isAcceptMessagesWhileStopping is enabled, and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"consumerType": {
				"title": "Consumer Type",
				"description": "The consumer type to use, which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
				"type": "string",
				"enum": [
					"Simple",
					"Default",
					"Custom"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.ConsumerType",
				"default": "Default"
			},
			"defaultTaskExecutorType": {
				"title": "Default Task Executor Type",
				"description": "Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer, for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's ThreadPoolTaskExecutor with optimal values - cached thread-pool-like). If not set, it defaults to the previous behaviour, which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers.",
				"type": "string",
				"enum": [
					"ThreadPool",
					"SimpleAsync"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.DefaultTaskExecutorType"
			},
			"eagerLoadingOfProperties": {
				"title": "Eager Loading Of Properties",
				"description": "Enables eager loading of JMS properties and payload as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties. See also the option eagerPoisonBody.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerPoisonBody": {
				"title": "Eager Poison Body",
				"description": "If eagerLoadingOfProperties is enabled and the JMS message payload (JMS body or JMS properties) is poison (cannot be read/mapped), then set this text as the message body instead so the message can be processed (the cause of the poison are already stored as exception on the Exchange). This can be turned off by setting eagerPoisonBody=false. See also the option eagerLoadingOfProperties.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "Poison JMS message due to ${exception.message}"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"exposeListenerSession": {
				"title": "Expose Listener Session",
				"description": "Specifies whether the listener session should be exposed when consuming messages.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"replyToConsumerType": {
				"title": "Reply To Consumer Type",
				"description": "The consumer type of the reply consumer (when doing request/reply), which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
				"type": "string",
				"enum": [
					"Simple",
					"Default",
					"Custom"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.ConsumerType",
				"default": "Default"
			},
			"replyToSameDestinationAllowed": {
				"title": "Reply To Same Destination Allowed",
				"description": "Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"taskExecutor": {
				"title": "Task Executor",
				"description": "Allows you to specify a custom task executor for consuming messages.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.springframework.core.task.TaskExecutor"
			},
			"deliveryDelay": {
				"title": "Delivery Delay",
				"description": "Sets delivery delay to use for send calls for JMS. This option requires JMS 2.0 compliant broker.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"deliveryMode": {
				"title": "Delivery Mode",
				"description": "Specifies the delivery mode to be used. Possible values are those defined by jakarta.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.",
				"type": "integer",
				"enum": [
					"1",
					"2"
				],
				"$comment": "group:producer"
			},
			"deliveryPersistent": {
				"title": "Delivery Persistent",
				"description": "Specifies whether persistent delivery is used by default.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"explicitQosEnabled": {
				"title": "Explicit Qos Enabled",
				"description": "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"formatDateHeadersToIso8601": {
				"title": "Format Date Headers To Iso8601",
				"description": "Sets whether JMS date properties should be formatted according to the ISO 8601 standard.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"preserveMessageQos": {
				"title": "Preserve Message Qos",
				"description": "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"priority": {
				"title": "Priority",
				"description": "Values greater than 1 specify the message priority when sending (where 1 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
				"type": "integer",
				"enum": [
					"1",
					"2",
					"3",
					"4",
					"5",
					"6",
					"7",
					"8",
					"9"
				],
				"$comment": "group:producer",
				"default": 4
			},
			"replyToConcurrentConsumers": {
				"title": "Reply To Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToMaxConcurrentConsumers": {
				"title": "Reply To Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"replyToOnTimeoutMaxConcurrentConsumers": {
				"title": "Reply To On Timeout Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToOverride": {
				"title": "Reply To Override",
				"description": "Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.",
				"type": "string",
				"$comment": "group:producer"
			},
			"replyToType": {
				"title": "Reply To Type",
				"description": "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary, Shared, or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details, and especially the notes about the implications if running in a clustered environment, and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive.",
				"type": "string",
				"enum": [
					"Temporary",
					"Shared",
					"Exclusive"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jms.ReplyToType"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "20000"
			},
			"timeToLive": {
				"title": "Time To Live",
				"description": "When sending messages, specifies the time-to-live of the message (in milliseconds).",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"allowAdditionalHeaders": {
				"title": "Allow Additional Headers",
				"description": "This option is used to allow additional headers which may have values that are invalid according to JMS specification. For example, some message systems, such as WMQ, do this with header names using prefix JMS_IBM_MQMD_ containing values with byte array or other invalid types. You can specify multiple header names separated by comma, and use as suffix for wildcard matching.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"alwaysCopyMessage": {
				"title": "Always Copy Message",
				"description": "If true, Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations, such as when a replyToDestinationSelectorName is set (incidentally, Camel will set the alwaysCopyMessage option to true, if a replyToDestinationSelectorName is set)",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"correlationProperty": {
				"title": "Correlation Property",
				"description": "When using InOut exchange pattern use this JMS property instead of JMSCorrelationID JMS property to correlate messages. If set messages will be correlated solely on the value of this property JMSCorrelationID property will be ignored and not set by Camel.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"disableTimeToLive": {
				"title": "Disable Time To Live",
				"description": "Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"forceSendOriginalMessage": {
				"title": "Force Send Original Message",
				"description": "When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"includeSentJMSMessageID": {
				"title": "Include Sent JMSMessage ID",
				"description": "Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"replyToCacheLevelName": {
				"title": "Reply To Cache Level Name",
				"description": "Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed, and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION.",
				"type": "string",
				"enum": [
					"CACHE_AUTO",
					"CACHE_CONNECTION",
					"CACHE_CONSUMER",
					"CACHE_NONE",
					"CACHE_SESSION"
				],
				"$comment": "group:producer (advanced)"
			},
			"replyToDestinationSelectorName": {
				"title": "Reply To Destination Selector Name",
				"description": "Sets the JMS Selector using the fixed name to be used so you can filter out your own replies from the others when using a shared queue (that is, if you are not using a temporary reply queue).",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"streamMessageTypeEnabled": {
				"title": "Stream Message Type Enabled",
				"description": "Sets whether StreamMessage type is enabled or not. Message payloads of streaming kind such as files, InputStream, etc will either by sent as BytesMessage or StreamMessage. This option controls which kind will be used. By default BytesMessage is used which enforces the entire message payload to be read into memory. By enabling this option the message payload is read into memory in chunks and each chunk is then written to the StreamMessage until no more data.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"allowSerializedHeaders": {
				"title": "Allow Serialized Headers",
				"description": "Controls whether or not to include serialized headers. Applies only when transferExchange is true. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"artemisStreamingEnabled": {
				"title": "Artemis Streaming Enabled",
				"description": "Whether optimizing for Apache Artemis streaming mode. This can reduce memory overhead when using Artemis with JMS StreamMessage types. This option must only be enabled if Apache Artemis is being used.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStartListener": {
				"title": "Async Start Listener",
				"description": "Whether to startup the JmsConsumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or fail-over. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStopListener": {
				"title": "Async Stop Listener",
				"description": "Whether to stop the JmsConsumer message listener asynchronously, when stopping a route.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"destinationResolver": {
				"title": "Destination Resolver",
				"description": "A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example, to lookup the real destination in a JNDI registry).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.jms.support.destination.DestinationResolver"
			},
			"errorHandler": {
				"title": "Error Handler",
				"description": "Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level, if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure, than having to code a custom errorHandler.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.util.ErrorHandler"
			},
			"exceptionListener": {
				"title": "Exception Listener",
				"description": "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.jms.ExceptionListener"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"idleConsumerLimit": {
				"title": "Idle Consumer Limit",
				"description": "Specify the limit for the number of consumers that are allowed to be idle at any given time.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"idleReceivesPerTaskLimit": {
				"title": "Idle Receives Per Task Limit",
				"description": "Marks the consumer as idle after the specified number of idle receives have been reached. An idle receive is counted from the moment a null message is returned by the receiver after the potential setReceiveTimeout elapsed. This gives the opportunity to check if the idle task count exceeds setIdleTaskExecutionLimit and based on that decide if the task needs to be re-scheduled or not, saving resources that would otherwise be held. This setting differs from setMaxMessagesPerTask where the task is released and re-scheduled after this limit is reached, no matter if the received messages were null or non-null messages. This setting alone can be inflexible if one desires to have a large enough batch for each task but requires a quick(er) release from the moment there are no more messages to process. This setting differs from setIdleTaskExecutionLimit where this limit decides after how many iterations of being marked as idle, a task is released. For example: If setMaxMessagesPerTask is set to '500' and #setIdleReceivesPerTaskLimit is set to '60' and setReceiveTimeout is set to '1000' and setIdleTaskExecutionLimit is set to '1', then 500 messages per task would be processed unless there is a subsequent number of 60 idle messages received, the task would be marked as idle and released. This also means that after the last message was processed, the task would be released after 60 seconds as long as no new messages appear.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"idleTaskExecutionLimit": {
				"title": "Idle Task Execution Limit",
				"description": "Specifies the limit for idle executions of a receive task, not having received any message within its execution. If this limit is reached, the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"includeAllJMSXProperties": {
				"title": "Include All JMSXProperties",
				"description": "Whether to include all JMSX prefixed properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"jmsKeyFormatStrategy": {
				"title": "Jms Key Format Strategy",
				"description": "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
				"type": "string",
				"enum": [
					"default",
					"passthrough"
				],
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.JmsKeyFormatStrategy"
			},
			"mapJmsMessage": {
				"title": "Map Jms Message",
				"description": "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as jakarta.jms.TextMessage to a String etc.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"maxMessagesPerTask": {
				"title": "Max Messages Per Task",
				"description": "The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max), then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": -1
			},
			"messageConverter": {
				"title": "Message Converter",
				"description": "To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a jakarta.jms.Message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.jms.support.converter.MessageConverter"
			},
			"messageCreatedStrategy": {
				"title": "Message Created Strategy",
				"description": "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of jakarta.jms.Message objects when Camel is sending a JMS message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.MessageCreatedStrategy"
			},
			"messageIdEnabled": {
				"title": "Message Id Enabled",
				"description": "When sending, specifies whether message IDs should be added. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"messageListenerContainerFactory": {
				"title": "Message Listener Container Factory",
				"description": "Registry ID of the MessageListenerContainerFactory used to determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use to consume messages. Setting this will automatically set consumerType to Custom.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.MessageListenerContainerFactory"
			},
			"messageTimestampEnabled": {
				"title": "Message Timestamp Enabled",
				"description": "Specifies whether timestamps should be enabled by default on sending messages. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint the timestamp must be set to its normal value.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"pubSubNoLocal": {
				"title": "Pub Sub No Local",
				"description": "Specifies whether to inhibit the delivery of messages published by its own connection.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"receiveTimeout": {
				"title": "Receive Timeout",
				"description": "The timeout for receiving messages (in milliseconds).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"recoveryInterval": {
				"title": "Recovery Interval",
				"description": "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "5000"
			},
			"requestTimeoutCheckerInterval": {
				"title": "Request Timeout Checker Interval",
				"description": "Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs, then you can lower this interval, to check more frequently. The timeout is determined by the option requestTimeout.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"temporaryQueueResolver": {
				"title": "Temporary Queue Resolver",
				"description": "A pluggable TemporaryQueueResolver that allows you to use your own resolver for creating temporary queues (some messaging systems has special requirements for creating temporary queues).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.TemporaryQueueResolver"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a jakarta.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transferExchange": {
				"title": "Transfer Exchange",
				"description": "You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side, so Camel knows the payloads is an Exchange and not a regular payload. Use this with caution as the data is using Java Object serialization and requires the receiver to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumers having to use compatible Camel versions!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"useMessageIDAsCorrelationID": {
				"title": "Use Message IDAs Correlation ID",
				"description": "Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"waitForProvisionCorrelationToBeUpdatedCounter": {
				"title": "Wait For Provision Correlation To Be Updated Counter",
				"description": "Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 50
			},
			"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime": {
				"title": "Wait For Provision Correlation To Be Updated Thread Sleeping Time",
				"description": "Interval in millis to sleep each time while waiting for provisional correlation id to be updated.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "100"
			},
			"waitForTemporaryReplyToToBeUpdatedCounter": {
				"title": "Wait For Temporary Reply To To Be Updated Counter",
				"description": "Number of times to wait for temporary replyTo queue to be created and ready when doing request/reply over JMS.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 200
			},
			"waitForTemporaryReplyToToBeUpdatedThreadSleepingTime": {
				"title": "Wait For Temporary Reply To To Be Updated Thread Sleeping Time",
				"description": "Interval in millis to sleep each time while waiting for temporary replyTo queue to be ready.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "100"
			},
			"errorHandlerLoggingLevel": {
				"title": "Error Handler Logging Level",
				"description": "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:logging",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"errorHandlerLogStackTrace": {
				"title": "Error Handler Log Stack Trace",
				"description": "Allows to control whether stack-traces should be logged or not, by the default errorHandler.",
				"type": "boolean",
				"$comment": "group:logging",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"transacted": {
				"title": "Transacted",
				"description": "Specifies whether to use transacted mode",
				"type": "boolean",
				"$comment": "group:transaction"
			},
			"transactedInOut": {
				"title": "Transacted In Out",
				"description": "Specifies whether InOut operations (request reply) default to using transacted mode If this flag is set to true, then Spring JmsTemplate will have sessionTransacted set to true, and the acknowledgeMode as transacted on the JmsTemplate used for InOut operations. Note from Spring JMS: that within a JTA transaction, the parameters passed to createQueue, createTopic methods are not taken into account. Depending on the Java EE transaction context, the container makes its own decisions on these values. Analogously, these parameters are not taken into account within a locally managed transaction either, since Spring JMS operates on an existing JMS Session in this case. Setting this flag to true will use a short local JMS transaction when running outside of a managed transaction, and a synchronized local JMS transaction in case of a managed transaction (other than an XA transaction) being present. This has the effect of a local JMS transaction being managed alongside the main transaction (which might be a native JDBC transaction), with the JMS transaction committing right after the main transaction.",
				"type": "boolean",
				"$comment": "group:transaction"
			},
			"lazyCreateTransactionManager": {
				"title": "Lazy Create Transaction Manager",
				"description": "If true, Camel will create a JmsTransactionManager, if there is no transactionManager injected when option transacted=true.",
				"type": "boolean",
				"$comment": "group:transaction (advanced)",
				"default": true
			},
			"transactionManager": {
				"title": "Transaction Manager",
				"description": "The Spring transaction manager to use.",
				"type": "string",
				"$comment": "group:transaction (advanced)",
				"format": "bean:org.springframework.transaction.PlatformTransactionManager"
			},
			"transactionName": {
				"title": "Transaction Name",
				"description": "The name of the transaction to use.",
				"type": "string",
				"$comment": "group:transaction (advanced)"
			},
			"transactionTimeout": {
				"title": "Transaction Timeout",
				"description": "The timeout value of the transaction (in seconds), if using transacted mode.",
				"type": "integer",
				"$comment": "group:transaction (advanced)",
				"default": -1
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"destinationName"
		]
	},
	"arangodb": {
		"properties": {
			"database": {
				"title": "Database",
				"description": "database name",
				"type": "string",
				"$comment": "group:producer"
			},
			"documentCollection": {
				"title": "Document Collection",
				"description": "Collection name, when using ArangoDb as a Document Database. Set the documentCollection name when using the CRUD operation on the document database collections (SAVE_DOCUMENT , FIND_DOCUMENT_BY_KEY, UPDATE_DOCUMENT, DELETE_DOCUMENT).",
				"type": "string",
				"$comment": "group:producer"
			},
			"edgeCollection": {
				"title": "Edge Collection",
				"description": "Collection name of vertices, when using ArangoDb as a Graph Database. Set the edgeCollection name to perform CRUD operation on edges using these operations : SAVE_VERTEX, FIND_VERTEX_BY_KEY, UPDATE_VERTEX, DELETE_VERTEX. The graph attribute is mandatory.",
				"type": "string",
				"$comment": "group:producer"
			},
			"graph": {
				"title": "Graph",
				"description": "Graph name, when using ArangoDb as a Graph Database. Combine this attribute with one of the two attributes vertexCollection and edgeCollection.",
				"type": "string",
				"$comment": "group:producer"
			},
			"host": {
				"title": "Host",
				"description": "ArangoDB host. If host and port are default, this field is Optional.",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Operations to perform on ArangoDb. For the operation AQL_QUERY, no need to specify a collection or graph.",
				"type": "string",
				"enum": [
					"SAVE_DOCUMENT",
					"FIND_DOCUMENT_BY_KEY",
					"UPDATE_DOCUMENT",
					"DELETE_DOCUMENT",
					"AQL_QUERY",
					"SAVE_VERTEX",
					"FIND_VERTEX_BY_KEY",
					"UPDATE_VERTEX",
					"DELETE_VERTEX",
					"SAVE_EDGE",
					"FIND_EDGE_BY_KEY",
					"UPDATE_EDGE",
					"DELETE_EDGE"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.arangodb.ArangoDbOperation"
			},
			"port": {
				"title": "Port",
				"description": "ArangoDB exposed port. If host and port are default, this field is Optional.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"vertexCollection": {
				"title": "Vertex Collection",
				"description": "Collection name of vertices, when using ArangoDb as a Graph Database. Set the vertexCollection name to perform CRUD operation on vertices using these operations : SAVE_EDGE, FIND_EDGE_BY_KEY, UPDATE_EDGE, DELETE_EDGE. The graph attribute is mandatory.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"arangoDB": {
				"title": "Arango DB",
				"description": "To use an existing ArangDB client.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.arangodb.ArangoDB"
			},
			"vertx": {
				"title": "Vertx",
				"description": "To use an existing Vertx instance in the ArangoDB client.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.vertx.core.Vertx"
			},
			"password": {
				"title": "Password",
				"description": "ArangoDB password. If user and password are default, this field is Optional.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"user": {
				"title": "User",
				"description": "ArangoDB user. If user and password are default, this field is Optional.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"database"
		]
	},
	"as2": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"CLIENT",
					"SERVER",
					"RECEIPT"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.as2.internal.AS2ApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"$comment": "group:common"
			},
			"as2From": {
				"title": "As2 From",
				"description": "The value of the AS2From header of AS2 message.",
				"type": "string",
				"$comment": "group:common"
			},
			"as2MessageStructure": {
				"title": "As2 Message Structure",
				"description": "The structure of AS2 Message. One of: PLAIN - No encryption, no signature, SIGNED - No encryption, signature, ENCRYPTED - Encryption, no signature, ENCRYPTED_SIGNED - Encryption, signature",
				"type": "string",
				"enum": [
					"PLAIN",
					"SIGNED",
					"ENCRYPTED",
					"SIGNED_ENCRYPTED",
					"PLAIN_COMPRESSED",
					"COMPRESSED_SIGNED",
					"SIGNED_COMPRESSED",
					"ENCRYPTED_COMPRESSED",
					"ENCRYPTED_COMPRESSED_SIGNED",
					"ENCRYPTED_SIGNED_COMPRESSED"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.as2.api.AS2MessageStructure"
			},
			"as2To": {
				"title": "As2 To",
				"description": "The value of the AS2To header of AS2 message.",
				"type": "string",
				"$comment": "group:common"
			},
			"as2Version": {
				"title": "As2 Version",
				"description": "The version of the AS2 protocol.",
				"type": "string",
				"enum": [
					"1.0",
					"1.1"
				],
				"$comment": "group:common",
				"default": "1.1"
			},
			"asyncMdnPortNumber": {
				"title": "Async Mdn Port Number",
				"description": "The port number of asynchronous MDN server.",
				"type": "integer",
				"$comment": "group:common"
			},
			"attachedFileName": {
				"title": "Attached File Name",
				"description": "The name of the attached file",
				"type": "string",
				"$comment": "group:common"
			},
			"clientFqdn": {
				"title": "Client Fqdn",
				"description": "The Client Fully Qualified Domain Name (FQDN). Used in message ids sent by endpoint.",
				"type": "string",
				"$comment": "group:common",
				"default": "camel.apache.org"
			},
			"compressionAlgorithm": {
				"title": "Compression Algorithm",
				"description": "The algorithm used to compress EDI message.",
				"type": "string",
				"enum": [
					"ZLIB"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.as2.api.AS2CompressionAlgorithm"
			},
			"dispositionNotificationTo": {
				"title": "Disposition Notification To",
				"description": "The value of the Disposition-Notification-To header. Assigning a value to this parameter requests a message disposition notification (MDN) for the AS2 message.",
				"type": "string",
				"$comment": "group:common"
			},
			"ediMessageCharset": {
				"title": "Edi Message Charset",
				"description": "The charset of the content type of EDI message.",
				"type": "string",
				"$comment": "group:common",
				"default": "us-ascii"
			},
			"ediMessageTransferEncoding": {
				"title": "Edi Message Transfer Encoding",
				"description": "The transfer encoding of EDI message.",
				"type": "string",
				"$comment": "group:common"
			},
			"ediMessageType": {
				"title": "Edi Message Type",
				"description": "The content type of EDI message. One of application/edifact, application/edi-x12, application/edi-consent, application/xml",
				"type": "string",
				"enum": [
					"application/edifact",
					"application/edi-x12",
					"application/edi-consent",
					"application/xml"
				],
				"$comment": "group:common"
			},
			"from": {
				"title": "From",
				"description": "The value of the From header of AS2 message.",
				"type": "string",
				"$comment": "group:common"
			},
			"httpConnectionPoolSize": {
				"title": "Http Connection Pool Size",
				"description": "The maximum size of the connection pool for http connections (client only)",
				"type": "integer",
				"$comment": "group:common",
				"default": "5"
			},
			"httpConnectionPoolTtl": {
				"title": "Http Connection Pool Ttl",
				"description": "The time to live for connections in the connection pool (client only)",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.time.Duration",
				"default": "15m"
			},
			"httpConnectionTimeout": {
				"title": "Http Connection Timeout",
				"description": "The timeout of the http connection (client only)",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.time.Duration",
				"default": "5s"
			},
			"httpSocketTimeout": {
				"title": "Http Socket Timeout",
				"description": "The timeout of the underlying http socket (client only)",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.time.Duration",
				"default": "5s"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"mdnMessageTemplate": {
				"title": "Mdn Message Template",
				"description": "The template used to format MDN message",
				"type": "string",
				"$comment": "group:common"
			},
			"receiptDeliveryOption": {
				"title": "Receipt Delivery Option",
				"description": "The return URL that the message receiver should send an asynchronous MDN to. If not present the receipt is synchronous. (Client only)",
				"type": "string",
				"$comment": "group:common"
			},
			"requestUri": {
				"title": "Request Uri",
				"description": "The request URI of EDI message.",
				"type": "string",
				"$comment": "group:common",
				"default": "/"
			},
			"server": {
				"title": "Server",
				"description": "The value included in the Server message header identifying the AS2 Server.",
				"type": "string",
				"$comment": "group:common",
				"default": "Camel AS2 Server Endpoint"
			},
			"serverFqdn": {
				"title": "Server Fqdn",
				"description": "The Server Fully Qualified Domain Name (FQDN). Used in message ids sent by endpoint.",
				"type": "string",
				"$comment": "group:common",
				"default": "camel.apache.org"
			},
			"serverPortNumber": {
				"title": "Server Port Number",
				"description": "The port number of server.",
				"type": "integer",
				"$comment": "group:common"
			},
			"subject": {
				"title": "Subject",
				"description": "The value of Subject header of AS2 message.",
				"type": "string",
				"$comment": "group:common"
			},
			"targetHostname": {
				"title": "Target Hostname",
				"description": "The host name (IP or DNS name) of target host.",
				"type": "string",
				"$comment": "group:common"
			},
			"targetPortNumber": {
				"title": "Target Port Number",
				"description": "The port number of target host. -1 indicates the scheme default port.",
				"type": "integer",
				"$comment": "group:common",
				"default": "80"
			},
			"userAgent": {
				"title": "User Agent",
				"description": "The value included in the User-Agent message header identifying the AS2 user agent.",
				"type": "string",
				"$comment": "group:common",
				"default": "Camel AS2 Client Endpoint"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"decryptingPrivateKey": {
				"title": "Decrypting Private Key",
				"description": "The key used to encrypt the EDI message.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PrivateKey"
			},
			"encryptingAlgorithm": {
				"title": "Encrypting Algorithm",
				"description": "The algorithm used to encrypt EDI message.",
				"type": "string",
				"enum": [
					"AES128_CBC",
					"AES192_CBC",
					"AES256_CBC",
					"AES128_CCM",
					"AES192_CCM",
					"AES256_CCM",
					"AES128_GCM",
					"AES192_GCM",
					"AES256_GCM",
					"CAMELLIA128_CBC",
					"CAMELLIA192_CBC",
					"CAMELLIA256_CBC",
					"CAST5_CBC",
					"DES_CBC",
					"DES_EDE3_CBC",
					"GOST28147_GCFB",
					"IDEA_CBC",
					"RC2_CBC",
					"RC4",
					"SEED_CBC"
				],
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.as2.api.AS2EncryptionAlgorithm"
			},
			"encryptingCertificateChain": {
				"title": "Encrypting Certificate Chain",
				"description": "The chain of certificates used to encrypt EDI message.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.cert.Certificate[]"
			},
			"hostnameVerifier": {
				"title": "Hostname Verifier",
				"description": "Set hostname verifier for SSL session.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:javax.net.ssl.HostnameVerifier"
			},
			"signedReceiptMicAlgorithms": {
				"title": "Signed Receipt Mic Algorithms",
				"description": "The list of algorithms, in order of preference, requested to generate a message integrity check (MIC) returned in message disposition notification (MDN). Multiple algorithms can be separated by comma.",
				"type": "string",
				"$comment": "group:security"
			},
			"signingAlgorithm": {
				"title": "Signing Algorithm",
				"description": "The algorithm used to sign EDI message.",
				"type": "string",
				"enum": [
					"SHA3_224WITHRSA",
					"SHA3_256WITHRSA",
					"SHA3_384withRSA",
					"SHA3_512WITHRSA",
					"MD5WITHRSA",
					"SHA1WITHRSA",
					"MD2WITHRSA",
					"SHA224WITHRSA",
					"SHA256WITHRSA",
					"SHA384WITHRSA",
					"SHA512WITHRSA",
					"RIPEMD128WITHRSA",
					"RIPEMD160WITHRSA",
					"RIPEMD256WITHRSA",
					"SHA224WITHDSA",
					"SHA256WITHDSA",
					"SHA384WITHDSA",
					"SHA512WITHDSA",
					"SHA3_224WITHDSA",
					"SHA3_256WITHDSA",
					"SHA3_384WITHDSA",
					"SHA3_512WITHDSA",
					"SHA1WITHDSA",
					"SHA3_224WITHECDSA",
					"SHA3_256WITHECDSA",
					"SHA3_384WITHECDSA",
					"SHA3_512WITHECDSA",
					"SHA1WITHECDSA",
					"SHA224WITHECDSA",
					"SHA256WITHECDSA",
					"SHA384WITHECDSA",
					"SHA512WITHECDSA",
					"SHA1WITHPLAIN_ECDSA",
					"SHA224WITHPLAIN_ECDSA",
					"SHA256WITHPLAIN_ECDSA",
					"SHA384WITHPLAIN_ECDSA",
					"SHA512WITHPLAIN_ECDSA",
					"RIPEMD160WITHPLAIN_ECDSA",
					"SHA1WITHRSAANDMGF1",
					"SHA224WITHRSAANDMGF1",
					"SHA256WITHRSAANDMGF1",
					"SHA384WITHRSAANDMGF1",
					"SHA512WITHRSAANDMGF1",
					"SHA3_224WITHRSAANDMGF1",
					"SHA3_256WITHRSAANDMGF1",
					"SHA3_384WITHRSAANDMGF1",
					"SHA3_512WITHRSAANDMGF1"
				],
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.as2.api.AS2SignatureAlgorithm"
			},
			"signingCertificateChain": {
				"title": "Signing Certificate Chain",
				"description": "The chain of certificates used to sign EDI message.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.cert.Certificate[]"
			},
			"signingPrivateKey": {
				"title": "Signing Private Key",
				"description": "The key used to sign the EDI message.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PrivateKey"
			},
			"sslContext": {
				"title": "Ssl Context",
				"description": "Set SSL context for connection to remote server.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:javax.net.ssl.SSLContext"
			},
			"validateSigningCertificateChain": {
				"title": "Validate Signing Certificate Chain",
				"description": "Certificates to validate the message's signature against. If not supplied, validation will not take place. Server: validates the received message. Client: not yet implemented, should validate the MDN",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.cert.Certificate[]"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"asterisk": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of component",
				"type": "string",
				"$comment": "group:common"
			},
			"hostname": {
				"title": "Hostname",
				"description": "The hostname of the asterisk server",
				"type": "string",
				"$comment": "group:common"
			},
			"password": {
				"title": "Password",
				"description": "Login password",
				"type": "string",
				"$comment": "group:common",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Login username",
				"type": "string",
				"$comment": "group:common",
				"format": "password"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"action": {
				"title": "Action",
				"description": "What action to perform such as getting queue status, sip peers or extension state.",
				"type": "string",
				"enum": [
					"QUEUE_STATUS",
					"SIP_PEERS",
					"EXTENSION_STATE"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.asterisk.AsteriskAction"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"hostname",
			"password",
			"username"
		]
	},
	"atmosphere-websocket": {
		"properties": {
			"servicePath": {
				"title": "Service Path",
				"description": "Name of websocket endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"chunked": {
				"title": "Chunked",
				"description": "If this option is false the Servlet will disable the HTTP streaming and set the content-length header on the response",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"disableStreamCache": {
				"title": "Disable Stream Cache",
				"description": "Determines whether or not the raw input stream is cached or not. The Camel consumer (camel-servlet, camel-jetty etc.) will by default cache the input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The producer (camel-http) will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is (the stream can only be read once) as the message body.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"sendToAll": {
				"title": "Send To All",
				"description": "Whether to send to all (broadcast) or send to a single receiver.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"useStreaming": {
				"title": "Use Streaming",
				"description": "To enable streaming to send data as multiple text fragments.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:common (advanced)",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"httpBinding": {
				"title": "Http Binding",
				"description": "To use a custom HttpBinding to control the mapping between Camel message and HttpClient.",
				"type": "string",
				"$comment": "group:common (advanced)",
				"format": "bean:org.apache.camel.http.common.HttpBinding"
			},
			"async": {
				"title": "Async",
				"description": "Configure the consumer to work in async mode",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"httpMethodRestrict": {
				"title": "Http Method Restrict",
				"description": "Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"logException": {
				"title": "Log Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side the exception's stack trace will be logged when the exception stack trace is not sent in the response's body.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"matchOnUriPrefix": {
				"title": "Match On Uri Prefix",
				"description": "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"muteException": {
				"title": "Mute Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"responseBufferSize": {
				"title": "Response Buffer Size",
				"description": "To use a custom buffer size on the jakarta.servlet.ServletResponse.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"servletName": {
				"title": "Servlet Name",
				"description": "Name of the servlet to use",
				"type": "string",
				"$comment": "group:consumer",
				"default": "CamelServlet"
			},
			"attachmentMultipartBinding": {
				"title": "Attachment Multipart Binding",
				"description": "Whether to automatic bind multipart/form-data as attachments on the Camel Exchange. The options attachmentMultipartBinding=true and disableStreamCache=false cannot work together. Remove disableStreamCache to use AttachmentMultipartBinding. This is turn off by default as this may require servlet specific configuration to enable this when using Servlet's.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerCheckContentAvailable": {
				"title": "Eager Check Content Available",
				"description": "Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present. This can be turned on in case HTTP clients do not send streamed data.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"fileNameExtWhitelist": {
				"title": "File Name Ext Whitelist",
				"description": "Whitelist of accepted filename extensions for accepting uploaded files. Multiple extensions can be separated by comma, such as txt,xml.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"mapHttpMessageBody": {
				"title": "Map Http Message Body",
				"description": "If this option is true then IN exchange Body of the exchange will be mapped to HTTP body. Setting this to false will avoid the HTTP mapping.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"mapHttpMessageFormUrlEncodedBody": {
				"title": "Map Http Message Form Url Encoded Body",
				"description": "If this option is true then IN exchange Form Encoded body of the exchange will be mapped to HTTP. Setting this to false will avoid the HTTP Form Encoded body mapping.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"mapHttpMessageHeaders": {
				"title": "Map Http Message Headers",
				"description": "If this option is true then IN exchange Headers of the exchange will be mapped to HTTP headers. Setting this to false will avoid the HTTP Headers mapping.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"optionsEnabled": {
				"title": "Options Enabled",
				"description": "Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"traceEnabled": {
				"title": "Trace Enabled",
				"description": "Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"bridgeEndpoint": {
				"title": "Bridge Endpoint",
				"description": "If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"servicePath"
		]
	},
	"atom": {
		"properties": {
			"feedUri": {
				"title": "Feed Uri",
				"description": "The URI to the feed to poll.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sortEntries": {
				"title": "Sort Entries",
				"description": "Sets whether to sort entries by published date. Only works when splitEntries = true.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"splitEntries": {
				"title": "Split Entries",
				"description": "Sets whether or not entries should be sent individually or whether the entire feed should be sent as a single message",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"throttleEntries": {
				"title": "Throttle Entries",
				"description": "Sets whether all entries identified in a single feed poll should be delivered immediately. If true, only one entry is processed per delay. Only applicable when splitEntries = true.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"feedHeader": {
				"title": "Feed Header",
				"description": "Sets whether to add the feed object as a header.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"feedUri"
		]
	},
	"avro": {
		"properties": {
			"transport": {
				"title": "Transport",
				"description": "Transport to use, can be either http or netty",
				"type": "string",
				"enum": [
					"http",
					"netty"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.avro.AvroTransport"
			},
			"port": {
				"title": "Port",
				"description": "Port number to use",
				"type": "integer",
				"$comment": "group:common"
			},
			"host": {
				"title": "Host",
				"description": "Hostname to use",
				"type": "string",
				"$comment": "group:common"
			},
			"messageName": {
				"title": "Message Name",
				"description": "The name of the message to send.",
				"type": "string",
				"$comment": "group:common"
			},
			"protocol": {
				"title": "Protocol",
				"description": "Avro protocol to use",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.avro.Protocol"
			},
			"protocolClassName": {
				"title": "Protocol Class Name",
				"description": "Avro protocol to use defined by the FQN class name",
				"type": "string",
				"$comment": "group:common"
			},
			"protocolLocation": {
				"title": "Protocol Location",
				"description": "Avro protocol location",
				"type": "string",
				"$comment": "group:common"
			},
			"reflectionProtocol": {
				"title": "Reflection Protocol",
				"description": "If the protocol object provided is reflection protocol. Should be used only with protocol parameter because for protocolClassName protocol type will be auto-detected",
				"type": "boolean",
				"$comment": "group:common"
			},
			"singleParameter": {
				"title": "Single Parameter",
				"description": "If true, consumer parameter won't be wrapped into an array. Will fail if protocol specifies more than one parameter for the message",
				"type": "boolean",
				"$comment": "group:common"
			},
			"uriAuthority": {
				"title": "Uri Authority",
				"description": "Authority to use (username and password)",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"transport",
			"port",
			"host"
		]
	},
	"aws-bedrock": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"modelId": {
				"title": "Model Id",
				"description": "Define the model Id we are going to use",
				"type": "string",
				"enum": [
					"amazon.titan-text-express-v1",
					"amazon.titan-text-lite-v1",
					"amazon.titan-image-generator-v1",
					"amazon.titan-embed-text-v1",
					"ai21.j2-ultra-v1",
					"ai21.j2-mid-v1",
					"anthropic.claude-instant-v1",
					"anthropic.claude-v2",
					"anthropic.claude-v2:1",
					"anthropic.claude-3-sonnet-20240229-v1:0",
					"anthropic.claude-3-haiku-20240307-v1:0",
					"amazon.titan-text-premier-v1:0",
					"amazon.titan-embed-text-v2:0"
				],
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"invokeTextModel",
					"invokeImageModel",
					"invokeEmbeddingsModel"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.bedrock.runtime.BedrockOperations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:producer",
				"default": "false"
			},
			"region": {
				"title": "Region",
				"description": "The region in which Bedrock client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"us-east-1",
					"us-west-1",
					"ap-southeast-1",
					"ap-northeast-1",
					"eu-central-1"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Bedrock client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Bedrock client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"bedrockRuntimeClient": {
				"title": "Bedrock Runtime Client",
				"description": "To use an existing configured AWS Bedrock Runtime client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.bedrockruntime.BedrockRuntimeClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Bedrock client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Bedrock client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Bedrock client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Bedrock client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Bedrock.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"modelId",
			"operation"
		]
	},
	"aws-bedrock-agent": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:common"
			},
			"dataSourceId": {
				"title": "Data Source Id",
				"description": "Define the Data source Id we are going to use",
				"type": "string",
				"$comment": "group:common"
			},
			"knowledgeBaseId": {
				"title": "Knowledge Base Id",
				"description": "Define the Knowledge Base Id we are going to use",
				"type": "string",
				"$comment": "group:common"
			},
			"modelId": {
				"title": "Model Id",
				"description": "Define the model Id we are going to use",
				"type": "string",
				"enum": [
					"anthropic.claude-instant-v1",
					"anthropic.claude-v2",
					"anthropic.claude-v2:1"
				],
				"$comment": "group:common"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"startIngestionJob",
					"listIngestionJobs",
					"getIngestionJob"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.aws2.bedrock.agent.BedrockAgentOperations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:common"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:common"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:common",
				"default": "false"
			},
			"region": {
				"title": "Region",
				"description": "The region in which Bedrock Agent client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"us-east-1",
					"us-west-1",
					"ap-southeast-1",
					"ap-northeast-1",
					"eu-central-1"
				],
				"$comment": "group:common"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:common"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Bedrock Agent client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Bedrock Agent client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"ingestionJobId": {
				"title": "Ingestion Job Id",
				"description": "Define the Ingestion Job Id we want to track",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"bedrockAgentClient": {
				"title": "Bedrock Agent Client",
				"description": "To use an existing configured AWS Bedrock Agent client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.bedrockagent.BedrockAgentClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Bedrock Agent client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Bedrock Agent client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Bedrock Agent client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Bedrock Agent client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Bedrock.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"modelId",
			"operation"
		]
	},
	"aws-bedrock-agent-runtime": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"knowledgeBaseId": {
				"title": "Knowledge Base Id",
				"description": "Define the Knowledge Base Id we are going to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"modelId": {
				"title": "Model Id",
				"description": "Define the model Id we are going to use",
				"type": "string",
				"enum": [
					"anthropic.claude-instant-v1",
					"anthropic.claude-v2",
					"anthropic.claude-v2:1"
				],
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"retrieveAndGenerate"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.bedrock.agentruntime.BedrockAgentRuntimeOperations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:producer",
				"default": "false"
			},
			"region": {
				"title": "Region",
				"description": "The region in which Bedrock Agent Runtime client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"us-east-1",
					"us-west-1",
					"ap-southeast-1",
					"ap-northeast-1",
					"eu-central-1"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Bedrock Agent Runtime client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Bedrock Agent Runtime client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"bedrockAgentRuntimeClient": {
				"title": "Bedrock Agent Runtime Client",
				"description": "To use an existing configured AWS Bedrock Agent Runtime client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.bedrockagentruntime.BedrockAgentRuntimeClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Bedrock Agent Runtime client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Bedrock Agent Runtime client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Bedrock Agent Runtime client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Bedrock Agent Runtime client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Bedrock.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"knowledgeBaseId",
			"modelId",
			"operation"
		]
	},
	"aws-cloudtrail": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "A label for indexing cloudtrail endpoints",
				"type": "string",
				"$comment": "group:consumer"
			},
			"eventSource": {
				"title": "Event Source",
				"description": "Specify an event source to select events",
				"type": "string",
				"$comment": "group:consumer"
			},
			"maxResults": {
				"title": "Max Results",
				"description": "Maximum number of records that will be fetched in each poll",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which Cloudtrail client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"cloudTrailClient": {
				"title": "Cloud Trail Client",
				"description": "Amazon Cloudtrail client to use for all requests for this endpoint",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.cloudtrail.CloudTrailClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Cloudtrail client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Cloudtrail client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Cloudtrail client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider this parameter will set the profile name.",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume a IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Cloudtrail client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Cloudtrail client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the CloudTrail client should expect to use Session Credentials. This is useful in situation in which the user needs to assume a IAM role for doing operations in CloudTrail.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label"
		]
	},
	"aws-config": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"putConfigRule",
					"removeConfigRule",
					"describeRuleCompliance",
					"putConformancePack",
					"removeConformancePack"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws.config.AWSConfigOperations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the Config client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"configClient": {
				"title": "Config Client",
				"description": "Amazon AWS Config Client instance",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.config.ConfigClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Config client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Config client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Config client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Config client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Config client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Config client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Config.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws-secrets-manager": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"binaryPayload": {
				"title": "Binary Payload",
				"description": "Set if the secret is binary or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"listSecrets",
					"createSecret",
					"getSecret",
					"batchGetSecret",
					"describeSecret",
					"deleteSecret",
					"rotateSecret",
					"updateSecret",
					"restoreSecret",
					"replicateSecretToRegions",
					"putSecretValue"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws.secretsmanager.SecretsManagerOperations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which a Secrets Manager client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Secrets Manager client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"secretsManagerClient": {
				"title": "Secrets Manager Client",
				"description": "To use an existing configured AWS Secrets Manager client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.secretsmanager.SecretsManagerClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Secrets Manager client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Secrets Manager client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Secrets Manager client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Translate client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Secrets Manager client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Secrets Manager.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-athena": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"database": {
				"title": "Database",
				"description": "The Athena database to use.",
				"type": "string",
				"$comment": "group:producer"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll for query execution status. See the section Waiting for Query Completion and Retrying Failed Queries to learn more.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 2000
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll for query execution status. See the section Waiting for Query Completion and Retrying Failed Queries to learn more.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1000
			},
			"maxAttempts": {
				"title": "Max Attempts",
				"description": "Maximum number of times to attempt a query. Set to 1 to disable retries. See the section Waiting for Query Completion and Retrying Failed Queries to learn more.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"maxResults": {
				"title": "Max Results",
				"description": "Max number of results to return for the given operation (if supported by the Athena API endpoint). If not set, will use the Athena API default for the given operation.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"nextToken": {
				"title": "Next Token",
				"description": "Pagination token to use in the case where the response from the previous request was truncated.",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The Athena API function to call.",
				"type": "string",
				"enum": [
					"getQueryExecution",
					"getQueryResults",
					"listQueryExecutions",
					"startQueryExecution"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.athena.Athena2Operations",
				"default": "startQueryExecution"
			},
			"outputLocation": {
				"title": "Output Location",
				"description": "The location in Amazon S3 where query results are stored, such as s3://path/to/query/bucket/. Ensure this value ends with a forward slash.",
				"type": "string",
				"$comment": "group:producer"
			},
			"outputType": {
				"title": "Output Type",
				"description": "How query results should be returned. One of StreamList (default - return a GetQueryResultsIterable that can page through all results), SelectList (returns at most 1000 rows at a time, plus a NextToken value as a header than can be used for manual pagination of results), S3Pointer (return an S3 path pointing to the results).",
				"type": "string",
				"enum": [
					"StreamList",
					"SelectList",
					"S3Pointer"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.athena.Athena2OutputType",
				"default": "StreamList"
			},
			"queryExecutionId": {
				"title": "Query Execution Id",
				"description": "The unique ID identifying the query execution.",
				"type": "string",
				"$comment": "group:producer"
			},
			"queryString": {
				"title": "Query String",
				"description": "The SQL query to run. Except for simple queries, prefer setting this as the body of the Exchange or as a header using Athena2Constants.QUERY_STRING to avoid having to deal with URL encoding issues.",
				"type": "string",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which Athena client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1).",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"resetWaitTimeoutOnRetry": {
				"title": "Reset Wait Timeout On Retry",
				"description": "Reset the waitTimeout countdown in the event of a query retry. If set to true, potential max time spent waiting for queries is equal to waitTimeout x maxAttempts. See the section Waiting for Query Completion and Retrying Failed Queries to learn more.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"retry": {
				"title": "Retry",
				"description": "Optional comma separated list of error types to retry the query for. Use: 'retryable' to retry all retryable failure conditions (e.g. generic errors and resources exhausted), 'generic' to retry 'GENERIC_INTERNAL_ERROR' failures, 'exhausted' to retry queries that have exhausted resource limits, 'always' to always retry regardless of failure condition, or 'never' or null to never retry (default). See the section Waiting for Query Completion and Retrying Failed Queries to learn more.",
				"type": "string",
				"enum": [
					"never",
					"always",
					"retryable",
					"exhausted",
					"generic"
				],
				"$comment": "group:producer",
				"default": "never"
			},
			"waitTimeout": {
				"title": "Wait Timeout",
				"description": "Optional max wait time in millis to wait for a successful query completion. See the section Waiting for Query Completion and Retrying Failed Queries to learn more.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 0
			},
			"workGroup": {
				"title": "Work Group",
				"description": "The workgroup to use for running the query.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonAthenaClient": {
				"title": "Amazon Athena Client",
				"description": "The AmazonAthena instance to use as the client.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.athena.AthenaClient"
			},
			"clientRequestToken": {
				"title": "Client Request Token",
				"description": "A unique string to ensure issues queries are idempotent. It is unlikely you will need to set this.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"includeTrace": {
				"title": "Include Trace",
				"description": "Include useful trace information at the beginning of queries as an SQL comment (prefixed with --).",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Athena client.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Athena client.",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Athena client.",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"encryptionOption": {
				"title": "Encryption Option",
				"description": "The encryption type to use when storing query results in S3. One of SSE_S3, SSE_KMS, or CSE_KMS.",
				"type": "string",
				"enum": [
					"SSE_S3",
					"SSE_KMS",
					"CSE_KMS",
					"null"
				],
				"$comment": "group:security",
				"format": "bean:software.amazon.awssdk.services.athena.model.EncryptionOption"
			},
			"kmsKey": {
				"title": "Kms Key",
				"description": "For SSE-KMS and CSE-KMS, this is the KMS key ARN or ID.",
				"type": "string",
				"$comment": "group:security"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Athena client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Athena client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Athena client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Athena.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label"
		]
	},
	"aws2-cw": {
		"properties": {
			"namespace": {
				"title": "Namespace",
				"description": "The metric namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"name": {
				"title": "Name",
				"description": "The metric name",
				"type": "string",
				"$comment": "group:producer"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which CW client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"timestamp": {
				"title": "Timestamp",
				"description": "The metric timestamp",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.time.Instant"
			},
			"unit": {
				"title": "Unit",
				"description": "The metric unit",
				"type": "string",
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"value": {
				"title": "Value",
				"description": "The metric value",
				"type": "number",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonCwClient": {
				"title": "Amazon Cw Client",
				"description": "To use the AmazonCloudWatch as the client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.cloudwatch.CloudWatchClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the CW client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the CW client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the CW client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the S3 client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Cloudwatch client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the CloudWatch client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in CloudWatch.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"namespace"
		]
	},
	"aws2-ddb": {
		"properties": {
			"tableName": {
				"title": "Table Name",
				"description": "The name of the table currently worked with.",
				"type": "string",
				"$comment": "group:producer"
			},
			"consistentRead": {
				"title": "Consistent Read",
				"description": "Determines whether strong consistency should be enforced when data is read.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"enabledInitialDescribeTable": {
				"title": "Enabled Initial Describe Table",
				"description": "Set whether the initial Describe table operation in the DDB Endpoint must be done, or not.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"keyAttributeName": {
				"title": "Key Attribute Name",
				"description": "Attribute name when creating table",
				"type": "string",
				"$comment": "group:producer"
			},
			"keyAttributeType": {
				"title": "Key Attribute Type",
				"description": "Attribute type when creating table",
				"type": "string",
				"$comment": "group:producer"
			},
			"keyScalarType": {
				"title": "Key Scalar Type",
				"description": "The key scalar type, it can be S (String), N (Number) and B (Bytes)",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "What operation to perform",
				"type": "string",
				"enum": [
					"BatchGetItems",
					"DeleteItem",
					"DeleteTable",
					"DescribeTable",
					"GetItem",
					"PutItem",
					"Query",
					"Scan",
					"UpdateItem",
					"UpdateTable"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.ddb.Ddb2Operations",
				"default": "PutItem"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"readCapacity": {
				"title": "Read Capacity",
				"description": "The provisioned throughput to reserve for reading resources from your table",
				"type": "integer",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which DDB client needs to work",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"writeCapacity": {
				"title": "Write Capacity",
				"description": "The provisioned throughput to reserved for writing resources to your table",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonDDBClient": {
				"title": "Amazon DDBClient",
				"description": "To use the AmazonDynamoDB as the client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.dynamodb.DynamoDbClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the DDB client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "The region in which DynamoDB client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the DDB client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume a IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the S3 client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the DDB client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the DDB client should expect to use Session Credentials. This is useful in situation in which the user needs to assume a IAM role for doing operations in DDB.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"tableName"
		]
	},
	"aws2-ddbstream": {
		"properties": {
			"tableName": {
				"title": "Table Name",
				"description": "Name of the dynamodb table",
				"type": "string",
				"$comment": "group:consumer"
			},
			"maxResultsPerRequest": {
				"title": "Max Results Per Request",
				"description": "Maximum number of records that will be fetched in each poll",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overidding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which DDBStreams client needs to work",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"streamIteratorType": {
				"title": "Stream Iterator Type",
				"description": "Defines where in the DynamoDB stream to start getting records. Note that using FROM_START can cause a significant delay before the stream has caught up to real-time.",
				"type": "string",
				"enum": [
					"FROM_LATEST",
					"FROM_START"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.aws2.ddbstream.Ddb2StreamConfiguration.StreamIteratorType",
				"default": "FROM_LATEST"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:consumer"
			},
			"amazonDynamoDbStreamsClient": {
				"title": "Amazon Dynamo Db Streams Client",
				"description": "Amazon DynamoDB client to use for all requests for this endpoint",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:software.amazon.awssdk.services.dynamodb.streams.DynamoDbStreamsClient"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the DDBStreams client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the DDBStreams client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the DDBStreams client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider this parameter will set the profile name.",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume a IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the DynamoDB Streams client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Cloudtrail client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the DDB Streams client should expect to use Session Credentials. This is useful in situation in which the user needs to assume a IAM role for doing operations in DDB.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"tableName"
		]
	},
	"aws2-ec2": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"amazonEc2Client": {
				"title": "Amazon Ec2 Client",
				"description": "To use an existing configured AmazonEC2Client client",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:software.amazon.awssdk.services.ec2.Ec2Client"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform. It can be createAndRunInstances, startInstances, stopInstances, terminateInstances, describeInstances, describeInstancesStatus, rebootInstances, monitorInstances, unmonitorInstances, createTags or deleteTags",
				"type": "string",
				"enum": [
					"createAndRunInstances",
					"startInstances",
					"stopInstances",
					"terminateInstances",
					"describeInstances",
					"describeInstancesStatus",
					"rebootInstances",
					"monitorInstances",
					"unmonitorInstances",
					"createTags",
					"deleteTags"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.ec2.AWS2EC2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which EC2 client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the EC2 client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the EC2 client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the EC2 client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the EC2 client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the EC2 client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the EC2 client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in EC2.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-ecs": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"listClusters",
					"describeCluster",
					"createCluster",
					"deleteCluster"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.ecs.ECS2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the ECS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"ecsClient": {
				"title": "Ecs Client",
				"description": "To use an existing configured AWS ECS client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.ecs.EcsClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the ECS client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the ECS client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the ECS client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the ECS client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the ECS client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the ECS client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in ECS.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-eks": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"listClusters",
					"describeCluster",
					"createCluster",
					"deleteCluster"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.eks.EKS2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:producer",
				"default": "false"
			},
			"region": {
				"title": "Region",
				"description": "The region in which EKS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the EKS client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the EKS client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"eksClient": {
				"title": "Eks Client",
				"description": "To use an existing configured AWS EKS client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.eks.EksClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the EKS client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the EKS client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the EKS client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the EKS client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in EKS.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-eventbridge": {
		"properties": {
			"eventbusNameOrArn": {
				"title": "Eventbus Name Or Arn",
				"description": "Event bus name or ARN",
				"type": "string",
				"$comment": "group:producer"
			},
			"eventPatternFile": {
				"title": "Event Pattern File",
				"description": "EventPattern File",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"putRule",
					"putTargets",
					"removeTargets",
					"deleteRule",
					"enableRule",
					"disableRule",
					"describeRule",
					"listRules",
					"listTargetsByRule",
					"listRuleNamesByTarget",
					"putEvent"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.eventbridge.EventbridgeOperations",
				"default": "putRule"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the Eventbridge client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"eventbridgeClient": {
				"title": "Eventbridge Client",
				"description": "To use an existing configured AWS Eventbridge client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.eventbridge.EventBridgeClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Eventbridge client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Eventbridge client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Eventbridge client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Eventbridge client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Eventbridge client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Eventbridge client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Eventbridge.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"eventbusNameOrArn",
			"operation"
		]
	},
	"aws2-iam": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"iamClient": {
				"title": "Iam Client",
				"description": "To use an existing configured AWS IAM client",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:software.amazon.awssdk.services.iam.IamClient"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform. You can configure a default operation on the component level, or the operation as part of the endpoint, or via a message header with the key CamelAwsIAMOperation.",
				"type": "string",
				"enum": [
					"listAccessKeys",
					"createUser",
					"deleteUser",
					"getUser",
					"listUsers",
					"createAccessKey",
					"deleteAccessKey",
					"updateAccessKey",
					"createGroup",
					"deleteGroup",
					"listGroups",
					"addUserToGroup",
					"removeUserFromGroup"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.iam.IAM2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which IAM client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer",
				"default": "aws-global"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the IAM client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the IAM client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the IAM client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the IAM client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the IAM client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the IAM client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume a IAM role for doing operations in IAM.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label"
		]
	},
	"aws2-kinesis": {
		"properties": {
			"streamName": {
				"title": "Stream Name",
				"description": "Name of the stream",
				"type": "string",
				"$comment": "group:common"
			},
			"cborEnabled": {
				"title": "Cbor Enabled",
				"description": "This option will set the CBOR_ENABLED property during the execution",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:common"
			},
			"region": {
				"title": "Region",
				"description": "The region in which Kinesis Firehose client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:common"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:common"
			},
			"iteratorType": {
				"title": "Iterator Type",
				"description": "Defines where in the Kinesis stream to start getting records",
				"type": "string",
				"enum": [
					"AT_SEQUENCE_NUMBER",
					"AFTER_SEQUENCE_NUMBER",
					"TRIM_HORIZON",
					"LATEST",
					"AT_TIMESTAMP",
					"null"
				],
				"$comment": "group:consumer",
				"format": "bean:software.amazon.awssdk.services.kinesis.model.ShardIteratorType",
				"default": "TRIM_HORIZON"
			},
			"maxResultsPerRequest": {
				"title": "Max Results Per Request",
				"description": "Maximum number of records that will be fetched in each poll",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"messageTimestamp": {
				"title": "Message Timestamp",
				"description": "The message timestamp to start polling from. Required if iteratorType is set to AT_TIMESTAMP",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sequenceNumber": {
				"title": "Sequence Number",
				"description": "The sequence number to start polling from. Required if iteratorType is set to AFTER_SEQUENCE_NUMBER or AT_SEQUENCE_NUMBER",
				"type": "string",
				"$comment": "group:consumer"
			},
			"shardClosed": {
				"title": "Shard Closed",
				"description": "Define what will be the behavior in case of shard closed. Possible value are ignore, silent and fail. In case of ignore a WARN message will be logged once and the consumer will not process new messages until restarted,in case of silent there will be no logging and the consumer will not process new messages until restarted,in case of fail a ReachedClosedStateException will be thrown",
				"type": "string",
				"enum": [
					"ignore",
					"fail",
					"silent"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.aws2.kinesis.Kinesis2ShardClosedStrategyEnum",
				"default": "ignore"
			},
			"shardId": {
				"title": "Shard Id",
				"description": "Defines which shardId in the Kinesis stream to get records from",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"shardMonitorInterval": {
				"title": "Shard Monitor Interval",
				"description": "The interval in milliseconds to wait between shard polling",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": 10000
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonKinesisAsyncClient": {
				"title": "Amazon Kinesis Async Client",
				"description": "Supply a pre-constructed Amazon Kinesis async client to use for the KCL Consumer",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.kinesis.KinesisAsyncClient"
			},
			"amazonKinesisClient": {
				"title": "Amazon Kinesis Client",
				"description": "Amazon Kinesis client to use for all requests for this endpoint",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.kinesis.KinesisClient"
			},
			"applicationName": {
				"title": "Application Name",
				"description": "Name of the KCL application. This defaults to the stream name.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"asyncClient": {
				"title": "Async Client",
				"description": "If we want to a KinesisAsyncClient instance set it to true",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"cloudWatchAsyncClient": {
				"title": "Cloud Watch Async Client",
				"description": "If we want to a KCL Consumer, we can pass an instance of CloudWatchAsyncClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.cloudwatch.CloudWatchAsyncClient"
			},
			"dynamoDbAsyncClient": {
				"title": "Dynamo Db Async Client",
				"description": "If we want to a KCL Consumer, we can pass an instance of DynamoDbAsyncClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.dynamodb.DynamoDbAsyncClient"
			},
			"kclDisableCloudwatchMetricsExport": {
				"title": "Kcl Disable Cloudwatch Metrics Export",
				"description": "If we want to use a KCL Consumer and disable the CloudWatch Metrics Export",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"useKclConsumers": {
				"title": "Use Kcl Consumers",
				"description": "If we want to a KCL Consumer set it to true",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Kinesis client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Kinesis client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Kinesis client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider this parameter will set the profile name.",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume a IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Kinesis client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Kinesis client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Kinesis client should expect to use Session Credentials. This is useful in situation in which the user needs to assume a IAM role for doing operations in Kinesis.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"streamName"
		]
	},
	"aws2-kinesis-firehose": {
		"properties": {
			"streamName": {
				"title": "Stream Name",
				"description": "Name of the stream",
				"type": "string",
				"$comment": "group:producer"
			},
			"cborEnabled": {
				"title": "Cbor Enabled",
				"description": "This option will set the CBOR_ENABLED property during the execution",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:common"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:common"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do in case the user don't want to send only a record",
				"type": "string",
				"enum": [
					"sendBatchRecord",
					"createDeliveryStream",
					"deleteDeliveryStream",
					"describeDeliveryStream",
					"updateDestination"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.firehose.KinesisFirehose2Operations"
			},
			"region": {
				"title": "Region",
				"description": "The region in which Kinesis Firehose client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Kinesis Firehose client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonKinesisFirehoseClient": {
				"title": "Amazon Kinesis Firehose Client",
				"description": "Amazon Kinesis Firehose client to use for all requests for this endpoint",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.firehose.FirehoseClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Kinesis Firehose client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Kinesis Firehose client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Kinesis Firehose client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider this parameter will set the profile name.",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume a IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Kinesis Firehose client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Kinesis Firehose client should expect to use Session Credentials. This is useful in situation in which the user needs to assume a IAM role for doing operations in Kinesis Firehose.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"streamName"
		]
	},
	"aws2-kms": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"listKeys",
					"createKey",
					"disableKey",
					"scheduleKeyDeletion",
					"describeKey",
					"enableKey"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.kms.KMS2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which EKS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"kmsClient": {
				"title": "Kms Client",
				"description": "To use an existing configured AWS KMS client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.kms.KmsClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the KMS client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the KMS client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the KMS client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the KMS client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the KMS client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the KMS client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume a IAM role for doing operations in KMS.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-lambda": {
		"properties": {
			"function": {
				"title": "Function",
				"description": "Name of the Lambda function.",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform. It can be listFunctions, getFunction, createFunction, deleteFunction or invokeFunction",
				"type": "string",
				"enum": [
					"listFunctions",
					"getFunction",
					"createAlias",
					"deleteAlias",
					"getAlias",
					"listAliases",
					"createFunction",
					"deleteFunction",
					"invokeFunction",
					"updateFunction",
					"createEventSourceMapping",
					"deleteEventSourceMapping",
					"listEventSourceMapping",
					"listTags",
					"tagResource",
					"untagResource",
					"publishVersion",
					"listVersions"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.lambda.Lambda2Operations",
				"default": "invokeFunction"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the Lambda client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"awsLambdaClient": {
				"title": "Aws Lambda Client",
				"description": "To use an existing configured AwsLambdaClient client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.lambda.LambdaClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Lambda client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Lambda client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Lambda client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Lambda client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Lambda client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Lambda client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Lambda.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"function"
		]
	},
	"aws2-mq": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform. It can be listBrokers, createBroker, deleteBroker",
				"type": "string",
				"enum": [
					"listBrokers",
					"createBroker",
					"deleteBroker",
					"rebootBroker",
					"updateBroker",
					"describeBroker"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.mq.MQ2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which MQ client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonMqClient": {
				"title": "Amazon Mq Client",
				"description": "To use a existing configured AmazonMQClient client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.mq.MqClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the MQ client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the MQ client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the MQ client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the MQ client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the MQ client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the MQ client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in MQ.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-msk": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"listClusters",
					"createCluster",
					"deleteCluster",
					"describeCluster"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.msk.MSK2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the MSK client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"mskClient": {
				"title": "Msk Client",
				"description": "To use an existing configured AWS MSK client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.kafka.KafkaClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the MSK client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the MSK client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the MSK client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Kafka client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the MSK client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the MSK client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in MSK.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-redshift-data": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform. It can be batchExecuteStatement, cancelStatement, describeStatement, describeTable, executeStatement, getStatementResult, listDatabases, listSchemas, listStatements or listTables",
				"type": "string",
				"enum": [
					"listDatabases",
					"listSchemas",
					"listStatements",
					"listTables",
					"describeTable",
					"executeStatement",
					"batchExecuteStatement",
					"cancelStatement",
					"describeStatement",
					"getStatementResult"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.redshift.data.RedshiftData2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which RedshiftData client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the RedshiftData client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the RedshiftData client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"awsRedshiftDataClient": {
				"title": "Aws Redshift Data Client",
				"description": "To use an existing configured AwsRedshiftDataClient client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.redshiftdata.RedshiftDataClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the RedshiftData client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the RedshiftData client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the RedshiftData client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Redshift client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Redshift.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-s3": {
		"properties": {
			"bucketNameOrArn": {
				"title": "Bucket Name Or Arn",
				"description": "Bucket name or ARN",
				"type": "string",
				"$comment": "group:common"
			},
			"autoCreateBucket": {
				"title": "Auto Create Bucket",
				"description": "Setting the autocreation of the S3 bucket bucketName. This will apply also in case of moveAfterRead option enabled, and it will create the destinationBucket if it doesn't exist already.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"delimiter": {
				"title": "Delimiter",
				"description": "The delimiter which is used in the com.amazonaws.services.s3.model.ListObjectsRequest to only consume objects we are interested in.",
				"type": "string",
				"$comment": "group:common"
			},
			"forcePathStyle": {
				"title": "Force Path Style",
				"description": "Set whether the S3 client should use path-style URL instead of virtual-hosted-style",
				"type": "boolean",
				"$comment": "group:common"
			},
			"ignoreBody": {
				"title": "Ignore Body",
				"description": "If it is true, the S3 Object Body will be ignored completely if it is set to false, the S3 Object will be put in the body. Setting this to true will override any behavior defined by includeBody option.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:common"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:common"
			},
			"policy": {
				"title": "Policy",
				"description": "The policy for this queue to set in the com.amazonaws.services.s3.AmazonS3#setBucketPolicy() method.",
				"type": "string",
				"$comment": "group:common"
			},
			"prefix": {
				"title": "Prefix",
				"description": "The prefix which is used in the com.amazonaws.services.s3.model.ListObjectsRequest to only consume objects we are interested in.",
				"type": "string",
				"$comment": "group:common"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the S3 client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:common"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:common"
			},
			"customerAlgorithm": {
				"title": "Customer Algorithm",
				"description": "Define the customer algorithm to use in case CustomerKey is enabled",
				"type": "string",
				"$comment": "group:common (advanced)"
			},
			"customerKeyId": {
				"title": "Customer Key Id",
				"description": "Define the id of the Customer key to use in case CustomerKey is enabled",
				"type": "string",
				"$comment": "group:common (advanced)"
			},
			"customerKeyMD5": {
				"title": "Customer Key MD5",
				"description": "Define the MD5 of Customer key to use in case CustomerKey is enabled",
				"type": "string",
				"$comment": "group:common (advanced)"
			},
			"deleteAfterRead": {
				"title": "Delete After Read",
				"description": "Delete objects from S3 after they have been retrieved. The deleting is only performed if the Exchange is committed. If a rollback occurs, the object is not deleted. If this option is false, then the same objects will be retrieved over and over again in the polls. Therefore, you need to use the Idempotent Consumer EIP in the route to filter out duplicates. You can filter using the AWS2S3Constants#BUCKET_NAME and AWS2S3Constants#KEY headers, or only the AWS2S3Constants#KEY header.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"destinationBucket": {
				"title": "Destination Bucket",
				"description": "Define the destination bucket where an object must be moved when moveAfterRead is set to true.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"destinationBucketPrefix": {
				"title": "Destination Bucket Prefix",
				"description": "Define the destination bucket prefix to use when an object must be moved, and moveAfterRead is set to true.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"destinationBucketSuffix": {
				"title": "Destination Bucket Suffix",
				"description": "Define the destination bucket suffix to use when an object must be moved, and moveAfterRead is set to true.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"doneFileName": {
				"title": "Done File Name",
				"description": "If provided, Camel will only consume files if a done file exists.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"fileName": {
				"title": "File Name",
				"description": "To get the object from the bucket with the given file name",
				"type": "string",
				"$comment": "group:consumer"
			},
			"includeBody": {
				"title": "Include Body",
				"description": "If it is true, the S3Object exchange will be consumed and put into the body and closed. If false, the S3Object stream will be put raw into the body and the headers will be set with the S3 object metadata. This option is strongly related to the autocloseBody option. In case of setting includeBody to true because the S3Object stream will be consumed then it will also be closed, while in case of includeBody false then it will be up to the caller to close the S3Object stream. However, setting autocloseBody to true when includeBody is false it will schedule to close the S3Object stream automatically on exchange completion.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"includeFolders": {
				"title": "Include Folders",
				"description": "If it is true, the folders/directories will be consumed. If it is false, they will be ignored, and Exchanges will not be created for those",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"maxConnections": {
				"title": "Max Connections",
				"description": "Set the maxConnections parameter in the S3 client configuration",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 60
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"moveAfterRead": {
				"title": "Move After Read",
				"description": "Move objects from S3 bucket to a different bucket after they have been retrieved. To accomplish the operation, the destinationBucket option must be set. The copy bucket operation is only performed if the Exchange is committed. If a rollback occurs, the object is not moved.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"autocloseBody": {
				"title": "Autoclose Body",
				"description": "If this option is true and includeBody is false, then the S3Object.close() method will be called on exchange completion. This option is strongly related to includeBody option. In case of setting includeBody to false and autocloseBody to false, it will be up to the caller to close the S3Object stream. Setting autocloseBody to true, will close the S3Object stream automatically.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"inProgressRepository": {
				"title": "In Progress Repository",
				"description": "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"batchMessageNumber": {
				"title": "Batch Message Number",
				"description": "The number of messages composing a batch in streaming upload mode",
				"type": "integer",
				"$comment": "group:producer",
				"default": 10
			},
			"batchSize": {
				"title": "Batch Size",
				"description": "The batch size (in bytes) in streaming upload mode",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1000000
			},
			"bufferSize": {
				"title": "Buffer Size",
				"description": "The buffer size (in bytes) in streaming upload mode",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1000000
			},
			"deleteAfterWrite": {
				"title": "Delete After Write",
				"description": "Delete file object after the S3 file has been uploaded",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"keyName": {
				"title": "Key Name",
				"description": "Setting the key name for an element in the bucket through endpoint parameter",
				"type": "string",
				"$comment": "group:producer"
			},
			"multiPartUpload": {
				"title": "Multi Part Upload",
				"description": "If it is true, camel will upload the file with multipart format. The part size is decided by the partSize option. Camel will only do multipart uploads for files that are larger than the part-size thresholds. Files that are smaller will be uploaded in a single operation.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"namingStrategy": {
				"title": "Naming Strategy",
				"description": "The naming strategy to use in streaming upload mode",
				"type": "string",
				"enum": [
					"progressive",
					"random"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.s3.stream.AWSS3NamingStrategyEnum",
				"default": "progressive"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do in case the user don't want to do only an upload",
				"type": "string",
				"enum": [
					"copyObject",
					"listObjects",
					"deleteObject",
					"deleteBucket",
					"listBuckets",
					"getObject",
					"getObjectRange",
					"createDownloadLink",
					"headBucket",
					"headObject"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.s3.AWS2S3Operations"
			},
			"partSize": {
				"title": "Part Size",
				"description": "Set up the partSize which is used in multipart upload, the default size is 25M. Camel will only do multipart uploads for files that are larger than the part-size thresholds. Files that are smaller will be uploaded in a single operation.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 26214400
			},
			"restartingPolicy": {
				"title": "Restarting Policy",
				"description": "The restarting policy to use in streaming upload mode",
				"type": "string",
				"enum": [
					"override",
					"lastPart"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.s3.stream.AWSS3RestartingPolicyEnum",
				"default": "override"
			},
			"storageClass": {
				"title": "Storage Class",
				"description": "The storage class to set in the com.amazonaws.services.s3.model.PutObjectRequest request.",
				"type": "string",
				"$comment": "group:producer"
			},
			"streamingUploadMode": {
				"title": "Streaming Upload Mode",
				"description": "When stream mode is true, the upload to bucket will be done in streaming",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"streamingUploadTimeout": {
				"title": "Streaming Upload Timeout",
				"description": "While streaming upload mode is true, this option set the timeout to complete upload",
				"type": "integer",
				"$comment": "group:producer"
			},
			"awsKMSKeyId": {
				"title": "Aws KMSKey Id",
				"description": "Define the id of KMS key to use in case KMS is enabled",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"conditionalWritesEnabled": {
				"title": "Conditional Writes Enabled",
				"description": "Uploads the object only if the object key name does not already exist in the bucket specified.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"useAwsKMS": {
				"title": "Use Aws KMS",
				"description": "Define if KMS must be used or not",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"useCustomerKey": {
				"title": "Use Customer Key",
				"description": "Define if Customer Key must be used or not",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"useSSES3": {
				"title": "Use SSES3",
				"description": "Define if SSE S3 must be used or not",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonS3Client": {
				"title": "Amazon S3 Client",
				"description": "Reference to a com.amazonaws.services.s3.AmazonS3 in the registry.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.s3.S3Client"
			},
			"amazonS3Presigner": {
				"title": "Amazon S3 Presigner",
				"description": "An S3 Presigner for Request, used mainly in createDownloadLink operation",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.s3.presigner.S3Presigner"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the SQS client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "Specify a proxy port to be used inside the client definition.",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the S3 client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the S3 client should expect to load credentials through a default credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the S3 client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the S3 client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in S3.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"bucketNameOrArn"
		]
	},
	"aws2-ses": {
		"properties": {
			"from": {
				"title": "From",
				"description": "The sender's email address.",
				"type": "string",
				"$comment": "group:producer"
			},
			"bcc": {
				"title": "Bcc",
				"description": "List of comma-separated destination blind carbon copy (bcc) email address. Can be overridden with 'CamelAwsSesBcc' header.",
				"type": "string",
				"$comment": "group:producer"
			},
			"cc": {
				"title": "Cc",
				"description": "List of comma-separated destination carbon copy (cc) email address. Can be overridden with 'CamelAwsSesCc' header.",
				"type": "string",
				"$comment": "group:producer"
			},
			"configurationSet": {
				"title": "Configuration Set",
				"description": "Set the configuration set to send with every request. Override it with 'CamelAwsSesConfigurationSet' header.",
				"type": "string",
				"$comment": "group:producer"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which SES client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"replyToAddresses": {
				"title": "Reply To Addresses",
				"description": "List of comma separated reply-to email address(es) for the message, override it using 'CamelAwsSesReplyToAddresses' header.",
				"type": "string",
				"$comment": "group:producer"
			},
			"returnPath": {
				"title": "Return Path",
				"description": "The email address to which bounce notifications are to be forwarded, override it using 'CamelAwsSesReturnPath' header.",
				"type": "string",
				"$comment": "group:producer"
			},
			"subject": {
				"title": "Subject",
				"description": "The subject which is used if the message header 'CamelAwsSesSubject' is not present.",
				"type": "string",
				"$comment": "group:producer"
			},
			"to": {
				"title": "To",
				"description": "List of comma separated destination email address. Can be overridden with 'CamelAwsSesTo' header.",
				"type": "string",
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonSESClient": {
				"title": "Amazon SESClient",
				"description": "To use the AmazonSimpleEmailService as the client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.ses.SesClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the SES client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the SES client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the SES client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Ses client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the SES client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the SES client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in SES.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"from"
		]
	},
	"aws2-sns": {
		"properties": {
			"topicNameOrArn": {
				"title": "Topic Name Or Arn",
				"description": "Topic name or ARN",
				"type": "string",
				"$comment": "group:producer"
			},
			"autoCreateTopic": {
				"title": "Auto Create Topic",
				"description": "Setting the auto-creation of the topic",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"batchEnabled": {
				"title": "Batch Enabled",
				"description": "Define if we are publishing a single message or a batch",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to map headers to/from Camel.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"kmsMasterKeyId": {
				"title": "Kms Master Key Id",
				"description": "The ID of an AWS-managed customer master key (CMK) for Amazon SNS or a custom CMK.",
				"type": "string",
				"$comment": "group:producer"
			},
			"messageDeduplicationIdStrategy": {
				"title": "Message Deduplication Id Strategy",
				"description": "Only for FIFO Topic. Strategy for setting the messageDeduplicationId on the message. It can be one of the following options: useExchangeId, useContentBasedDeduplication. For the useContentBasedDeduplication option, no messageDeduplicationId will be set on the message.",
				"type": "string",
				"enum": [
					"useExchangeId",
					"useContentBasedDeduplication"
				],
				"$comment": "group:producer",
				"default": "useExchangeId"
			},
			"messageGroupIdStrategy": {
				"title": "Message Group Id Strategy",
				"description": "Only for FIFO Topic. Strategy for setting the messageGroupId on the message. It can be one of the following options: useConstant, useExchangeId, usePropertyValue. For the usePropertyValue option, the value of property CamelAwsSnsMessageGroupId will be used.",
				"type": "string",
				"enum": [
					"useConstant",
					"useExchangeId",
					"usePropertyValue"
				],
				"$comment": "group:producer"
			},
			"messageStructure": {
				"title": "Message Structure",
				"description": "The message structure to use such as json",
				"type": "string",
				"$comment": "group:producer"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"policy": {
				"title": "Policy",
				"description": "The policy for this topic. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:producer"
			},
			"queueArn": {
				"title": "Queue Arn",
				"description": "The ARN endpoint to subscribe to",
				"type": "string",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the SNS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"serverSideEncryptionEnabled": {
				"title": "Server Side Encryption Enabled",
				"description": "Define if Server Side Encryption is enabled or not on the topic",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"subject": {
				"title": "Subject",
				"description": "The subject which is used if the message header 'CamelAwsSnsSubject' is not present.",
				"type": "string",
				"$comment": "group:producer"
			},
			"subscribeSNStoSQS": {
				"title": "Subscribe SNSto SQS",
				"description": "Define if the subscription between SNS Topic and SQS must be done or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonSNSClient": {
				"title": "Amazon SNSClient",
				"description": "To use the AmazonSNS as the client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.sns.SnsClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the SNS client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the SNS client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the SNS client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the SNS client should expect to load credentials on an AWS infra instance or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the SNS client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the SNS client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in SNS.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"topicNameOrArn"
		]
	},
	"aws2-sqs": {
		"properties": {
			"queueNameOrArn": {
				"title": "Queue Name Or Arn",
				"description": "Queue name or ARN",
				"type": "string",
				"$comment": "group:common"
			},
			"amazonAWSHost": {
				"title": "Amazon AWSHost",
				"description": "The hostname of the Amazon AWS cloud.",
				"type": "string",
				"$comment": "group:common",
				"default": "amazonaws.com"
			},
			"autoCreateQueue": {
				"title": "Auto Create Queue",
				"description": "Setting the auto-creation of the queue",
				"type": "boolean",
				"$comment": "group:common"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to map headers to/from Camel.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:common"
			},
			"protocol": {
				"title": "Protocol",
				"description": "The underlying protocol used to communicate with SQS",
				"type": "string",
				"$comment": "group:common",
				"default": "https"
			},
			"queueOwnerAWSAccountId": {
				"title": "Queue Owner AWSAccount Id",
				"description": "Specify the queue owner aws account id when you need to connect the queue with a different account owner.",
				"type": "string",
				"$comment": "group:common",
				"format": "password"
			},
			"region": {
				"title": "Region",
				"description": "The region in which SQS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:common"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:common"
			},
			"attributeNames": {
				"title": "Attribute Names",
				"description": "A list of attribute names to receive when consuming. Multiple names can be separated by comma.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Allows you to use multiple threads to poll the sqs queue to increase throughput",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"concurrentRequestLimit": {
				"title": "Concurrent Request Limit",
				"description": "The maximum number of concurrent receive request send to AWS in single consumer polling.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 50
			},
			"defaultVisibilityTimeout": {
				"title": "Default Visibility Timeout",
				"description": "The default visibility timeout (in seconds)",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"deleteAfterRead": {
				"title": "Delete After Read",
				"description": "Delete message from SQS after it has been read",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"deleteIfFiltered": {
				"title": "Delete If Filtered",
				"description": "Whether to send the DeleteMessage to the SQS queue if the exchange has property with key Sqs2Constants#SQS_DELETE_FILTERED (CamelAwsSqsDeleteFiltered) set to true.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"extendMessageVisibility": {
				"title": "Extend Message Visibility",
				"description": "If enabled, then a scheduled background task will keep extending the message visibility on SQS. This is needed if it takes a long time to process the message. If set to true defaultVisibilityTimeout must be set. See details at Amazon docs.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"kmsDataKeyReusePeriodSeconds": {
				"title": "Kms Data Key Reuse Period Seconds",
				"description": "The length of time, in seconds, for which Amazon SQS can reuse a data key to encrypt or decrypt messages before calling AWS KMS again. An integer representing seconds, between 60 seconds (1 minute) and 86,400 seconds (24 hours). Default: 300 (5 minutes).",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"kmsMasterKeyId": {
				"title": "Kms Master Key Id",
				"description": "The ID of an AWS-managed customer master key (CMK) for Amazon SQS or a custom CMK.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Gets the maximum number of messages as a limit to poll at each polling. Is default unlimited, but use 0 or negative number to disable it as unlimited.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"messageAttributeNames": {
				"title": "Message Attribute Names",
				"description": "A list of message attribute names to receive when consuming. Multiple names can be separated by comma.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"serverSideEncryptionEnabled": {
				"title": "Server Side Encryption Enabled",
				"description": "Define if Server Side Encryption is enabled or not on the queue",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sortAttributeName": {
				"title": "Sort Attribute Name",
				"description": "The name of the message attribute used for sorting the messages. When specified, the messages polled by the consumer will be sorted by this attribute. This configuration may be of importance when you configure maxMessagesPerPoll parameter exceeding 10. In such cases, the messages will be fetched concurrently so the ordering is not guaranteed.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"visibilityTimeout": {
				"title": "Visibility Timeout",
				"description": "The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request to set in the com.amazonaws.services.sqs.model.SetQueueAttributesRequest. This only makes sense if it's different from defaultVisibilityTimeout. It changes the queue visibility timeout attribute permanently.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"waitTimeSeconds": {
				"title": "Wait Time Seconds",
				"description": "Duration in seconds (0 to 20) that the ReceiveMessage action call will wait until a message is in the queue to include in the response.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"batchSeparator": {
				"title": "Batch Separator",
				"description": "Set the separator when passing a String to send batch message operation",
				"type": "string",
				"$comment": "group:producer",
				"default": ","
			},
			"delaySeconds": {
				"title": "Delay Seconds",
				"description": "Delay sending messages for a number of seconds.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"messageDeduplicationIdStrategy": {
				"title": "Message Deduplication Id Strategy",
				"description": "Only for FIFO queues. Strategy for setting the messageDeduplicationId on the message. It can be one of the following options: useExchangeId, useContentBasedDeduplication. For the useContentBasedDeduplication option, no messageDeduplicationId will be set on the message.",
				"type": "string",
				"enum": [
					"useExchangeId",
					"useContentBasedDeduplication"
				],
				"$comment": "group:producer",
				"default": "useExchangeId"
			},
			"messageGroupIdStrategy": {
				"title": "Message Group Id Strategy",
				"description": "Only for FIFO queues. Strategy for setting the messageGroupId on the message. It can be one of the following options: useConstant, useExchangeId, usePropertyValue. For the usePropertyValue option, the value of property CamelAwsMessageGroupId will be used.",
				"type": "string",
				"enum": [
					"useConstant",
					"useExchangeId",
					"usePropertyValue"
				],
				"$comment": "group:producer"
			},
			"messageHeaderExceededLimit": {
				"title": "Message Header Exceeded Limit",
				"description": "What to do if sending to AWS SQS has more messages than AWS allows (currently only maximum 10 message headers are allowed). WARN will log a WARN about the limit is for each additional header, so the message can be sent to AWS. WARN_ONCE will only log one time a WARN about the limit is hit, and drop additional headers, so the message can be sent to AWS. IGNORE will ignore (no logging) and drop additional headers, so the message can be sent to AWS. FAIL will cause an exception to be thrown and the message is not sent to AWS.",
				"type": "string",
				"enum": [
					"WARN",
					"WARN_ONCE",
					"IGNORE",
					"FAIL"
				],
				"$comment": "group:producer",
				"default": "WARN"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do in case the user don't want to send only a message",
				"type": "string",
				"enum": [
					"sendBatchMessage",
					"deleteMessage",
					"listQueues",
					"purgeQueue",
					"deleteQueue"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.sqs.Sqs2Operations"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"amazonSQSClient": {
				"title": "Amazon SQSClient",
				"description": "To use the AmazonSQS client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.sqs.SqsClient"
			},
			"delayQueue": {
				"title": "Delay Queue",
				"description": "Define if you want to apply delaySeconds option to the queue or on single messages",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the SQS client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the SQS client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the SQS client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"maximumMessageSize": {
				"title": "Maximum Message Size",
				"description": "The maximumMessageSize (in bytes) an SQS message can contain for this queue.",
				"type": "integer",
				"$comment": "group:queue"
			},
			"messageRetentionPeriod": {
				"title": "Message Retention Period",
				"description": "The messageRetentionPeriod (in seconds) a message will be retained by SQS for this queue.",
				"type": "integer",
				"$comment": "group:queue"
			},
			"policy": {
				"title": "Policy",
				"description": "The policy for this queue. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:queue"
			},
			"queueUrl": {
				"title": "Queue Url",
				"description": "To define the queueUrl explicitly. All other parameters, which would influence the queueUrl, are ignored. This parameter is intended to be used to connect to a mock implementation of SQS, for testing purposes.",
				"type": "string",
				"$comment": "group:queue"
			},
			"receiveMessageWaitTimeSeconds": {
				"title": "Receive Message Wait Time Seconds",
				"description": "If you do not specify WaitTimeSeconds in the request, the queue attribute ReceiveMessageWaitTimeSeconds is used to determine how long to wait.",
				"type": "integer",
				"$comment": "group:queue"
			},
			"redrivePolicy": {
				"title": "Redrive Policy",
				"description": "Specify the policy that send message to DeadLetter queue. See detail at Amazon docs.",
				"type": "string",
				"$comment": "group:queue"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the SQS client should expect to load credentials on an AWS infra instance or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the SQS client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the SQS client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in SQS.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"queueNameOrArn"
		]
	},
	"aws2-step-functions": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform. It can be listFunctions, getFunction, createFunction, deleteFunction or invokeFunction",
				"type": "string",
				"enum": [
					"createStateMachine",
					"deleteStateMachine",
					"updateStateMachine",
					"describeStateMachine",
					"listStateMachines",
					"createActivity",
					"deleteActivity",
					"describeActivity",
					"getActivityTask",
					"listActivities",
					"startExecution",
					"startSyncExecution",
					"stopExecution",
					"describeExecution",
					"listExecutions",
					"getExecutionHistory"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.stepfunctions.StepFunctions2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which StepFunctions client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the StepFunctions client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the StepFunctions client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"awsSfnClient": {
				"title": "Aws Sfn Client",
				"description": "To use an existing configured AwsStepFunctionsClient client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.sfn.SfnClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the StepFunctions client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the StepFunctions client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the StepFunctions client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Step Functions client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Step Functions.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-sts": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"assumeRole",
					"getSessionToken",
					"getFederationToken"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.sts.STS2Operations",
				"default": "assumeRole"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the STS client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer",
				"default": "aws-global"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"stsClient": {
				"title": "Sts Client",
				"description": "To use an existing configured AWS STS client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.sts.StsClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the STS client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the STS client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the STS client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the STS client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the STS client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"aws2-timestream": {
		"properties": {
			"clientType": {
				"title": "Client Type",
				"description": "Type of client - write/query",
				"type": "string",
				"enum": [
					"write",
					"query"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.timestream.Timestream2ClientType"
			},
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform. It can be describeEndpoints,createBatchLoadTask,describeBatchLoadTask, resumeBatchLoadTask,listBatchLoadTasks,createDatabase,deleteDatabase,describeDatabase,updateDatabase, listDatabases,createTable,deleteTable,describeTable,updateTable,listTables,writeRecords, createScheduledQuery,deleteScheduledQuery,executeScheduledQuery,updateScheduledQuery, describeScheduledQuery,listScheduledQueries,prepareQuery,query,cancelQuery",
				"type": "string",
				"enum": [
					"describeEndpoints",
					"createBatchLoadTask",
					"describeBatchLoadTask",
					"resumeBatchLoadTask",
					"listBatchLoadTasks",
					"createDatabase",
					"deleteDatabase",
					"describeDatabase",
					"updateDatabase",
					"listDatabases",
					"createTable",
					"deleteTable",
					"describeTable",
					"updateTable",
					"listTables",
					"writeRecords",
					"createScheduledQuery",
					"deleteScheduledQuery",
					"executeScheduledQuery",
					"updateScheduledQuery",
					"describeScheduledQuery",
					"listScheduledQueries",
					"prepareQuery",
					"query",
					"cancelQuery"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.timestream.Timestream2Operations"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the Timestream client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Timestream client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Timestream client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"awsTimestreamQueryClient": {
				"title": "Aws Timestream Query Client",
				"description": "To use an existing configured AwsTimestreamQueryClient client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.timestreamquery.TimestreamQueryClient"
			},
			"awsTimestreamWriteClient": {
				"title": "Aws Timestream Write Client",
				"description": "To use an existing configured AwsTimestreamWriteClient client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.timestreamwrite.TimestreamWriteClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Timestream client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Timestream client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Timestream client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"clientType",
			"label",
			"operation"
		]
	},
	"aws2-translate": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"autodetectSourceLanguage": {
				"title": "Autodetect Source Language",
				"description": "Being able to autodetect the source language",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"translateText"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.aws2.translate.Translate2Operations",
				"default": "translateText"
			},
			"overrideEndpoint": {
				"title": "Override Endpoint",
				"description": "Set the need for overriding the endpoint. This option needs to be used in combination with the uriEndpointOverride option",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "The region in which the Translate client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example, ap-east-1) You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"enum": [
					"ap-south-2",
					"ap-south-1",
					"eu-south-1",
					"eu-south-2",
					"us-gov-east-1",
					"me-central-1",
					"il-central-1",
					"ca-central-1",
					"eu-central-1",
					"us-iso-west-1",
					"eu-central-2",
					"eu-isoe-west-1",
					"us-west-1",
					"us-west-2",
					"af-south-1",
					"eu-north-1",
					"eu-west-3",
					"eu-west-2",
					"eu-west-1",
					"ap-northeast-3",
					"ap-northeast-2",
					"ap-northeast-1",
					"me-south-1",
					"sa-east-1",
					"ap-east-1",
					"cn-north-1",
					"ca-west-1",
					"us-gov-west-1",
					"ap-southeast-1",
					"ap-southeast-2",
					"us-iso-east-1",
					"ap-southeast-3",
					"ap-southeast-4",
					"us-east-1",
					"us-east-2",
					"cn-northwest-1",
					"us-isob-east-1",
					"aws-global",
					"aws-cn-global",
					"aws-us-gov-global",
					"aws-iso-global",
					"aws-iso-b-global"
				],
				"$comment": "group:producer"
			},
			"sourceLanguage": {
				"title": "Source Language",
				"description": "Source language to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"targetLanguage": {
				"title": "Target Language",
				"description": "Target language to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"uriEndpointOverride": {
				"title": "Uri Endpoint Override",
				"description": "Set the overriding uri endpoint. This option needs to be used in combination with overrideEndpoint option",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"translateClient": {
				"title": "Translate Client",
				"description": "To use an existing configured AWS Translate client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:software.amazon.awssdk.services.translate.TranslateClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "To define a proxy host when instantiating the Translate client",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "To define a proxy port when instantiating the Translate client",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyProtocol": {
				"title": "Proxy Protocol",
				"description": "To define a proxy protocol when instantiating the Translate client",
				"type": "string",
				"enum": [
					"HTTP",
					"HTTPS"
				],
				"$comment": "group:proxy",
				"format": "bean:software.amazon.awssdk.core.Protocol",
				"default": "HTTPS"
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Access Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"profileCredentialsName": {
				"title": "Profile Credentials Name",
				"description": "If using a profile credentials provider, this parameter will set the profile name",
				"type": "string",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Secret Key",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sessionToken": {
				"title": "Session Token",
				"description": "Amazon AWS Session Token used when the user needs to assume an IAM role",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustAllCertificates": {
				"title": "Trust All Certificates",
				"description": "If we want to trust all certificates in case of overriding the endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useDefaultCredentialsProvider": {
				"title": "Use Default Credentials Provider",
				"description": "Set whether the Translate client should expect to load credentials through a default credentials provider or to expect static credentials to be passed in.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useProfileCredentialsProvider": {
				"title": "Use Profile Credentials Provider",
				"description": "Set whether the Translate client should expect to load credentials through a profile credentials provider.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"useSessionCredentials": {
				"title": "Use Session Credentials",
				"description": "Set whether the Translate client should expect to use Session Credentials. This is useful in a situation in which the user needs to assume an IAM role for doing operations in Translate.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label",
			"operation"
		]
	},
	"azure-cosmosdb": {
		"properties": {
			"databaseName": {
				"title": "Database Name",
				"description": "The name of the Cosmos database that component should connect to. In case you are producing data and have createDatabaseIfNotExists=true, the component will automatically auto create a Cosmos database.",
				"type": "string",
				"$comment": "group:common"
			},
			"containerName": {
				"title": "Container Name",
				"description": "The name of the Cosmos container that component should connect to. In case you are producing data and have createContainerIfNotExists=true, the component will automatically auto create a Cosmos container.",
				"type": "string",
				"$comment": "group:common"
			},
			"clientTelemetryEnabled": {
				"title": "Client Telemetry Enabled",
				"description": "Sets the flag to enable client telemetry which will periodically collect database operations aggregation statistics, system information like cpu/memory and send it to cosmos monitoring service, which will be helpful during debugging. DEFAULT value is false indicating this is an opt-in feature, by default no telemetry collection.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"connectionSharingAcrossClientsEnabled": {
				"title": "Connection Sharing Across Clients Enabled",
				"description": "Enables connections sharing across multiple Cosmos Clients. The default is false. When you have multiple instances of Cosmos Client in the same JVM interacting with multiple Cosmos accounts, enabling this allows connection sharing in Direct mode if possible between instances of Cosmos Client. Please note, when setting this option, the connection configuration (e.g., socket timeout config, idle timeout config) of the first instantiated client will be used for all other client instances.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"consistencyLevel": {
				"title": "Consistency Level",
				"description": "Sets the consistency levels supported for Azure Cosmos DB client operations in the Azure Cosmos DB service. The requested ConsistencyLevel must match or be weaker than that provisioned for the database account. Consistency levels by order of strength are STRONG, BOUNDED_STALENESS, SESSION and EVENTUAL. Refer to consistency level documentation for additional details: https://docs.microsoft.com/en-us/azure/cosmos-db/consistency-levels",
				"type": "string",
				"enum": [
					"Strong",
					"BoundedStaleness",
					"Session",
					"Eventual",
					"ConsistentPrefix"
				],
				"$comment": "group:common",
				"format": "bean:com.azure.cosmos.ConsistencyLevel",
				"default": "SESSION"
			},
			"containerPartitionKeyPath": {
				"title": "Container Partition Key Path",
				"description": "Sets the container partition key path.",
				"type": "string",
				"$comment": "group:common"
			},
			"contentResponseOnWriteEnabled": {
				"title": "Content Response On Write Enabled",
				"description": "Sets the boolean to only return the headers and status code in Cosmos DB response in case of Create, Update and Delete operations on CosmosItem. In Consumer, it is enabled by default because of the ChangeFeed in the consumer that needs this flag to be enabled, and thus it shouldn't be overridden. In Producer, it is advised to disable it since it reduces the network overhead",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"cosmosAsyncClient": {
				"title": "Cosmos Async Client",
				"description": "Inject an external CosmosAsyncClient into the component which provides a client-side logical representation of the Azure Cosmos DB service. This asynchronous client is used to configure and execute requests against the service.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.cosmos.CosmosAsyncClient"
			},
			"createContainerIfNotExists": {
				"title": "Create Container If Not Exists",
				"description": "Sets if the component should create the Cosmos container automatically in case it doesn't exist in the Cosmos database",
				"type": "boolean",
				"$comment": "group:common"
			},
			"createDatabaseIfNotExists": {
				"title": "Create Database If Not Exists",
				"description": "Sets if the component should create the Cosmos database automatically in case it doesn't exist in the Cosmos account",
				"type": "boolean",
				"$comment": "group:common"
			},
			"databaseEndpoint": {
				"title": "Database Endpoint",
				"description": "Sets the Azure Cosmos database endpoint the component will connect to.",
				"type": "string",
				"$comment": "group:common"
			},
			"multipleWriteRegionsEnabled": {
				"title": "Multiple Write Regions Enabled",
				"description": "Sets the flag to enable writes on any regions for geo-replicated database accounts in the Azure Cosmos DB service. When the value of this property is true, the SDK will direct write operations to available writable regions of geo-replicated database account. Writable regions are ordered by PreferredRegions property. Setting the property value to true has no effect until EnableMultipleWriteRegions in DatabaseAccount is also set to true. DEFAULT value is true indicating that writes are directed to available writable regions of geo-replicated database account.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"preferredRegions": {
				"title": "Preferred Regions",
				"description": "Sets the comma separated preferred regions for geo-replicated database accounts. For example, East US as the preferred region. When EnableEndpointDiscovery is true and PreferredRegions is non-empty, the SDK will prefer to use the regions in the container in the order they are specified to perform operations.",
				"type": "string",
				"$comment": "group:common"
			},
			"readRequestsFallbackEnabled": {
				"title": "Read Requests Fallback Enabled",
				"description": "Sets whether to allow for reads to go to multiple regions configured on an account of Azure Cosmos DB service. DEFAULT value is true. If this property is not set, the default is true for all Consistency Levels other than Bounded Staleness, The default is false for Bounded Staleness. 1. endpointDiscoveryEnabled is true 2. the Azure Cosmos DB account has more than one region",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"throughputProperties": {
				"title": "Throughput Properties",
				"description": "Sets throughput of the resources in the Azure Cosmos DB service.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.cosmos.models.ThroughputProperties"
			},
			"changeFeedProcessorOptions": {
				"title": "Change Feed Processor Options",
				"description": "Sets the ChangeFeedProcessorOptions to be used. Unless specifically set the default values that will be used are: maximum items per page or FeedResponse: 100 lease renew interval: 17 seconds lease acquire interval: 13 seconds lease expiration interval: 60 seconds feed poll delay: 5 seconds maximum scale count: unlimited",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:com.azure.cosmos.models.ChangeFeedProcessorOptions"
			},
			"createLeaseContainerIfNotExists": {
				"title": "Create Lease Container If Not Exists",
				"description": "Sets if the component should create Cosmos lease container for the consumer automatically in case it doesn't exist in Cosmos database",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"createLeaseDatabaseIfNotExists": {
				"title": "Create Lease Database If Not Exists",
				"description": "Sets if the component should create the Cosmos lease database for the consumer automatically in case it doesn't exist in the Cosmos account",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"hostName": {
				"title": "Host Name",
				"description": "Sets the hostname. The host: a host is an application instance that uses the change feed processor to listen for changes. Multiple instances with the same lease configuration can run in parallel, but each instance should have a different instance name. If not specified, this will be a generated random hostname.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"leaseContainerName": {
				"title": "Lease Container Name",
				"description": "Sets the lease container which acts as a state storage and coordinates processing the change feed across multiple workers. The lease container can be stored in the same account as the monitored container or in a separate account. It will be auto-created if createLeaseContainerIfNotExists is set to true.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "camel-lease"
			},
			"leaseDatabaseName": {
				"title": "Lease Database Name",
				"description": "Sets the lease database where the leaseContainerName will be stored. If it is not specified, this component will store the lease container in the same database that is specified in databaseName. It will be auto-created if createLeaseDatabaseIfNotExists is set to true.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"itemId": {
				"title": "Item Id",
				"description": "Sets the itemId in case needed for operation on item like delete, replace",
				"type": "string",
				"$comment": "group:producer"
			},
			"itemPartitionKey": {
				"title": "Item Partition Key",
				"description": "Sets partition key. Represents a partition key value in the Azure Cosmos DB database service. A partition key identifies the partition where the item is stored in.",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The CosmosDB operation that can be used with this component on the producer.",
				"type": "string",
				"enum": [
					"listDatabases",
					"createDatabase",
					"queryDatabases",
					"deleteDatabase",
					"createContainer",
					"replaceDatabaseThroughput",
					"listContainers",
					"queryContainers",
					"deleteContainer",
					"replaceContainerThroughput",
					"createItem",
					"upsertItem",
					"deleteItem",
					"replaceItem",
					"readItem",
					"readAllItems",
					"queryItems"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.azure.cosmosdb.CosmosDbOperationsDefinition",
				"default": "listDatabases"
			},
			"query": {
				"title": "Query",
				"description": "An SQL query to execute on a given resources. To learn more about Cosmos SQL API, check this link {link https://docs.microsoft.com/en-us/azure/cosmos-db/sql-query-getting-started}",
				"type": "string",
				"$comment": "group:producer"
			},
			"queryRequestOptions": {
				"title": "Query Request Options",
				"description": "Set additional QueryRequestOptions that can be used with queryItems, queryContainers, queryDatabases, listDatabases, listItems, listContainers operations",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:com.azure.cosmos.models.CosmosQueryRequestOptions"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"indexingPolicy": {
				"title": "Indexing Policy",
				"description": "The CosmosDB Indexing Policy that will be set in case of container creation, this option is related to createLeaseContainerIfNotExists and it will be taken into account when the latter is true.",
				"type": "string",
				"$comment": "group: advanced",
				"format": "bean:com.azure.cosmos.models.IndexingPolicy"
			},
			"accountKey": {
				"title": "Account Key",
				"description": "Sets either a master or readonly key used to perform authentication for accessing resource.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"credentialType": {
				"title": "Credential Type",
				"description": "Determines the credential strategy to adopt",
				"type": "string",
				"enum": [
					"SHARED_ACCOUNT_KEY",
					"AZURE_IDENTITY"
				],
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.azure.cosmosdb.CredentialType",
				"default": "SHARED_ACCOUNT_KEY"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"databaseEndpoint"
		]
	},
	"azure-eventhubs": {
		"properties": {
			"namespace": {
				"title": "Namespace",
				"description": "EventHubs namespace created in Azure Portal.",
				"type": "string",
				"$comment": "group:common"
			},
			"eventHubName": {
				"title": "Event Hub Name",
				"description": "EventHubs name under a specific namespace.",
				"type": "string",
				"$comment": "group:common"
			},
			"amqpRetryOptions": {
				"title": "Amqp Retry Options",
				"description": "Sets the retry policy for EventHubProducerAsyncClient. If not specified, the default retry options are used.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.core.amqp.AmqpRetryOptions"
			},
			"amqpTransportType": {
				"title": "Amqp Transport Type",
				"description": "Sets the transport type by which all the communication with Azure Event Hubs occurs.",
				"type": "string",
				"enum": [
					"Amqp",
					"AmqpWebSockets"
				],
				"$comment": "group:common",
				"format": "bean:com.azure.core.amqp.AmqpTransportType",
				"default": "AMQP"
			},
			"blobAccessKey": {
				"title": "Blob Access Key",
				"description": "In case you chose the default BlobCheckpointStore, this sets access key for the associated azure account name to be used for authentication with azure blob services.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "password"
			},
			"blobAccountName": {
				"title": "Blob Account Name",
				"description": "In case you chose the default BlobCheckpointStore, this sets Azure account name to be used for authentication with azure blob services.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"blobContainerName": {
				"title": "Blob Container Name",
				"description": "In case you chose the default BlobCheckpointStore, this sets the blob container that shall be used by the BlobCheckpointStore to store the checkpoint offsets.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"blobStorageSharedKeyCredential": {
				"title": "Blob Storage Shared Key Credential",
				"description": "In case you chose the default BlobCheckpointStore, StorageSharedKeyCredential can be injected to create the azure client, this holds the important authentication information.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:com.azure.storage.common.StorageSharedKeyCredential|password"
			},
			"checkpointBatchSize": {
				"title": "Checkpoint Batch Size",
				"description": "Sets the batch size between each checkpoint update. Works jointly with checkpointBatchTimeout.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 500
			},
			"checkpointBatchTimeout": {
				"title": "Checkpoint Batch Timeout",
				"description": "Sets the batch timeout between each checkpoint update. Works jointly with checkpointBatchSize.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 5000
			},
			"checkpointStore": {
				"title": "Checkpoint Store",
				"description": "Sets the CheckpointStore the EventProcessorClient will use for storing partition ownership and checkpoint information. Users can, optionally, provide their own implementation of CheckpointStore which will store ownership and checkpoint information. By default, it's set to use com.azure.messaging.eventhubs.checkpointstore.blob.BlobCheckpointStore which stores all checkpoint offsets into Azure Blob Storage.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:com.azure.messaging.eventhubs.CheckpointStore",
				"default": "BlobCheckpointStore"
			},
			"consumerGroupName": {
				"title": "Consumer Group Name",
				"description": "Sets the name of the consumer group this consumer is associated with. Events are read in the context of this group. The name of the consumer group that is created by default is $Default.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "$Default"
			},
			"eventPosition": {
				"title": "Event Position",
				"description": "Sets the map containing the event position to use for each partition if a checkpoint for the partition does not exist in CheckpointStore. This map is keyed off of the partition id. If there is no checkpoint in CheckpointStore and there is no entry in this map, the processing of the partition will start from EventPosition#latest() position.",
				"type": "object",
				"$comment": "group:consumer"
			},
			"prefetchCount": {
				"title": "Prefetch Count",
				"description": "Sets the count used by the receiver to control the number of events the Event Hub consumer will actively receive and queue locally without regard to whether a receive operation is currently active.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 500
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"partitionId": {
				"title": "Partition Id",
				"description": "Sets the identifier of the Event Hub partition that the EventData events will be sent to. If the identifier is not specified, the Event Hubs service will be responsible for routing events that are sent to an available partition.",
				"type": "string",
				"$comment": "group:producer"
			},
			"partitionKey": {
				"title": "Partition Key",
				"description": "Sets a hashing key to be provided for the batch of events, which instructs the Event Hubs service to map this key to a specific partition. The selection of a partition is stable for a given partition hashing key. Should any other batches of events be sent using the same exact partition hashing key, the Event Hubs service will route them all to the same partition. This should be specified only when there is a need to group events by partition, but there is flexibility into which partition they are routed. If ensuring that a batch of events is sent only to a specific partition, it is recommended that the identifier of the position be specified directly when sending the batch.",
				"type": "string",
				"$comment": "group:producer"
			},
			"producerAsyncClient": {
				"title": "Producer Async Client",
				"description": "Sets the EventHubProducerAsyncClient.An asynchronous producer responsible for transmitting EventData to a specific Event Hub, grouped together in batches. Depending on the com.azure.messaging.eventhubs.models.CreateBatchOptions options specified when creating an com.azure.messaging.eventhubs.EventDataBatch, the events may be automatically routed to an available partition or specific to a partition. Use by this component to produce the data in camel producer.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:com.azure.messaging.eventhubs.EventHubProducerAsyncClient"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionString": {
				"title": "Connection String",
				"description": "Instead of supplying namespace, sharedAccessKey, sharedAccessName, etc. you can supply the connection string for your eventHub. The connection string for EventHubs already includes all the necessary information to connect to your EventHub. To learn how to generate the connection string, take a look at this documentation: https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"credentialType": {
				"title": "Credential Type",
				"description": "Determines the credential strategy to adopt",
				"type": "string",
				"enum": [
					"AZURE_IDENTITY",
					"CONNECTION_STRING",
					"TOKEN_CREDENTIAL"
				],
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.azure.eventhubs.CredentialType",
				"default": "CONNECTION_STRING"
			},
			"sharedAccessKey": {
				"title": "Shared Access Key",
				"description": "The generated value for the SharedAccessName.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sharedAccessName": {
				"title": "Shared Access Name",
				"description": "The name you chose for your EventHubs SAS keys.",
				"type": "string",
				"$comment": "group:security"
			},
			"tokenCredential": {
				"title": "Token Credential",
				"description": "Provide custom authentication credentials using an implementation of TokenCredential.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:com.azure.core.credential.TokenCredential|password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"azure-files": {
		"properties": {
			"account": {
				"title": "Account",
				"description": "The account to use",
				"type": "string",
				"$comment": "group:common"
			},
			"share": {
				"title": "Share",
				"description": "The share to use",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port of the FTP server",
				"type": "integer",
				"$comment": "group:common"
			},
			"directoryName": {
				"title": "Directory Name",
				"description": "The starting directory",
				"type": "string",
				"$comment": "group:common"
			},
			"credentialType": {
				"title": "Credential Type",
				"description": "Determines the credential strategy to adopt",
				"type": "string",
				"enum": [
					"SHARED_ACCOUNT_KEY",
					"SHARED_KEY_CREDENTIAL",
					"AZURE_IDENTITY",
					"AZURE_SAS"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.file.azure.CredentialType",
				"default": "SHARED_ACCOUNT_KEY"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"doneFileName": {
				"title": "Done File Name",
				"description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
				"type": "string",
				"$comment": "group:common"
			},
			"fileName": {
				"title": "File Name",
				"description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
				"type": "string",
				"$comment": "group:common"
			},
			"sharedKey": {
				"title": "Shared Key",
				"description": "Shared key (storage account key)",
				"type": "string",
				"$comment": "group:common",
				"format": "password"
			},
			"delete": {
				"title": "Delete",
				"description": "If true, the file will be deleted after it is processed successfully.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveFailed": {
				"title": "Move Failed",
				"description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"noop": {
				"title": "Noop",
				"description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"preMove": {
				"title": "Pre Move",
				"description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"preSort": {
				"title": "Pre Sort",
				"description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"recursive": {
				"title": "Recursive",
				"description": "If a directory, will look for files in all the sub-directories as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"resumeDownload": {
				"title": "Resume Download",
				"description": "Configures whether resume download is enabled. In addition the options localWorkDirectory must be configured so downloaded files are stored in a local directory, which is required to support resuming of downloads.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"streamDownload": {
				"title": "Stream Download",
				"description": "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"download": {
				"title": "Download",
				"description": "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"inProgressRepository": {
				"title": "In Progress Repository",
				"description": "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"localWorkDirectory": {
				"title": "Local Work Directory",
				"description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"onCompletionExceptionHandler": {
				"title": "On Completion Exception Handler",
				"description": "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"processStrategy": {
				"title": "Process Strategy",
				"description": "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.file.GenericFileProcessStrategy<com.azure.storage.file.share.models.ShareFileItem>"
			},
			"throwExceptionOnConnectFailed": {
				"title": "Throw Exception On Connect Failed",
				"description": "Should an exception be thrown if connection failed (exhausted)By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"checksumFileAlgorithm": {
				"title": "Checksum File Algorithm",
				"description": "If provided, then Camel will write a checksum file when the original file has been written. The checksum file will contain the checksum created with the provided algorithm for the original file. The checksum file will always be written in the same folder as the original file.",
				"type": "string",
				"enum": [
					"MD2",
					"MD5",
					"SHA_1",
					"SHA_224",
					"SHA_256",
					"SHA_384",
					"SHA_512",
					"SHA_512_224",
					"SHA_512_256",
					"SHA3_224",
					"SHA3_256",
					"SHA3_384",
					"SHA3_512"
				],
				"$comment": "group:producer"
			},
			"fileExist": {
				"title": "File Exist",
				"description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
				"type": "string",
				"enum": [
					"Override",
					"Append",
					"Fail",
					"Ignore",
					"Move",
					"TryRename"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.file.GenericFileExist",
				"default": "Override"
			},
			"flatten": {
				"title": "Flatten",
				"description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"jailStartingDirectory": {
				"title": "Jail Starting Directory",
				"description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"tempFileName": {
				"title": "Temp File Name",
				"description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempPrefix": {
				"title": "Temp Prefix",
				"description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"disconnectOnBatchComplete": {
				"title": "Disconnect On Batch Complete",
				"description": "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"eagerDeleteTargetFile": {
				"title": "Eager Delete Target File",
				"description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"keepLastModified": {
				"title": "Keep Last Modified",
				"description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"moveExistingFileStrategy": {
				"title": "Move Existing File Strategy",
				"description": "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.file.strategy.FileMoveExistingStrategy"
			},
			"autoCreate": {
				"title": "Auto Create",
				"description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "10000"
			},
			"maximumReconnectAttempts": {
				"title": "Maximum Reconnect Attempts",
				"description": "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"reconnectDelay": {
				"title": "Reconnect Delay",
				"description": "Delay in millis Camel will wait before performing a reconnect attempt.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets the data timeout for waiting for reply Used only by FTPClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "30000"
			},
			"antExclude": {
				"title": "Ant Exclude",
				"description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"antFilterCaseSensitive": {
				"title": "Ant Filter Case Sensitive",
				"description": "Sets case sensitive flag on ant filter.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"antInclude": {
				"title": "Ant Include",
				"description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"eagerMaxMessagesPerPoll": {
				"title": "Eager Max Messages Per Poll",
				"description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"exclude": {
				"title": "Exclude",
				"description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"excludeExt": {
				"title": "Exclude Ext",
				"description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"filter": {
				"title": "Filter",
				"description": "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.component.file.GenericFileFilter<com.azure.storage.file.share.models.ShareFileItem>"
			},
			"filterDirectory": {
				"title": "Filter Directory",
				"description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
				"type": "string",
				"$comment": "group:filter"
			},
			"filterFile": {
				"title": "Filter File",
				"description": "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotent": {
				"title": "Idempotent",
				"description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:filter"
			},
			"idempotentEager": {
				"title": "Idempotent Eager",
				"description": "Sets whether to eagerly add the filename to the idempotent repository or wait until the exchange is complete.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"idempotentKey": {
				"title": "Idempotent Key",
				"description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryIdempotentRepository if none is specified and idempotent is true.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"include": {
				"title": "Include",
				"description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"includeExt": {
				"title": "Include Ext",
				"description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"maxDepth": {
				"title": "Max Depth",
				"description": "The maximum depth to traverse when recursively processing a directory.",
				"type": "integer",
				"$comment": "group:filter",
				"default": 2147483647
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"minDepth": {
				"title": "Min Depth",
				"description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"move": {
				"title": "Move",
				"description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
				"type": "string",
				"$comment": "group:filter"
			},
			"exclusiveReadLockStrategy": {
				"title": "Exclusive Read Lock Strategy",
				"description": "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
				"type": "string",
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy<com.azure.storage.file.share.models.ShareFileItem>"
			},
			"readLock": {
				"title": "Read Lock",
				"description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
				"type": "string",
				"enum": [
					"none",
					"markerFile",
					"fileLock",
					"rename",
					"changed",
					"idempotent",
					"idempotent-changed",
					"idempotent-rename"
				],
				"$comment": "group:lock",
				"default": "none"
			},
			"readLockCheckInterval": {
				"title": "Read Lock Check Interval",
				"description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1000
			},
			"readLockDeleteOrphanLockFiles": {
				"title": "Read Lock Delete Orphan Lock Files",
				"description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockLoggingLevel": {
				"title": "Read Lock Logging Level",
				"description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"readLockMarkerFile": {
				"title": "Read Lock Marker File",
				"description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockMinAge": {
				"title": "Read Lock Min Age",
				"description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 0
			},
			"readLockMinLength": {
				"title": "Read Lock Min Length",
				"description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1
			},
			"readLockRemoveOnCommit": {
				"title": "Read Lock Remove On Commit",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "boolean",
				"$comment": "group:lock"
			},
			"readLockRemoveOnRollback": {
				"title": "Read Lock Remove On Rollback",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockTimeout": {
				"title": "Read Lock Timeout",
				"description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 10000
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"sdd": {
				"title": "Sdd",
				"description": "part of service SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"se": {
				"title": "Se",
				"description": "part of SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"si": {
				"title": "Si",
				"description": "part of service SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sig": {
				"title": "Sig",
				"description": "part of SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sip": {
				"title": "Sip",
				"description": "part of SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sp": {
				"title": "Sp",
				"description": "part of SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"spr": {
				"title": "Spr",
				"description": "part of SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sr": {
				"title": "Sr",
				"description": "part of service SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"srt": {
				"title": "Srt",
				"description": "part of SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"ss": {
				"title": "Ss",
				"description": "part of account SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"st": {
				"title": "St",
				"description": "part of SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sv": {
				"title": "Sv",
				"description": "part of SAS token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"shuffle": {
				"title": "Shuffle",
				"description": "To shuffle the list of files (sort in random order)",
				"type": "boolean",
				"$comment": "group:sort"
			},
			"sortBy": {
				"title": "Sort By",
				"description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
				"type": "string",
				"$comment": "group:sort"
			},
			"sorter": {
				"title": "Sorter",
				"description": "Pluggable sorter as a java.util.Comparator class.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:java.util.Comparator<org.apache.camel.component.file.GenericFile<com.azure.storage.file.share.models.ShareFileItem>>"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"account",
			"share"
		]
	},
	"azure-key-vault": {
		"properties": {
			"vaultName": {
				"title": "Vault Name",
				"description": "Vault Name to be used",
				"type": "string",
				"$comment": "group:producer"
			},
			"credentialType": {
				"title": "Credential Type",
				"description": "Determines the credential strategy to adopt",
				"type": "string",
				"enum": [
					"CLIENT_SECRET",
					"AZURE_IDENTITY"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.azure.key.vault.CredentialType",
				"default": "CLIENT_SECRET"
			},
			"operation": {
				"title": "Operation",
				"description": "Operation to be performed",
				"type": "string",
				"enum": [
					"createSecret",
					"getSecret",
					"updateSecretProperties",
					"deleteSecret",
					"purgeDeletedSecret"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.azure.key.vault.KeyVaultOperation"
			},
			"secretClient": {
				"title": "Secret Client",
				"description": "Instance of Secret client",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:com.azure.security.keyvault.secrets.SecretClient"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Client Id to be used",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Client Secret to be used",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"tenantId": {
				"title": "Tenant Id",
				"description": "Tenant Id to be used",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"azure-servicebus": {
		"properties": {
			"topicOrQueueName": {
				"title": "Topic Or Queue Name",
				"description": "Selected topic name or the queue name, that is depending on serviceBusType config. For example if serviceBusType=queue, then this will be the queue name and if serviceBusType=topic, this will be the topic name.",
				"type": "string",
				"$comment": "group:common"
			},
			"amqpRetryOptions": {
				"title": "Amqp Retry Options",
				"description": "Sets the retry options for Service Bus clients. If not specified, the default retry options are used.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.core.amqp.AmqpRetryOptions"
			},
			"amqpTransportType": {
				"title": "Amqp Transport Type",
				"description": "Sets the transport type by which all the communication with Azure Service Bus occurs. Default value is AMQP.",
				"type": "string",
				"enum": [
					"Amqp",
					"AmqpWebSockets"
				],
				"$comment": "group:common",
				"format": "bean:com.azure.core.amqp.AmqpTransportType",
				"default": "AMQP"
			},
			"clientOptions": {
				"title": "Client Options",
				"description": "Sets the ClientOptions to be sent from the client built from this builder, enabling customization of certain properties, as well as support the addition of custom header information.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.core.util.ClientOptions"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter Service Bus application properties to and from Camel message headers.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"proxyOptions": {
				"title": "Proxy Options",
				"description": "Sets the proxy configuration to use for ServiceBusSenderClient. When a proxy is configured, AMQP_WEB_SOCKETS must be used for the transport type.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.core.amqp.ProxyOptions"
			},
			"serviceBusType": {
				"title": "Service Bus Type",
				"description": "The service bus type of connection to execute. Queue is for typical queue option and topic for subscription based model.",
				"type": "string",
				"enum": [
					"queue",
					"topic"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.azure.servicebus.ServiceBusType",
				"default": "queue"
			},
			"enableDeadLettering": {
				"title": "Enable Dead Lettering",
				"description": "Enable application level deadlettering to the subscription deadletter subqueue if deadletter related headers are set.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maxAutoLockRenewDuration": {
				"title": "Max Auto Lock Renew Duration",
				"description": "Sets the amount of time to continue auto-renewing the lock. Setting ZERO disables auto-renewal. For ServiceBus receive mode (RECEIVE_AND_DELETE RECEIVE_AND_DELETE), auto-renewal is disabled.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:java.time.Duration",
				"default": "5m"
			},
			"maxConcurrentCalls": {
				"title": "Max Concurrent Calls",
				"description": "Sets maximum number of concurrent calls",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"prefetchCount": {
				"title": "Prefetch Count",
				"description": "Sets the prefetch count of the receiver. For both PEEK_LOCK PEEK_LOCK and RECEIVE_AND_DELETE RECEIVE_AND_DELETE receive modes the default value is 1. Prefetch speeds up the message flow by aiming to have a message readily available for local retrieval when and before the application asks for one using receive message. Setting a non-zero value will prefetch that number of messages. Setting the value to zero turns prefetch off.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"processorClient": {
				"title": "Processor Client",
				"description": "Sets the processorClient in order to consume messages by the consumer",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:com.azure.messaging.servicebus.ServiceBusProcessorClient"
			},
			"serviceBusReceiveMode": {
				"title": "Service Bus Receive Mode",
				"description": "Sets the receive mode for the receiver.",
				"type": "string",
				"enum": [
					"PEEK_LOCK",
					"RECEIVE_AND_DELETE"
				],
				"$comment": "group:consumer",
				"format": "bean:com.azure.messaging.servicebus.models.ServiceBusReceiveMode",
				"default": "PEEK_LOCK"
			},
			"sessionEnabled": {
				"title": "Session Enabled",
				"description": "Enable session support",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"subQueue": {
				"title": "Sub Queue",
				"description": "Sets the type of the SubQueue to connect to.",
				"type": "string",
				"enum": [
					"NONE",
					"DEAD_LETTER_QUEUE",
					"TRANSFER_DEAD_LETTER_QUEUE"
				],
				"$comment": "group:consumer",
				"format": "bean:com.azure.messaging.servicebus.models.SubQueue"
			},
			"subscriptionName": {
				"title": "Subscription Name",
				"description": "Sets the name of the subscription in the topic to listen to. topicOrQueueName and serviceBusType=topic must also be set. This property is required if serviceBusType=topic and the consumer is in use.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"binary": {
				"title": "Binary",
				"description": "Set binary mode. If true, message body will be sent as byte. By default, it is false.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"producerOperation": {
				"title": "Producer Operation",
				"description": "Sets the desired operation to be used in the producer",
				"type": "string",
				"enum": [
					"sendMessages",
					"scheduleMessages"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.azure.servicebus.ServiceBusProducerOperationDefinition",
				"default": "sendMessages"
			},
			"scheduledEnqueueTime": {
				"title": "Scheduled Enqueue Time",
				"description": "Sets OffsetDateTime at which the message should appear in the Service Bus queue or topic.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.time.OffsetDateTime"
			},
			"senderClient": {
				"title": "Sender Client",
				"description": "Sets senderClient to be used in the producer.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:com.azure.messaging.servicebus.ServiceBusSenderClient"
			},
			"serviceBusTransactionContext": {
				"title": "Service Bus Transaction Context",
				"description": "Represents transaction in service. This object just contains transaction id.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:com.azure.messaging.servicebus.ServiceBusTransactionContext"
			},
			"sessionId": {
				"title": "Session Id",
				"description": "Session ID for session-enabled queues or topics.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionString": {
				"title": "Connection String",
				"description": "Sets the connection string for a Service Bus namespace or a specific Service Bus resource.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"credentialType": {
				"title": "Credential Type",
				"description": "Determines the credential strategy to adopt",
				"type": "string",
				"enum": [
					"AZURE_IDENTITY",
					"CONNECTION_STRING",
					"TOKEN_CREDENTIAL"
				],
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.azure.servicebus.CredentialType",
				"default": "CONNECTION_STRING"
			},
			"fullyQualifiedNamespace": {
				"title": "Fully Qualified Namespace",
				"description": "Fully Qualified Namespace of the service bus",
				"type": "string",
				"$comment": "group:security"
			},
			"tokenCredential": {
				"title": "Token Credential",
				"description": "A TokenCredential for Azure AD authentication.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:com.azure.core.credential.TokenCredential|password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"serviceBusType"
		]
	},
	"azure-storage-blob": {
		"properties": {
			"accountName": {
				"title": "Account Name",
				"description": "Azure account name to be used for authentication with azure blob services",
				"type": "string",
				"$comment": "group:common"
			},
			"containerName": {
				"title": "Container Name",
				"description": "The blob container name",
				"type": "string",
				"$comment": "group:common"
			},
			"blobName": {
				"title": "Blob Name",
				"description": "The blob name, to consume specific blob from a container. However, on producer it is only required for the operations on the blob level",
				"type": "string",
				"$comment": "group:common"
			},
			"blobOffset": {
				"title": "Blob Offset",
				"description": "Set the blob offset for the upload or download operations, default is 0",
				"type": "integer",
				"$comment": "group:common",
				"default": 0
			},
			"blobServiceClient": {
				"title": "Blob Service Client",
				"description": "Client to a storage account. This client does not hold any state about a particular storage account but is instead a convenient way of sending off appropriate requests to the resource on the service. It may also be used to construct URLs to blobs and containers. This client contains operations on a service account. Operations on a container are available on BlobContainerClient through getBlobContainerClient(String), and operations on a blob are available on BlobClient through getBlobContainerClient(String).getBlobClient(String).",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.storage.blob.BlobServiceClient"
			},
			"blobType": {
				"title": "Blob Type",
				"description": "The blob type in order to initiate the appropriate settings for each blob type",
				"type": "string",
				"enum": [
					"blockblob",
					"appendblob",
					"pageblob"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.azure.storage.blob.BlobType",
				"default": "blockblob"
			},
			"closeStreamAfterRead": {
				"title": "Close Stream After Read",
				"description": "Close the stream after read or keep it open, default is true",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"credentials": {
				"title": "Credentials",
				"description": "StorageSharedKeyCredential can be injected to create the azure client, this holds the important authentication information",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.storage.common.StorageSharedKeyCredential"
			},
			"credentialType": {
				"title": "Credential Type",
				"description": "Determines the credential strategy to adopt",
				"type": "string",
				"enum": [
					"SHARED_ACCOUNT_KEY",
					"SHARED_KEY_CREDENTIAL",
					"AZURE_IDENTITY",
					"AZURE_SAS"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.azure.storage.blob.CredentialType",
				"default": "AZURE_IDENTITY"
			},
			"dataCount": {
				"title": "Data Count",
				"description": "How many bytes to include in the range. Must be greater than or equal to 0 if specified.",
				"type": "integer",
				"$comment": "group:common"
			},
			"fileDir": {
				"title": "File Dir",
				"description": "The file directory where the downloaded blobs will be saved to, this can be used in both, producer and consumer",
				"type": "string",
				"$comment": "group:common"
			},
			"maxResultsPerPage": {
				"title": "Max Results Per Page",
				"description": "Specifies the maximum number of blobs to return, including all BlobPrefix elements. If the request does not specify maxResultsPerPage or specifies a value greater than 5,000, the server will return up to 5,000 items.",
				"type": "integer",
				"$comment": "group:common"
			},
			"maxRetryRequests": {
				"title": "Max Retry Requests",
				"description": "Specifies the maximum number of additional HTTP Get requests that will be made while reading the data from a response body.",
				"type": "integer",
				"$comment": "group:common",
				"default": 0
			},
			"prefix": {
				"title": "Prefix",
				"description": "Filters the results to return only blobs whose names begin with the specified prefix. May be null to return all blobs.",
				"type": "string",
				"$comment": "group:common"
			},
			"regex": {
				"title": "Regex",
				"description": "Filters the results to return only blobs whose names match the specified regular expression. May be null to return all if both prefix and regex are set, regex takes the priority and prefix is ignored.",
				"type": "string",
				"$comment": "group:common"
			},
			"sasToken": {
				"title": "Sas Token",
				"description": "In case of usage of Shared Access Signature we'll need to set a SAS Token",
				"type": "string",
				"$comment": "group:common"
			},
			"serviceClient": {
				"title": "Service Client",
				"description": "Client to a storage account. This client does not hold any state about a particular storage account but is instead a convenient way of sending off appropriate requests to the resource on the service. It may also be used to construct URLs to blobs and containers. This client contains operations on a service account. Operations on a container are available on BlobContainerClient through BlobServiceClient#getBlobContainerClient(String), and operations on a blob are available on BlobClient through BlobContainerClient#getBlobClient(String).",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.storage.blob.BlobServiceClient"
			},
			"timeout": {
				"title": "Timeout",
				"description": "An optional timeout value beyond which a RuntimeException will be raised.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.time.Duration"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"blobSequenceNumber": {
				"title": "Blob Sequence Number",
				"description": "A user-controlled value that you can use to track requests. The value of the sequence number must be between 0 and 263 - 1.The default value is 0.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "0"
			},
			"blockListType": {
				"title": "Block List Type",
				"description": "Specifies which type of blocks to return.",
				"type": "string",
				"enum": [
					"committed",
					"uncommitted",
					"all"
				],
				"$comment": "group:producer",
				"format": "bean:com.azure.storage.blob.models.BlockListType",
				"default": "COMMITTED"
			},
			"changeFeedContext": {
				"title": "Change Feed Context",
				"description": "When using getChangeFeed producer operation, this gives additional context that is passed through the Http pipeline during the service call.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:com.azure.core.util.Context"
			},
			"changeFeedEndTime": {
				"title": "Change Feed End Time",
				"description": "When using getChangeFeed producer operation, this filters the results to return events approximately before the end time. Note: A few events belonging to the next hour can also be returned. A few events belonging to this hour can be missing; to ensure all events from the hour are returned, round the end time up by an hour.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.time.OffsetDateTime"
			},
			"changeFeedStartTime": {
				"title": "Change Feed Start Time",
				"description": "When using getChangeFeed producer operation, this filters the results to return events approximately after the start time. Note: A few events belonging to the previous hour can also be returned. A few events belonging to this hour can be missing; to ensure all events from the hour are returned, round the start time down by an hour.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.time.OffsetDateTime"
			},
			"closeStreamAfterWrite": {
				"title": "Close Stream After Write",
				"description": "Close the stream after write or keep it open, default is true",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"commitBlockListLater": {
				"title": "Commit Block List Later",
				"description": "When is set to true, the staged blocks will not be committed directly.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"createAppendBlob": {
				"title": "Create Append Blob",
				"description": "When is set to true, the append blocks will be created when committing append blocks.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"createPageBlob": {
				"title": "Create Page Blob",
				"description": "When is set to true, the page blob will be created when uploading page blob.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"downloadLinkExpiration": {
				"title": "Download Link Expiration",
				"description": "Override the default expiration (millis) of URL download link.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The blob operation that can be used with this component on the producer",
				"type": "string",
				"enum": [
					"listBlobContainers",
					"createBlobContainer",
					"deleteBlobContainer",
					"listBlobs",
					"getBlob",
					"deleteBlob",
					"downloadBlobToFile",
					"downloadLink",
					"uploadBlockBlob",
					"stageBlockBlobList",
					"commitBlobBlockList",
					"getBlobBlockList",
					"createAppendBlob",
					"commitAppendBlob",
					"createPageBlob",
					"uploadPageBlob",
					"resizePageBlob",
					"clearPageBlob",
					"getPageBlobRanges"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.azure.storage.blob.BlobOperationsDefinition",
				"default": "listBlobContainers"
			},
			"pageBlobSize": {
				"title": "Page Blob Size",
				"description": "Specifies the maximum size for the page blob, up to 8 TB. The page blob size must be aligned to a 512-byte boundary.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "512"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Access key for the associated azure account name to be used for authentication with azure blob services",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sourceBlobAccessKey": {
				"title": "Source Blob Access Key",
				"description": "Source Blob Access Key: for copyblob operation, sadly, we need to have an accessKey for the source blob we want to copy Passing an accessKey as header, it's unsafe so we could set as key.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"azure-storage-datalake": {
		"properties": {
			"accountName": {
				"title": "Account Name",
				"description": "name of the azure account",
				"type": "string",
				"$comment": "group:common"
			},
			"fileSystemName": {
				"title": "File System Name",
				"description": "name of filesystem to be used",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "client id for azure account",
				"type": "string",
				"$comment": "group:common"
			},
			"close": {
				"title": "Close",
				"description": "Whether or not a file changed event raised indicates completion (true) or modification (false)",
				"type": "boolean",
				"$comment": "group:common"
			},
			"closeStreamAfterRead": {
				"title": "Close Stream After Read",
				"description": "check for closing stream after read",
				"type": "boolean",
				"$comment": "group:common"
			},
			"credentialType": {
				"title": "Credential Type",
				"description": "Determines the credential strategy to adopt",
				"type": "string",
				"enum": [
					"CLIENT_SECRET",
					"SHARED_KEY_CREDENTIAL",
					"AZURE_IDENTITY",
					"AZURE_SAS",
					"SERVICE_CLIENT_INSTANCE"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.azure.storage.datalake.CredentialType",
				"default": "CLIENT_SECRET"
			},
			"dataCount": {
				"title": "Data Count",
				"description": "count number of bytes to download",
				"type": "integer",
				"$comment": "group:common"
			},
			"dataLakeServiceClient": {
				"title": "Data Lake Service Client",
				"description": "service client of data lake",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.storage.file.datalake.DataLakeServiceClient"
			},
			"directoryName": {
				"title": "Directory Name",
				"description": "directory of the file to be handled in component",
				"type": "string",
				"$comment": "group:common"
			},
			"downloadLinkExpiration": {
				"title": "Download Link Expiration",
				"description": "download link expiration time",
				"type": "integer",
				"$comment": "group:common"
			},
			"expression": {
				"title": "Expression",
				"description": "expression for queryInputStream",
				"type": "string",
				"$comment": "group:common"
			},
			"fileDir": {
				"title": "File Dir",
				"description": "directory of file to do operations in the local system",
				"type": "string",
				"$comment": "group:common"
			},
			"fileName": {
				"title": "File Name",
				"description": "name of file to be handled in component",
				"type": "string",
				"$comment": "group:common"
			},
			"fileOffset": {
				"title": "File Offset",
				"description": "offset position in file for different operations",
				"type": "integer",
				"$comment": "group:common"
			},
			"maxResults": {
				"title": "Max Results",
				"description": "maximum number of results to show at a time",
				"type": "integer",
				"$comment": "group:common"
			},
			"maxRetryRequests": {
				"title": "Max Retry Requests",
				"description": "no of retries to a given request",
				"type": "integer",
				"$comment": "group:common"
			},
			"openOptions": {
				"title": "Open Options",
				"description": "set open options for creating file",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.util.Set<java.nio.file.OpenOption>"
			},
			"path": {
				"title": "Path",
				"description": "path in azure data lake for operations",
				"type": "string",
				"$comment": "group:common"
			},
			"permission": {
				"title": "Permission",
				"description": "permission string for the file",
				"type": "string",
				"$comment": "group:common"
			},
			"position": {
				"title": "Position",
				"description": "This parameter allows the caller to upload data in parallel and control the order in which it is appended to the file.",
				"type": "integer",
				"$comment": "group:common"
			},
			"recursive": {
				"title": "Recursive",
				"description": "recursively include all paths",
				"type": "boolean",
				"$comment": "group:common"
			},
			"regex": {
				"title": "Regex",
				"description": "regular expression for matching file names",
				"type": "string",
				"$comment": "group:common"
			},
			"retainUncommitedData": {
				"title": "Retain Uncommited Data",
				"description": "Whether or not uncommitted data is to be retained after the operation",
				"type": "boolean",
				"$comment": "group:common"
			},
			"serviceClient": {
				"title": "Service Client",
				"description": "data lake service client for azure storage data lake",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.storage.file.datalake.DataLakeServiceClient"
			},
			"sharedKeyCredential": {
				"title": "Shared Key Credential",
				"description": "shared key credential for azure data lake gen2",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.storage.common.StorageSharedKeyCredential"
			},
			"tenantId": {
				"title": "Tenant Id",
				"description": "tenant id for azure account",
				"type": "string",
				"$comment": "group:common"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Timeout for operation",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.time.Duration"
			},
			"umask": {
				"title": "Umask",
				"description": "umask permission for file",
				"type": "string",
				"$comment": "group:common"
			},
			"userPrincipalNameReturned": {
				"title": "User Principal Name Returned",
				"description": "whether or not to use upn",
				"type": "boolean",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"operation": {
				"title": "Operation",
				"description": "operation to be performed",
				"type": "string",
				"enum": [
					"listFileSystem",
					"listFiles"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.azure.storage.datalake.DataLakeOperationsDefinition",
				"default": "listFileSystem"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accountKey": {
				"title": "Account Key",
				"description": "account key for authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "client secret for azure account",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecretCredential": {
				"title": "Client Secret Credential",
				"description": "client secret credential for authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:com.azure.identity.ClientSecretCredential|password"
			},
			"sasCredential": {
				"title": "Sas Credential",
				"description": "SAS token credential",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:com.azure.core.credential.AzureSasCredential|password"
			},
			"sasSignature": {
				"title": "Sas Signature",
				"description": "SAS token signature",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"azure-storage-queue": {
		"properties": {
			"accountName": {
				"title": "Account Name",
				"description": "Azure account name to be used for authentication with azure queue services",
				"type": "string",
				"$comment": "group:common"
			},
			"queueName": {
				"title": "Queue Name",
				"description": "The queue resource name",
				"type": "string",
				"$comment": "group:common"
			},
			"credentialType": {
				"title": "Credential Type",
				"description": "Determines the credential strategy to adopt",
				"type": "string",
				"enum": [
					"SHARED_ACCOUNT_KEY",
					"SHARED_KEY_CREDENTIAL",
					"AZURE_IDENTITY"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.azure.storage.queue.CredentialType",
				"default": "SHARED_ACCOUNT_KEY"
			},
			"serviceClient": {
				"title": "Service Client",
				"description": "Service client to a storage account to interact with the queue service. This client does not hold any state about a particular storage account but is instead a convenient way of sending off appropriate requests to the resource on the service. This client contains all the operations for interacting with a queue account in Azure Storage. Operations allowed by the client are creating, listing, and deleting queues, retrieving and updating properties of the account, and retrieving statistics of the account.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.azure.storage.queue.QueueServiceClient"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"createQueue": {
				"title": "Create Queue",
				"description": "When is set to true, the queue will be automatically created when sending messages to the queue.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Queue service operation hint to the producer",
				"type": "string",
				"enum": [
					"listQueues",
					"createQueue",
					"deleteQueue",
					"clearQueue",
					"sendMessage",
					"deleteMessage",
					"receiveMessages",
					"peekMessages",
					"updateMessage"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.azure.storage.queue.QueueOperationDefinition"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"maxMessages": {
				"title": "Max Messages",
				"description": "Maximum number of messages to get, if there are less messages exist in the queue than requested all the messages will be returned. If left empty only 1 message will be retrieved, the allowed range is 1 to 32 messages.",
				"type": "integer",
				"$comment": "group:queue",
				"default": "1"
			},
			"messageId": {
				"title": "Message Id",
				"description": "The ID of the message to be deleted or updated.",
				"type": "string",
				"$comment": "group:queue"
			},
			"popReceipt": {
				"title": "Pop Receipt",
				"description": "Unique identifier that must match for the message to be deleted or updated.",
				"type": "string",
				"$comment": "group:queue"
			},
			"timeout": {
				"title": "Timeout",
				"description": "An optional timeout applied to the operation. If a response is not returned before the timeout concludes a RuntimeException will be thrown.",
				"type": "string",
				"$comment": "group:queue",
				"format": "bean:java.time.Duration"
			},
			"timeToLive": {
				"title": "Time To Live",
				"description": "How long the message will stay alive in the queue. If unset the value will default to 7 days, if -1 is passed the message will not expire. The time to live must be -1 or any positive number. The format should be in this form: PnDTnHnMn.nS., e.g: PT20.345S -- parses as 20.345 seconds, P2D -- parses as 2 days However, in case you are using EndpointDsl/ComponentDsl, you can do something like Duration.ofSeconds() since these Java APIs are typesafe.",
				"type": "string",
				"$comment": "group:queue",
				"format": "bean:java.time.Duration"
			},
			"visibilityTimeout": {
				"title": "Visibility Timeout",
				"description": "The timeout period for how long the message is invisible in the queue. The timeout must be between 1 seconds and 7 days. The format should be in this form: PnDTnHnMn.nS., e.g: PT20.345S -- parses as 20.345 seconds, P2D -- parses as 2 days However, in case you are using EndpointDsl/ComponentDsl, you can do something like Duration.ofSeconds() since these Java APIs are typesafe.",
				"type": "string",
				"$comment": "group:queue",
				"format": "bean:java.time.Duration"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Access key for the associated azure account name to be used for authentication with azure queue services",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"credentials": {
				"title": "Credentials",
				"description": "StorageSharedKeyCredential can be injected to create the azure client, this holds the important authentication information",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:com.azure.storage.common.StorageSharedKeyCredential"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"bean": {
		"properties": {
			"beanName": {
				"title": "Bean Name",
				"description": "Sets the name of the bean to invoke",
				"type": "string",
				"$comment": "group:common"
			},
			"method": {
				"title": "Method",
				"description": "Sets the name of the method to invoke on the bean",
				"type": "string",
				"$comment": "group:common"
			},
			"scope": {
				"title": "Scope",
				"description": "Scope of bean. When using singleton scope (default) the bean is created or looked up only once and reused for the lifetime of the endpoint. The bean should be thread-safe in case concurrent threads is calling the bean at the same time. When using request scope the bean is created or looked up once per request (exchange). This can be used if you want to store state on a bean while processing a request and you want to call the same bean instance multiple times while processing the request. The bean does not have to be thread-safe as the instance is only called from the same request. When using prototype scope, then the bean will be looked up or created per call. However in case of lookup then this is delegated to the bean registry such as Spring or CDI (if in use), which depends on their configuration can act as either singleton or prototype scope. so when using prototype then this depends on the delegated registry.",
				"type": "string",
				"enum": [
					"Singleton",
					"Request",
					"Prototype"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.BeanScope",
				"default": "Singleton"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"parameters": {
				"title": "Parameters",
				"description": "Used for configuring additional properties on the bean",
				"type": "object",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"beanName"
		]
	},
	"bean-validator": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Where label is an arbitrary text value describing the endpoint",
				"type": "string",
				"$comment": "group:producer"
			},
			"group": {
				"title": "Group",
				"description": "To use a custom validation group",
				"type": "string",
				"$comment": "group:producer",
				"default": "jakarta.validation.groups.Default"
			},
			"ignoreXmlConfiguration": {
				"title": "Ignore Xml Configuration",
				"description": "Whether to ignore data from the META-INF/validation.xml file.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"constraintValidatorFactory": {
				"title": "Constraint Validator Factory",
				"description": "To use a custom ConstraintValidatorFactory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.validation.ConstraintValidatorFactory"
			},
			"messageInterpolator": {
				"title": "Message Interpolator",
				"description": "To use a custom MessageInterpolator",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.validation.MessageInterpolator"
			},
			"traversableResolver": {
				"title": "Traversable Resolver",
				"description": "To use a custom TraversableResolver",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.validation.TraversableResolver"
			},
			"validationProviderResolver": {
				"title": "Validation Provider Resolver",
				"description": "To use a a custom ValidationProviderResolver",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.validation.ValidationProviderResolver"
			},
			"validatorFactory": {
				"title": "Validator Factory",
				"description": "To use a custom ValidatorFactory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.validation.ValidatorFactory"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label"
		]
	},
	"bonita": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "Operation to use",
				"type": "string",
				"enum": [
					"startCase"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.bonita.util.BonitaOperation"
			},
			"hostname": {
				"title": "Hostname",
				"description": "Hostname where Bonita engine runs",
				"type": "string",
				"$comment": "group:producer",
				"default": "localhost"
			},
			"port": {
				"title": "Port",
				"description": "Port of the server hosting Bonita engine",
				"type": "string",
				"$comment": "group:producer",
				"default": "8080"
			},
			"processName": {
				"title": "Process Name",
				"description": "Name of the process involved in the operation",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"password": {
				"title": "Password",
				"description": "Password to authenticate to Bonita engine.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to authenticate to Bonita engine.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation"
		]
	},
	"box": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"COLLABORATIONS",
					"COMMENTS",
					"EVENT_LOGS",
					"FILES",
					"FOLDERS",
					"GROUPS",
					"EVENTS",
					"SEARCH",
					"TASKS",
					"USERS"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.box.internal.BoxApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Box application client ID",
				"type": "string",
				"$comment": "group:common"
			},
			"enterpriseId": {
				"title": "Enterprise Id",
				"description": "The enterprise ID to use for an App Enterprise.",
				"type": "string",
				"$comment": "group:common"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"userId": {
				"title": "User Id",
				"description": "The user ID to use for an App User.",
				"type": "string",
				"$comment": "group:common"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"httpParams": {
				"title": "Http Params",
				"description": "Custom HTTP params for settings like proxy host",
				"type": "object",
				"$comment": "group:advanced"
			},
			"authenticationType": {
				"title": "Authentication Type",
				"description": "The type of authentication for connection. Types of Authentication: STANDARD_AUTHENTICATION - OAuth 2.0 (3-legged) SERVER_AUTHENTICATION - OAuth 2.0 with JSON Web Tokens",
				"type": "string",
				"$comment": "group:authentication",
				"default": "APP_USER_AUTHENTICATION"
			},
			"accessTokenCache": {
				"title": "Access Token Cache",
				"description": "Custom Access Token Cache for storing and retrieving access tokens.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:com.box.sdk.IAccessTokenCache"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Box application client secret",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"encryptionAlgorithm": {
				"title": "Encryption Algorithm",
				"description": "The type of encryption algorithm for JWT. Supported Algorithms: RSA_SHA_256 RSA_SHA_384 RSA_SHA_512",
				"type": "string",
				"enum": [
					"RSA_SHA_256",
					"RSA_SHA_384",
					"RSA_SHA_512"
				],
				"$comment": "group:security",
				"format": "bean:com.box.sdk.EncryptionAlgorithm",
				"default": "RSA_SHA_256"
			},
			"maxCacheEntries": {
				"title": "Max Cache Entries",
				"description": "The maximum number of access tokens in cache.",
				"type": "integer",
				"$comment": "group:security",
				"default": 100
			},
			"privateKeyFile": {
				"title": "Private Key File",
				"description": "The private key for generating the JWT signature.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privateKeyPassword": {
				"title": "Private Key Password",
				"description": "The password for the private key.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"publicKeyId": {
				"title": "Public Key Id",
				"description": "The ID for public key for validating the JWT signature.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"userName": {
				"title": "User Name",
				"description": "Box user name, MUST be provided",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"userPassword": {
				"title": "User Password",
				"description": "Box user password, MUST be provided if authSecureStorage is not set, or returns null on first call",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"braintree": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"ADD_ON",
					"ADDRESS",
					"CLIENT_TOKEN",
					"CREDIT_CARD_VERIFICATION",
					"CUSTOMER",
					"DISCOUNT",
					"DISPUTE",
					"DOCUMENT_UPLOAD",
					"MERCHANT_ACCOUNT",
					"PAYMENT_METHOD",
					"PAYMENT_METHOD_NONCE",
					"OAUTH",
					"PLAN",
					"REPORT",
					"SETTLEMENT_BATCH_SUMMARY",
					"SUBSCRIPTION",
					"TRANSACTION",
					"US_BANK_ACCOUNT",
					"WEBHOOK_NOTIFICATION"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.braintree.internal.BraintreeApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"enum": [
					"accept",
					"addFileEvidence",
					"addTextEvidence",
					"cancel",
					"cancelRelease",
					"cloneTransaction",
					"create",
					"createForCurrency",
					"credit",
					"delete",
					"fetchMerchantAccounts",
					"finalize",
					"find",
					"generate",
					"grant",
					"holdInEscrow",
					"parse",
					"refund",
					"releaseFromEscrow",
					"removeEvidence",
					"retryCharge",
					"revoke",
					"sale",
					"search",
					"submitForPartialSettlement",
					"submitForSettlement",
					"transactionLevelFees",
					"update",
					"updateDetails",
					"verify",
					"voidTransaction"
				],
				"$comment": "group:producer"
			},
			"environment": {
				"title": "Environment",
				"description": "The environment Either SANDBOX or PRODUCTION",
				"type": "string",
				"$comment": "group:producer"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:producer"
			},
			"merchantId": {
				"title": "Merchant Id",
				"description": "The merchant id provided by Braintree.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"httpReadTimeout": {
				"title": "Http Read Timeout",
				"description": "Set read timeout for http calls.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"httpLogLevel": {
				"title": "Http Log Level",
				"description": "Set logging level for http calls, see java.util.logging.Level",
				"type": "string",
				"enum": [
					"OFF",
					"SEVERE",
					"WARNING",
					"INFO",
					"CONFIG",
					"FINE",
					"FINER",
					"FINEST",
					"ALL"
				],
				"$comment": "group:logging"
			},
			"httpLogName": {
				"title": "Http Log Name",
				"description": "Set log category to use to log http calls.",
				"type": "string",
				"$comment": "group:logging",
				"default": "Braintree"
			},
			"logHandlerEnabled": {
				"title": "Log Handler Enabled",
				"description": "Sets whether to enable the BraintreeLogHandler. It may be desirable to set this to 'false' where an existing JUL - SLF4J logger bridge is on the classpath. This option can also be configured globally on the BraintreeComponent.",
				"type": "boolean",
				"$comment": "group:logging",
				"default": true
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "The proxy host",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "The proxy port",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"accessToken": {
				"title": "Access Token",
				"description": "The access token granted by a merchant to another in order to process transactions on their behalf. Used in place of environment, merchant id, public key and private key fields.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privateKey": {
				"title": "Private Key",
				"description": "The private key provided by Braintree.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"publicKey": {
				"title": "Public Key",
				"description": "The public key provided by Braintree.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"browse": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "A name which can be any string to uniquely identify the endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"filter": {
				"title": "Filter",
				"description": "To use a predicate to filter whether to include the message for browsing. Return true to include, false to exclude.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.function.Predicate<org.apache.camel.Exchange>"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"caffeine-cache": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "Cache name",
				"type": "string",
				"$comment": "group:producer"
			},
			"action": {
				"title": "Action",
				"description": "To configure the default cache action. If an action is set in the message header, then the operation from the header takes precedence.",
				"type": "string",
				"enum": [
					"GET",
					"GET_ALL",
					"PUT",
					"PUT_ALL",
					"INVALIDATE",
					"INVALIDATE_ALL",
					"CLEANUP",
					"AS_MAP"
				],
				"$comment": "group:producer"
			},
			"createCacheIfNotExist": {
				"title": "Create Cache If Not Exist",
				"description": "Automatic create the Caffeine cache if none has been configured or exists in the registry.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"evictionType": {
				"title": "Eviction Type",
				"description": "Set the eviction Type for this cache",
				"type": "string",
				"enum": [
					"size_based",
					"time_based"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.caffeine.EvictionType",
				"default": "SIZE_BASED"
			},
			"expireAfterAccessTime": {
				"title": "Expire After Access Time",
				"description": "Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's creation, the most recent replacement of its value, or its last read. Access time is reset by all cache read and write operations. The unit is in seconds.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 300
			},
			"expireAfterWriteTime": {
				"title": "Expire After Write Time",
				"description": "Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's creation, or the most recent replacement of its value. The unit is in seconds.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 300
			},
			"initialCapacity": {
				"title": "Initial Capacity",
				"description": "Sets the minimum total size for the internal data structures. Providing a large enough estimate at construction time avoids the need for expensive resizing operations later, but setting this value unnecessarily high wastes memory.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"key": {
				"title": "Key",
				"description": "To configure the default action key. If a key is set in the message header, then the key from the header takes precedence.",
				"type": "string",
				"$comment": "group:producer"
			},
			"maximumSize": {
				"title": "Maximum Size",
				"description": "Specifies the maximum number of entries the cache may contain. Note that the cache may evict an entry before this limit is exceeded or temporarily exceed the threshold while evicting. As the cache size grows close to the maximum, the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often. When size is zero, elements will be evicted immediately after being loaded into the cache. This can be useful in testing or to disable caching temporarily without a code change. As eviction is scheduled on the configured executor, tests may instead prefer to configure the cache to execute tasks directly on the same thread.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"cacheLoader": {
				"title": "Cache Loader",
				"description": "To configure a CacheLoader in case of a LoadCache use",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.github.benmanes.caffeine.cache.CacheLoader"
			},
			"removalListener": {
				"title": "Removal Listener",
				"description": "Set a specific removal Listener for the cache",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.github.benmanes.caffeine.cache.RemovalListener"
			},
			"statsCounter": {
				"title": "Stats Counter",
				"description": "Set a specific Stats Counter for the cache stats",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.github.benmanes.caffeine.cache.stats.StatsCounter"
			},
			"statsEnabled": {
				"title": "Stats Enabled",
				"description": "To enable stats on the cache",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"valueType": {
				"title": "Value Type",
				"description": "The cache value type, default java.lang.Object",
				"type": "string",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"caffeine-loadcache": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "the cache name",
				"type": "string",
				"$comment": "group:producer"
			},
			"action": {
				"title": "Action",
				"description": "To configure the default cache action. If an action is set in the message header, then the operation from the header takes precedence.",
				"type": "string",
				"enum": [
					"GET",
					"GET_ALL",
					"PUT",
					"PUT_ALL",
					"INVALIDATE",
					"INVALIDATE_ALL",
					"CLEANUP",
					"AS_MAP"
				],
				"$comment": "group:producer"
			},
			"createCacheIfNotExist": {
				"title": "Create Cache If Not Exist",
				"description": "Automatic create the Caffeine cache if none has been configured or exists in the registry.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"evictionType": {
				"title": "Eviction Type",
				"description": "Set the eviction Type for this cache",
				"type": "string",
				"enum": [
					"size_based",
					"time_based"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.caffeine.EvictionType",
				"default": "SIZE_BASED"
			},
			"expireAfterAccessTime": {
				"title": "Expire After Access Time",
				"description": "Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's creation, the most recent replacement of its value, or its last read. Access time is reset by all cache read and write operations. The unit is in seconds.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 300
			},
			"expireAfterWriteTime": {
				"title": "Expire After Write Time",
				"description": "Specifies that each entry should be automatically removed from the cache once a fixed duration has elapsed after the entry's creation, or the most recent replacement of its value. The unit is in seconds.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 300
			},
			"initialCapacity": {
				"title": "Initial Capacity",
				"description": "Sets the minimum total size for the internal data structures. Providing a large enough estimate at construction time avoids the need for expensive resizing operations later, but setting this value unnecessarily high wastes memory.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"key": {
				"title": "Key",
				"description": "To configure the default action key. If a key is set in the message header, then the key from the header takes precedence.",
				"type": "string",
				"$comment": "group:producer"
			},
			"maximumSize": {
				"title": "Maximum Size",
				"description": "Specifies the maximum number of entries the cache may contain. Note that the cache may evict an entry before this limit is exceeded or temporarily exceed the threshold while evicting. As the cache size grows close to the maximum, the cache evicts entries that are less likely to be used again. For example, the cache may evict an entry because it hasn't been used recently or very often. When size is zero, elements will be evicted immediately after being loaded into the cache. This can be useful in testing or to disable caching temporarily without a code change. As eviction is scheduled on the configured executor, tests may instead prefer to configure the cache to execute tasks directly on the same thread.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"cacheLoader": {
				"title": "Cache Loader",
				"description": "To configure a CacheLoader in case of a LoadCache use",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.github.benmanes.caffeine.cache.CacheLoader"
			},
			"removalListener": {
				"title": "Removal Listener",
				"description": "Set a specific removal Listener for the cache",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.github.benmanes.caffeine.cache.RemovalListener"
			},
			"statsCounter": {
				"title": "Stats Counter",
				"description": "Set a specific Stats Counter for the cache stats",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.github.benmanes.caffeine.cache.stats.StatsCounter"
			},
			"statsEnabled": {
				"title": "Stats Enabled",
				"description": "To enable stats on the cache",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"valueType": {
				"title": "Value Type",
				"description": "The cache value type, default java.lang.Object",
				"type": "string",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"chatscript": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname or IP of the server on which CS server is running",
				"type": "string",
				"$comment": "group:producer"
			},
			"port": {
				"title": "Port",
				"description": "Port on which ChatScript is listening to",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1024
			},
			"botName": {
				"title": "Bot Name",
				"description": "Name of the Bot in CS to converse with",
				"type": "string",
				"$comment": "group:producer"
			},
			"chatUserName": {
				"title": "Chat User Name",
				"description": "Username who initializes the CS conversation. To be set when chat is initialized from camel route",
				"type": "string",
				"$comment": "group:producer"
			},
			"resetChat": {
				"title": "Reset Chat",
				"description": "Issues :reset command to start a new conversation everytime",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"botName"
		]
	},
	"chunk": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"encoding": {
				"title": "Encoding",
				"description": "Define the encoding of the body",
				"type": "string",
				"$comment": "group:producer"
			},
			"extension": {
				"title": "Extension",
				"description": "Define the file extension of the template",
				"type": "string",
				"$comment": "group:producer"
			},
			"themeFolder": {
				"title": "Theme Folder",
				"description": "Define the themes folder to scan",
				"type": "string",
				"$comment": "group:producer"
			},
			"themeLayer": {
				"title": "Theme Layer",
				"description": "Define the theme layer to elaborate",
				"type": "string",
				"$comment": "group:producer"
			},
			"themeSubfolder": {
				"title": "Theme Subfolder",
				"description": "Define the themes subfolder to scan",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"class": {
		"properties": {
			"beanName": {
				"title": "Bean Name",
				"description": "Sets the name of the bean to invoke",
				"type": "string",
				"$comment": "group:common"
			},
			"method": {
				"title": "Method",
				"description": "Sets the name of the method to invoke on the bean",
				"type": "string",
				"$comment": "group:common"
			},
			"scope": {
				"title": "Scope",
				"description": "Scope of bean. When using singleton scope (default) the bean is created or looked up only once and reused for the lifetime of the endpoint. The bean should be thread-safe in case concurrent threads is calling the bean at the same time. When using request scope the bean is created or looked up once per request (exchange). This can be used if you want to store state on a bean while processing a request and you want to call the same bean instance multiple times while processing the request. The bean does not have to be thread-safe as the instance is only called from the same request. When using prototype scope, then the bean will be looked up or created per call. However in case of lookup then this is delegated to the bean registry such as Spring or CDI (if in use), which depends on their configuration can act as either singleton or prototype scope. so when using prototype then this depends on the delegated registry.",
				"type": "string",
				"enum": [
					"Singleton",
					"Request",
					"Prototype"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.BeanScope",
				"default": "Singleton"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"parameters": {
				"title": "Parameters",
				"description": "Used for configuring additional properties on the bean",
				"type": "object",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"beanName"
		]
	},
	"clickup": {
		"properties": {
			"workspaceId": {
				"title": "Workspace Id",
				"description": "The WorkspaceID.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"events": {
				"title": "Events",
				"description": "The comma separated list of events to which the webhook must subscribe",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"baseUrl": {
				"title": "Base Url",
				"description": "Can be used to set an alternative base URL, e.g. when you want to test the component against a mock ClickUp API",
				"type": "string",
				"$comment": "group:advanced"
			},
			"authorizationToken": {
				"title": "Authorization Token",
				"description": "The authorization token for authenticating against the ClickUp API.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"webhookSecret": {
				"title": "Webhook Secret",
				"description": "The shared secret obtained in the webhook creation response.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"workspaceId",
			"events"
		]
	},
	"cm-sms": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "SMS Provider HOST with scheme",
				"type": "string",
				"$comment": "group:producer"
			},
			"defaultFrom": {
				"title": "Default From",
				"description": "This is the sender name. The maximum length is 11 characters.",
				"type": "string",
				"$comment": "group:producer"
			},
			"defaultMaxNumberOfParts": {
				"title": "Default Max Number Of Parts",
				"description": "If it is a multipart message forces the max number. Message can be truncated. Technically the gateway will first check if a message is larger than 160 characters, if so, the message will be cut into multiple 153 characters parts limited by these parameters.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 8
			},
			"productToken": {
				"title": "Product Token",
				"description": "The unique token to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "Whether to test the connection to the SMS Gateway on startup",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"defaultFrom",
			"productToken"
		]
	},
	"coap": {
		"properties": {
			"uri": {
				"title": "Uri",
				"description": "The URI for the CoAP endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"coapMethodRestrict": {
				"title": "Coap Method Restrict",
				"description": "Comma separated list of methods that the CoAP consumer will bind to. The default is to bind to all methods (DELETE, GET, POST, PUT).",
				"type": "string",
				"enum": [
					"DELETE",
					"GET",
					"POST",
					"PUT"
				],
				"$comment": "group:consumer"
			},
			"observable": {
				"title": "Observable",
				"description": "Make CoAP resource observable for source endpoint, based on RFC 7641.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"observe": {
				"title": "Observe",
				"description": "Send an observe request from a source endpoint, based on RFC 7641.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"notify": {
				"title": "Notify",
				"description": "Notify observers that the resource of this URI has changed, based on RFC 7641. Use this flag on a destination endpoint, with a URI that matches an existing source endpoint URI.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"advancedCertificateVerifier": {
				"title": "Advanced Certificate Verifier",
				"description": "Set the AdvancedCertificateVerifier to use to determine trust in raw public keys.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.scandium.dtls.x509.NewAdvancedCertificateVerifier"
			},
			"advancedPskStore": {
				"title": "Advanced Psk Store",
				"description": "Set the AdvancedPskStore to use for pre-shared key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.scandium.dtls.pskstore.AdvancedPskStore"
			},
			"alias": {
				"title": "Alias",
				"description": "Sets the alias used to query the KeyStore for the private key and certificate. This parameter is used when we are enabling TLS with certificates on the service side, and similarly on the client side when TLS is used with certificates and client authentication. If the parameter is not specified then the default behavior is to use the first alias in the keystore that contains a key entry. This configuration parameter does not apply to configuring TLS via a Raw Public Key or a Pre-Shared Key.",
				"type": "string",
				"enum": [
					"NONE",
					"WANT",
					"REQUIRE"
				],
				"$comment": "group:security"
			},
			"cipherSuites": {
				"title": "Cipher Suites",
				"description": "Sets the cipherSuites String. This is a comma separated String of ciphersuites to configure. If it is not specified, then it falls back to getting the ciphersuites from the sslContextParameters object.",
				"type": "string",
				"$comment": "group:security"
			},
			"clientAuthentication": {
				"title": "Client Authentication",
				"description": "Sets the configuration options for server-side client-authentication requirements. The value must be one of NONE, WANT, REQUIRE. If this value is not specified, then it falls back to checking the sslContextParameters.getServerParameters().getClientAuthentication() value.",
				"type": "string",
				"enum": [
					"NONE",
					"WANTED",
					"NEEDED"
				],
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.elements.config.CertificateAuthenticationMode"
			},
			"privateKey": {
				"title": "Private Key",
				"description": "Set the configured private key for use with Raw Public Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PrivateKey|password"
			},
			"publicKey": {
				"title": "Public Key",
				"description": "Set the configured public key for use with Raw Public Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PublicKey"
			},
			"recommendedCipherSuitesOnly": {
				"title": "Recommended Cipher Suites Only",
				"description": "The CBC cipher suites are not recommended. If you want to use them, you first need to set the recommendedCipherSuitesOnly option to false.",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "Set the SSLContextParameters object for setting up TLS. This is required for coapstcp, and for coaps when we are using certificates for TLS (as opposed to RPK or PKS).",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"coap+tcp": {
		"properties": {
			"uri": {
				"title": "Uri",
				"description": "The URI for the CoAP endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"coapMethodRestrict": {
				"title": "Coap Method Restrict",
				"description": "Comma separated list of methods that the CoAP consumer will bind to. The default is to bind to all methods (DELETE, GET, POST, PUT).",
				"type": "string",
				"enum": [
					"DELETE",
					"GET",
					"POST",
					"PUT"
				],
				"$comment": "group:consumer"
			},
			"observable": {
				"title": "Observable",
				"description": "Make CoAP resource observable for source endpoint, based on RFC 7641.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"observe": {
				"title": "Observe",
				"description": "Send an observe request from a source endpoint, based on RFC 7641.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"notify": {
				"title": "Notify",
				"description": "Notify observers that the resource of this URI has changed, based on RFC 7641. Use this flag on a destination endpoint, with a URI that matches an existing source endpoint URI.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"advancedCertificateVerifier": {
				"title": "Advanced Certificate Verifier",
				"description": "Set the AdvancedCertificateVerifier to use to determine trust in raw public keys.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.scandium.dtls.x509.NewAdvancedCertificateVerifier"
			},
			"advancedPskStore": {
				"title": "Advanced Psk Store",
				"description": "Set the AdvancedPskStore to use for pre-shared key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.scandium.dtls.pskstore.AdvancedPskStore"
			},
			"alias": {
				"title": "Alias",
				"description": "Sets the alias used to query the KeyStore for the private key and certificate. This parameter is used when we are enabling TLS with certificates on the service side, and similarly on the client side when TLS is used with certificates and client authentication. If the parameter is not specified then the default behavior is to use the first alias in the keystore that contains a key entry. This configuration parameter does not apply to configuring TLS via a Raw Public Key or a Pre-Shared Key.",
				"type": "string",
				"enum": [
					"NONE",
					"WANT",
					"REQUIRE"
				],
				"$comment": "group:security"
			},
			"cipherSuites": {
				"title": "Cipher Suites",
				"description": "Sets the cipherSuites String. This is a comma separated String of ciphersuites to configure. If it is not specified, then it falls back to getting the ciphersuites from the sslContextParameters object.",
				"type": "string",
				"$comment": "group:security"
			},
			"clientAuthentication": {
				"title": "Client Authentication",
				"description": "Sets the configuration options for server-side client-authentication requirements. The value must be one of NONE, WANT, REQUIRE. If this value is not specified, then it falls back to checking the sslContextParameters.getServerParameters().getClientAuthentication() value.",
				"type": "string",
				"enum": [
					"NONE",
					"WANTED",
					"NEEDED"
				],
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.elements.config.CertificateAuthenticationMode"
			},
			"privateKey": {
				"title": "Private Key",
				"description": "Set the configured private key for use with Raw Public Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PrivateKey|password"
			},
			"publicKey": {
				"title": "Public Key",
				"description": "Set the configured public key for use with Raw Public Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PublicKey"
			},
			"recommendedCipherSuitesOnly": {
				"title": "Recommended Cipher Suites Only",
				"description": "The CBC cipher suites are not recommended. If you want to use them, you first need to set the recommendedCipherSuitesOnly option to false.",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "Set the SSLContextParameters object for setting up TLS. This is required for coapstcp, and for coaps when we are using certificates for TLS (as opposed to RPK or PKS).",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"coaps": {
		"properties": {
			"uri": {
				"title": "Uri",
				"description": "The URI for the CoAP endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"coapMethodRestrict": {
				"title": "Coap Method Restrict",
				"description": "Comma separated list of methods that the CoAP consumer will bind to. The default is to bind to all methods (DELETE, GET, POST, PUT).",
				"type": "string",
				"enum": [
					"DELETE",
					"GET",
					"POST",
					"PUT"
				],
				"$comment": "group:consumer"
			},
			"observable": {
				"title": "Observable",
				"description": "Make CoAP resource observable for source endpoint, based on RFC 7641.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"observe": {
				"title": "Observe",
				"description": "Send an observe request from a source endpoint, based on RFC 7641.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"notify": {
				"title": "Notify",
				"description": "Notify observers that the resource of this URI has changed, based on RFC 7641. Use this flag on a destination endpoint, with a URI that matches an existing source endpoint URI.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"advancedCertificateVerifier": {
				"title": "Advanced Certificate Verifier",
				"description": "Set the AdvancedCertificateVerifier to use to determine trust in raw public keys.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.scandium.dtls.x509.NewAdvancedCertificateVerifier"
			},
			"advancedPskStore": {
				"title": "Advanced Psk Store",
				"description": "Set the AdvancedPskStore to use for pre-shared key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.scandium.dtls.pskstore.AdvancedPskStore"
			},
			"alias": {
				"title": "Alias",
				"description": "Sets the alias used to query the KeyStore for the private key and certificate. This parameter is used when we are enabling TLS with certificates on the service side, and similarly on the client side when TLS is used with certificates and client authentication. If the parameter is not specified then the default behavior is to use the first alias in the keystore that contains a key entry. This configuration parameter does not apply to configuring TLS via a Raw Public Key or a Pre-Shared Key.",
				"type": "string",
				"enum": [
					"NONE",
					"WANT",
					"REQUIRE"
				],
				"$comment": "group:security"
			},
			"cipherSuites": {
				"title": "Cipher Suites",
				"description": "Sets the cipherSuites String. This is a comma separated String of ciphersuites to configure. If it is not specified, then it falls back to getting the ciphersuites from the sslContextParameters object.",
				"type": "string",
				"$comment": "group:security"
			},
			"clientAuthentication": {
				"title": "Client Authentication",
				"description": "Sets the configuration options for server-side client-authentication requirements. The value must be one of NONE, WANT, REQUIRE. If this value is not specified, then it falls back to checking the sslContextParameters.getServerParameters().getClientAuthentication() value.",
				"type": "string",
				"enum": [
					"NONE",
					"WANTED",
					"NEEDED"
				],
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.elements.config.CertificateAuthenticationMode"
			},
			"privateKey": {
				"title": "Private Key",
				"description": "Set the configured private key for use with Raw Public Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PrivateKey|password"
			},
			"publicKey": {
				"title": "Public Key",
				"description": "Set the configured public key for use with Raw Public Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PublicKey"
			},
			"recommendedCipherSuitesOnly": {
				"title": "Recommended Cipher Suites Only",
				"description": "The CBC cipher suites are not recommended. If you want to use them, you first need to set the recommendedCipherSuitesOnly option to false.",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "Set the SSLContextParameters object for setting up TLS. This is required for coapstcp, and for coaps when we are using certificates for TLS (as opposed to RPK or PKS).",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"coaps+tcp": {
		"properties": {
			"uri": {
				"title": "Uri",
				"description": "The URI for the CoAP endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"coapMethodRestrict": {
				"title": "Coap Method Restrict",
				"description": "Comma separated list of methods that the CoAP consumer will bind to. The default is to bind to all methods (DELETE, GET, POST, PUT).",
				"type": "string",
				"enum": [
					"DELETE",
					"GET",
					"POST",
					"PUT"
				],
				"$comment": "group:consumer"
			},
			"observable": {
				"title": "Observable",
				"description": "Make CoAP resource observable for source endpoint, based on RFC 7641.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"observe": {
				"title": "Observe",
				"description": "Send an observe request from a source endpoint, based on RFC 7641.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"notify": {
				"title": "Notify",
				"description": "Notify observers that the resource of this URI has changed, based on RFC 7641. Use this flag on a destination endpoint, with a URI that matches an existing source endpoint URI.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"advancedCertificateVerifier": {
				"title": "Advanced Certificate Verifier",
				"description": "Set the AdvancedCertificateVerifier to use to determine trust in raw public keys.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.scandium.dtls.x509.NewAdvancedCertificateVerifier"
			},
			"advancedPskStore": {
				"title": "Advanced Psk Store",
				"description": "Set the AdvancedPskStore to use for pre-shared key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.scandium.dtls.pskstore.AdvancedPskStore"
			},
			"alias": {
				"title": "Alias",
				"description": "Sets the alias used to query the KeyStore for the private key and certificate. This parameter is used when we are enabling TLS with certificates on the service side, and similarly on the client side when TLS is used with certificates and client authentication. If the parameter is not specified then the default behavior is to use the first alias in the keystore that contains a key entry. This configuration parameter does not apply to configuring TLS via a Raw Public Key or a Pre-Shared Key.",
				"type": "string",
				"enum": [
					"NONE",
					"WANT",
					"REQUIRE"
				],
				"$comment": "group:security"
			},
			"cipherSuites": {
				"title": "Cipher Suites",
				"description": "Sets the cipherSuites String. This is a comma separated String of ciphersuites to configure. If it is not specified, then it falls back to getting the ciphersuites from the sslContextParameters object.",
				"type": "string",
				"$comment": "group:security"
			},
			"clientAuthentication": {
				"title": "Client Authentication",
				"description": "Sets the configuration options for server-side client-authentication requirements. The value must be one of NONE, WANT, REQUIRE. If this value is not specified, then it falls back to checking the sslContextParameters.getServerParameters().getClientAuthentication() value.",
				"type": "string",
				"enum": [
					"NONE",
					"WANTED",
					"NEEDED"
				],
				"$comment": "group:security",
				"format": "bean:org.eclipse.californium.elements.config.CertificateAuthenticationMode"
			},
			"privateKey": {
				"title": "Private Key",
				"description": "Set the configured private key for use with Raw Public Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PrivateKey|password"
			},
			"publicKey": {
				"title": "Public Key",
				"description": "Set the configured public key for use with Raw Public Key.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.PublicKey"
			},
			"recommendedCipherSuitesOnly": {
				"title": "Recommended Cipher Suites Only",
				"description": "The CBC cipher suites are not recommended. If you want to use them, you first need to set the recommendedCipherSuitesOnly option to false.",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "Set the SSLContextParameters object for setting up TLS. This is required for coapstcp, and for coaps when we are using certificates for TLS (as opposed to RPK or PKS).",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"cometd": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Host port number",
				"type": "integer",
				"$comment": "group:common"
			},
			"channelName": {
				"title": "Channel Name",
				"description": "The channelName represents a topic that can be subscribed to by the Camel endpoints.",
				"type": "string",
				"$comment": "group:common"
			},
			"allowedOrigins": {
				"title": "Allowed Origins",
				"description": "The origins domain that support to cross, if the crosssOriginFilterOn is true",
				"type": "string",
				"$comment": "group:common",
				"default": "*"
			},
			"baseResource": {
				"title": "Base Resource",
				"description": "The root directory for the web resources or classpath. Use the protocol file: or classpath: depending if you want that the component loads the resource from file system or classpath. Classpath is required for OSGI deployment where the resources are packaged in the jar",
				"type": "string",
				"$comment": "group:common"
			},
			"crossOriginFilterOn": {
				"title": "Cross Origin Filter On",
				"description": "If true, the server will support for cross-domain filtering",
				"type": "boolean",
				"$comment": "group:common"
			},
			"filterPath": {
				"title": "Filter Path",
				"description": "The filterPath will be used by the CrossOriginFilter, if the crosssOriginFilterOn is true",
				"type": "string",
				"$comment": "group:common"
			},
			"interval": {
				"title": "Interval",
				"description": "The client side poll timeout in milliseconds. How long a client will wait between reconnects",
				"type": "integer",
				"$comment": "group:common"
			},
			"jsonCommented": {
				"title": "Json Commented",
				"description": "If true, the server will accept JSON wrapped in a comment and will generate JSON wrapped in a comment. This is a defence against Ajax Hijacking.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"logLevel": {
				"title": "Log Level",
				"description": "Logging level. 0=none, 1=info, 2=debug.",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2"
				],
				"$comment": "group:common",
				"default": 1
			},
			"maxInterval": {
				"title": "Max Interval",
				"description": "The max client side poll timeout in milliseconds. A client will be removed if a connection is not received in this time.",
				"type": "integer",
				"$comment": "group:common",
				"default": 30000
			},
			"multiFrameInterval": {
				"title": "Multi Frame Interval",
				"description": "The client side poll timeout, if multiple connections are detected from the same browser.",
				"type": "integer",
				"$comment": "group:common",
				"default": 1500
			},
			"timeout": {
				"title": "Timeout",
				"description": "The server side poll timeout in milliseconds. This is how long the server will hold a reconnect request before responding.",
				"type": "integer",
				"$comment": "group:common",
				"default": 240000
			},
			"sessionHeadersEnabled": {
				"title": "Session Headers Enabled",
				"description": "Whether to include the server session headers in the Camel message when creating a Camel Message for incoming requests.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"disconnectLocalSession": {
				"title": "Disconnect Local Session",
				"description": "Whether to disconnect local sessions after publishing a message to its channel. Disconnecting local session is needed as they are not swept by default by CometD, and therefore you can run out of memory.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"port",
			"channelName"
		]
	},
	"cometds": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Host port number",
				"type": "integer",
				"$comment": "group:common"
			},
			"channelName": {
				"title": "Channel Name",
				"description": "The channelName represents a topic that can be subscribed to by the Camel endpoints.",
				"type": "string",
				"$comment": "group:common"
			},
			"allowedOrigins": {
				"title": "Allowed Origins",
				"description": "The origins domain that support to cross, if the crosssOriginFilterOn is true",
				"type": "string",
				"$comment": "group:common",
				"default": "*"
			},
			"baseResource": {
				"title": "Base Resource",
				"description": "The root directory for the web resources or classpath. Use the protocol file: or classpath: depending if you want that the component loads the resource from file system or classpath. Classpath is required for OSGI deployment where the resources are packaged in the jar",
				"type": "string",
				"$comment": "group:common"
			},
			"crossOriginFilterOn": {
				"title": "Cross Origin Filter On",
				"description": "If true, the server will support for cross-domain filtering",
				"type": "boolean",
				"$comment": "group:common"
			},
			"filterPath": {
				"title": "Filter Path",
				"description": "The filterPath will be used by the CrossOriginFilter, if the crosssOriginFilterOn is true",
				"type": "string",
				"$comment": "group:common"
			},
			"interval": {
				"title": "Interval",
				"description": "The client side poll timeout in milliseconds. How long a client will wait between reconnects",
				"type": "integer",
				"$comment": "group:common"
			},
			"jsonCommented": {
				"title": "Json Commented",
				"description": "If true, the server will accept JSON wrapped in a comment and will generate JSON wrapped in a comment. This is a defence against Ajax Hijacking.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"logLevel": {
				"title": "Log Level",
				"description": "Logging level. 0=none, 1=info, 2=debug.",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2"
				],
				"$comment": "group:common",
				"default": 1
			},
			"maxInterval": {
				"title": "Max Interval",
				"description": "The max client side poll timeout in milliseconds. A client will be removed if a connection is not received in this time.",
				"type": "integer",
				"$comment": "group:common",
				"default": 30000
			},
			"multiFrameInterval": {
				"title": "Multi Frame Interval",
				"description": "The client side poll timeout, if multiple connections are detected from the same browser.",
				"type": "integer",
				"$comment": "group:common",
				"default": 1500
			},
			"timeout": {
				"title": "Timeout",
				"description": "The server side poll timeout in milliseconds. This is how long the server will hold a reconnect request before responding.",
				"type": "integer",
				"$comment": "group:common",
				"default": 240000
			},
			"sessionHeadersEnabled": {
				"title": "Session Headers Enabled",
				"description": "Whether to include the server session headers in the Camel message when creating a Camel Message for incoming requests.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"disconnectLocalSession": {
				"title": "Disconnect Local Session",
				"description": "Whether to disconnect local sessions after publishing a message to its channel. Disconnecting local session is needed as they are not swept by default by CometD, and therefore you can run out of memory.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"port",
			"channelName"
		]
	},
	"consul": {
		"properties": {
			"apiEndpoint": {
				"title": "Api Endpoint",
				"description": "The API endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Connect timeout for OkHttpClient",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.time.Duration"
			},
			"consulClient": {
				"title": "Consul Client",
				"description": "Reference to a org.kiwiproject.consul.Consul in the registry.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.kiwiproject.consul.Consul"
			},
			"key": {
				"title": "Key",
				"description": "The default key. Can be overridden by CamelConsulKey",
				"type": "string",
				"$comment": "group:common"
			},
			"pingInstance": {
				"title": "Ping Instance",
				"description": "Configure if the AgentClient should attempt a ping before returning the Consul instance",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"readTimeout": {
				"title": "Read Timeout",
				"description": "Read timeout for OkHttpClient",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.time.Duration"
			},
			"tags": {
				"title": "Tags",
				"description": "Set tags. You can separate multiple tags by comma.",
				"type": "string",
				"$comment": "group:common"
			},
			"url": {
				"title": "Url",
				"description": "The Consul agent URL",
				"type": "string",
				"$comment": "group:common"
			},
			"writeTimeout": {
				"title": "Write Timeout",
				"description": "Write timeout for OkHttpClient",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.time.Duration"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"action": {
				"title": "Action",
				"description": "The default action. Can be overridden by CamelConsulAction",
				"type": "string",
				"$comment": "group:producer"
			},
			"valueAsString": {
				"title": "Value As String",
				"description": "Default to transform values retrieved from Consul i.e. on KV endpoint to string.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"consistencyMode": {
				"title": "Consistency Mode",
				"description": "The consistencyMode used for queries, default ConsistencyMode.DEFAULT",
				"type": "string",
				"enum": [
					"DEFAULT",
					"STALE",
					"CONSISTENT"
				],
				"$comment": "group:advanced",
				"format": "bean:org.kiwiproject.consul.option.ConsistencyMode",
				"default": "DEFAULT"
			},
			"datacenter": {
				"title": "Datacenter",
				"description": "The data center",
				"type": "string",
				"$comment": "group:advanced"
			},
			"nearNode": {
				"title": "Near Node",
				"description": "The near node to use for queries.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"nodeMeta": {
				"title": "Node Meta",
				"description": "The note meta-data to use for queries.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:advanced"
			},
			"aclToken": {
				"title": "Acl Token",
				"description": "Sets the ACL token to be used with Consul",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Sets the password to be used for basic authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "SSL configuration using an org.apache.camel.support.jsse.SSLContextParameters instance.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"userName": {
				"title": "User Name",
				"description": "Sets the username to be used for basic authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"blockSeconds": {
				"title": "Block Seconds",
				"description": "The second to wait for a watch event, default 10 seconds",
				"type": "integer",
				"$comment": "group:watch",
				"default": "10"
			},
			"firstIndex": {
				"title": "First Index",
				"description": "The first index for watch for, default 0",
				"type": "string",
				"$comment": "group:watch",
				"format": "bean:java.math.BigInteger",
				"default": "0"
			},
			"recursive": {
				"title": "Recursive",
				"description": "Recursively watch, default false",
				"type": "boolean",
				"$comment": "group:watch"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiEndpoint"
		]
	},
	"controlbus": {
		"properties": {
			"command": {
				"title": "Command",
				"description": "Command can be either route or language",
				"type": "string",
				"enum": [
					"route",
					"language"
				],
				"$comment": "group:producer"
			},
			"language": {
				"title": "Language",
				"description": "Allows you to specify the name of a Language to use for evaluating the message body. If there is any result from the evaluation, then the result is put in the message body.",
				"type": "string",
				"enum": [
					"bean",
					"constant",
					"csimple",
					"datasonnet",
					"exchangeProperty",
					"file",
					"groovy",
					"header",
					"hl7terser",
					"java",
					"joor",
					"jq",
					"jsonpath",
					"mvel",
					"ognl",
					"python",
					"ref",
					"simple",
					"spel",
					"tokenize",
					"xpath",
					"xquery",
					"xtokenize"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.spi.Language"
			},
			"action": {
				"title": "Action",
				"description": "To denote an action that can be either: start, stop, or status. To either start or stop a route, or to get the status of the route as output in the message body. You can use suspend and resume to either suspend or resume a route. You can use stats to get performance statics returned in XML format; the routeId option can be used to define which route to get the performance stats for, if routeId is not defined, then you get statistics for the entire CamelContext. The restart action will restart the route. And the fail action will stop and mark the route as failed (stopped due to an exception)",
				"type": "string",
				"enum": [
					"start",
					"stop",
					"fail",
					"suspend",
					"resume",
					"restart",
					"status",
					"stats"
				],
				"$comment": "group:producer"
			},
			"async": {
				"title": "Async",
				"description": "Whether to execute the control bus task asynchronously. Important: If this option is enabled, then any result from the task is not set on the Exchange. This is only possible if executing tasks synchronously.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"loggingLevel": {
				"title": "Logging Level",
				"description": "Logging level used for logging when task is done, or if any exceptions occurred during processing the task.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "INFO"
			},
			"restartDelay": {
				"title": "Restart Delay",
				"description": "The delay in millis to use when restarting a route.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1000
			},
			"routeId": {
				"title": "Route Id",
				"description": "To specify a route by its id. The special keyword current indicates the current route.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"command"
		]
	},
	"couchbase": {
		"properties": {
			"protocol": {
				"title": "Protocol",
				"description": "The protocol to use",
				"type": "string",
				"$comment": "group:common"
			},
			"hostname": {
				"title": "Hostname",
				"description": "The hostname to use",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The port number to use",
				"type": "integer",
				"$comment": "group:common",
				"default": 8091
			},
			"bucket": {
				"title": "Bucket",
				"description": "The bucket to use",
				"type": "string",
				"$comment": "group:common"
			},
			"collection": {
				"title": "Collection",
				"description": "The collection to use",
				"type": "string",
				"$comment": "group:common"
			},
			"key": {
				"title": "Key",
				"description": "The key to use",
				"type": "string",
				"$comment": "group:common"
			},
			"scope": {
				"title": "Scope",
				"description": "The scope to use",
				"type": "string",
				"$comment": "group:common"
			},
			"consumerProcessedStrategy": {
				"title": "Consumer Processed Strategy",
				"description": "Define the consumer Processed strategy to use",
				"type": "string",
				"$comment": "group:consumer",
				"default": "none"
			},
			"descending": {
				"title": "Descending",
				"description": "Define if this operation is descending or not",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"designDocumentName": {
				"title": "Design Document Name",
				"description": "The design document name to use",
				"type": "string",
				"$comment": "group:consumer",
				"default": "beer"
			},
			"fullDocument": {
				"title": "Full Document",
				"description": "If true consumer will return complete document instead data defined in view",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"limit": {
				"title": "Limit",
				"description": "The output limit to use",
				"type": "integer",
				"$comment": "group:consumer",
				"default": -1
			},
			"rangeEndKey": {
				"title": "Range End Key",
				"description": "Define a range for the end key",
				"type": "string",
				"$comment": "group:consumer"
			},
			"rangeStartKey": {
				"title": "Range Start Key",
				"description": "Define a range for the start key",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"skip": {
				"title": "Skip",
				"description": "Define the skip to use",
				"type": "integer",
				"$comment": "group:consumer",
				"default": -1
			},
			"viewName": {
				"title": "View Name",
				"description": "The view name to use",
				"type": "string",
				"$comment": "group:consumer",
				"default": "brewery_beers"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"autoStartIdForInserts": {
				"title": "Auto Start Id For Inserts",
				"description": "Define if we want an autostart Id when we are doing an insert operation",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do",
				"type": "string",
				"$comment": "group:producer",
				"default": "CCB_PUT"
			},
			"persistTo": {
				"title": "Persist To",
				"description": "Where to persist the data",
				"type": "integer",
				"$comment": "group:producer",
				"default": 0
			},
			"producerRetryAttempts": {
				"title": "Producer Retry Attempts",
				"description": "Define the number of retry attempts",
				"type": "integer",
				"$comment": "group:producer",
				"default": 2
			},
			"producerRetryPause": {
				"title": "Producer Retry Pause",
				"description": "Define the retry pause between different attempts",
				"type": "integer",
				"$comment": "group:producer",
				"default": 5000
			},
			"replicateTo": {
				"title": "Replicate To",
				"description": "Where to replicate the data",
				"type": "integer",
				"$comment": "group:producer",
				"default": 0
			},
			"startingIdForInsertsFrom": {
				"title": "Starting Id For Inserts From",
				"description": "Define the starting Id where we are doing an insert operation",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"additionalHosts": {
				"title": "Additional Hosts",
				"description": "The additional hosts",
				"type": "string",
				"$comment": "group:advanced"
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Define the timeoutconnect in milliseconds",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "30000"
			},
			"queryTimeout": {
				"title": "Query Timeout",
				"description": "Define the operation timeout in milliseconds",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "2500"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "The password to use",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "The username to use",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"protocol",
			"hostname",
			"bucket"
		]
	},
	"couchdb": {
		"properties": {
			"protocol": {
				"title": "Protocol",
				"description": "The protocol to use for communicating with the database.",
				"type": "string",
				"enum": [
					"http",
					"https"
				],
				"$comment": "group:common"
			},
			"hostname": {
				"title": "Hostname",
				"description": "Hostname of the running couchdb instance",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port number for the running couchdb instance",
				"type": "integer",
				"$comment": "group:common",
				"default": 5984
			},
			"database": {
				"title": "Database",
				"description": "Name of the database to use",
				"type": "string",
				"$comment": "group:common"
			},
			"createDatabase": {
				"title": "Create Database",
				"description": "Creates the database if it does not already exist",
				"type": "boolean",
				"$comment": "group:common"
			},
			"deletes": {
				"title": "Deletes",
				"description": "Document deletes are published as events",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"heartbeat": {
				"title": "Heartbeat",
				"description": "How often to send an empty message to keep socket alive in millis",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "30000"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"style": {
				"title": "Style",
				"description": "Specifies how many revisions are returned in the changes array. The default, main_only, will only return the current winning revision; all_docs will return all leaf revisions (including conflicts and deleted former conflicts.)",
				"type": "string",
				"enum": [
					"all_docs",
					"main_only"
				],
				"$comment": "group:consumer",
				"default": "main_only"
			},
			"updates": {
				"title": "Updates",
				"description": "Document inserts/updates are published as events",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"password": {
				"title": "Password",
				"description": "Password for authenticated databases",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username in case of authenticated databases",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"protocol",
			"hostname",
			"database"
		]
	},
	"cql": {
		"properties": {
			"beanRef": {
				"title": "Bean Ref",
				"description": "beanRef is defined using bean:id",
				"type": "string",
				"$comment": "group:common"
			},
			"hosts": {
				"title": "Hosts",
				"description": "Hostname(s) Cassandra server(s). Multiple hosts can be separated by comma.",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port number of Cassandra server(s)",
				"type": "integer",
				"$comment": "group:common"
			},
			"keyspace": {
				"title": "Keyspace",
				"description": "Keyspace to use",
				"type": "string",
				"$comment": "group:common"
			},
			"clusterName": {
				"title": "Cluster Name",
				"description": "Cluster name",
				"type": "string",
				"$comment": "group:common"
			},
			"cql": {
				"title": "Cql",
				"description": "CQL query to perform. Can be overridden with the message header with key CamelCqlQuery.",
				"type": "string",
				"$comment": "group:common"
			},
			"datacenter": {
				"title": "Datacenter",
				"description": "Datacenter to use",
				"type": "string",
				"$comment": "group:common",
				"default": "datacenter1"
			},
			"prepareStatements": {
				"title": "Prepare Statements",
				"description": "Whether to use PreparedStatements or regular Statements",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"extraTypeCodecs": {
				"title": "Extra Type Codecs",
				"description": "To use a specific comma separated list of Extra Type codecs. Possible values are: BLOB_TO_ARRAY, BOOLEAN_LIST_TO_ARRAY, BYTE_LIST_TO_ARRAY, SHORT_LIST_TO_ARRAY, INT_LIST_TO_ARRAY, LONG_LIST_TO_ARRAY, FLOAT_LIST_TO_ARRAY, DOUBLE_LIST_TO_ARRAY, TIMESTAMP_UTC, TIMESTAMP_MILLIS_SYSTEM, TIMESTAMP_MILLIS_UTC, ZONED_TIMESTAMP_SYSTEM, ZONED_TIMESTAMP_UTC, ZONED_TIMESTAMP_PERSISTED, LOCAL_TIMESTAMP_SYSTEM and LOCAL_TIMESTAMP_UTC",
				"type": "string",
				"$comment": "group:advanced"
			},
			"loadBalancingPolicyClass": {
				"title": "Load Balancing Policy Class",
				"description": "To use a specific LoadBalancingPolicyClass",
				"type": "string",
				"$comment": "group:advanced"
			},
			"resultSetConversionStrategy": {
				"title": "Result Set Conversion Strategy",
				"description": "To use a custom class that implements logic for converting ResultSet into message body ALL, ONE, LIMIT_10, LIMIT_100...",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.cassandra.ResultSetConversionStrategy"
			},
			"session": {
				"title": "Session",
				"description": "To use the Session instance (you would normally not use this option)",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.datastax.oss.driver.api.core.CqlSession"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password for session authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username for session authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"cron": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The name of the cron trigger",
				"type": "string",
				"$comment": "group:consumer"
			},
			"schedule": {
				"title": "Schedule",
				"description": "A cron expression that will be used to generate events",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"schedule"
		]
	},
	"crypto": {
		"properties": {
			"cryptoOperation": {
				"title": "Crypto Operation",
				"description": "Set the Crypto operation from that supplied after the crypto scheme in the endpoint uri e.g. crypto:sign sets sign as the operation.",
				"type": "string",
				"enum": [
					"sign",
					"verify"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.crypto.CryptoOperation"
			},
			"name": {
				"title": "Name",
				"description": "The logical name of this operation.",
				"type": "string",
				"$comment": "group:producer"
			},
			"algorithm": {
				"title": "Algorithm",
				"description": "Sets the JCE name of the Algorithm that should be used for the signer.",
				"type": "string",
				"$comment": "group:producer",
				"default": "SHA256withRSA"
			},
			"alias": {
				"title": "Alias",
				"description": "Sets the alias used to query the KeyStore for keys and {link java.security.cert.Certificate Certificates} to be used in signing and verifying exchanges. This value can be provided at runtime via the message header org.apache.camel.component.crypto.DigitalSignatureConstants#KEYSTORE_ALIAS",
				"type": "string",
				"$comment": "group:producer"
			},
			"certificateName": {
				"title": "Certificate Name",
				"description": "Sets the reference name for a PrivateKey that can be found in the registry.",
				"type": "string",
				"$comment": "group:producer"
			},
			"keystore": {
				"title": "Keystore",
				"description": "Sets the KeyStore that can contain keys and Certficates for use in signing and verifying exchanges. A KeyStore is typically used with an alias, either one supplied in the Route definition or dynamically via the message header CamelSignatureKeyStoreAlias. If no alias is supplied and there is only a single entry in the Keystore, then this single entry will be used.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.security.KeyStore"
			},
			"keystoreName": {
				"title": "Keystore Name",
				"description": "Sets the reference name for a Keystore that can be found in the registry.",
				"type": "string",
				"$comment": "group:producer"
			},
			"privateKey": {
				"title": "Private Key",
				"description": "Set the PrivateKey that should be used to sign the exchange",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.security.PrivateKey|password"
			},
			"privateKeyName": {
				"title": "Private Key Name",
				"description": "Sets the reference name for a PrivateKey that can be found in the registry.",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"provider": {
				"title": "Provider",
				"description": "Set the id of the security provider that provides the configured Signature algorithm.",
				"type": "string",
				"$comment": "group:producer"
			},
			"publicKeyName": {
				"title": "Public Key Name",
				"description": "references that should be resolved when the context changes",
				"type": "string",
				"$comment": "group:producer"
			},
			"secureRandomName": {
				"title": "Secure Random Name",
				"description": "Sets the reference name for a SecureRandom that can be found in the registry.",
				"type": "string",
				"$comment": "group:producer"
			},
			"signatureHeaderName": {
				"title": "Signature Header Name",
				"description": "Set the name of the message header that should be used to store the base64 encoded signature. This defaults to 'CamelDigitalSignature'",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"bufferSize": {
				"title": "Buffer Size",
				"description": "Set the size of the buffer used to read in the Exchange payload data.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "2048"
			},
			"certificate": {
				"title": "Certificate",
				"description": "Set the Certificate that should be used to verify the signature in the exchange based on its payload.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.security.cert.Certificate"
			},
			"clearHeaders": {
				"title": "Clear Headers",
				"description": "Determines if the Signature specific headers be cleared after signing and verification. Defaults to true, and should only be made otherwise at your extreme peril as vital private information such as Keys and passwords may escape if unset.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"keyStoreParameters": {
				"title": "Key Store Parameters",
				"description": "Sets the KeyStore that can contain keys and Certficates for use in signing and verifying exchanges based on the given KeyStoreParameters. A KeyStore is typically used with an alias, either one supplied in the Route definition or dynamically via the message header CamelSignatureKeyStoreAlias. If no alias is supplied and there is only a single entry in the Keystore, then this single entry will be used.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.support.jsse.KeyStoreParameters"
			},
			"publicKey": {
				"title": "Public Key",
				"description": "Set the PublicKey that should be used to verify the signature in the exchange.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.security.PublicKey"
			},
			"secureRandom": {
				"title": "Secure Random",
				"description": "Set the SecureRandom used to initialize the Signature service",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.security.SecureRandom|password"
			},
			"password": {
				"title": "Password",
				"description": "Sets the password used to access an aliased PrivateKey in the KeyStore.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cryptoOperation",
			"name"
		]
	},
	"cxf": {
		"properties": {
			"beanId": {
				"title": "Bean Id",
				"description": "To lookup an existing configured CxfEndpoint. Must used bean: as prefix.",
				"type": "string",
				"$comment": "group:common"
			},
			"address": {
				"title": "Address",
				"description": "The service publish address.",
				"type": "string",
				"$comment": "group:service"
			},
			"dataFormat": {
				"title": "Data Format",
				"description": "The data type messages supported by the CXF endpoint.",
				"type": "string",
				"enum": [
					"PAYLOAD",
					"RAW",
					"MESSAGE",
					"CXF_MESSAGE",
					"POJO"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.cxf.common.DataFormat",
				"default": "POJO"
			},
			"wrappedStyle": {
				"title": "Wrapped Style",
				"description": "The WSDL style that describes how parameters are represented in the SOAP body. If the value is false, CXF will chose the document-literal unwrapped style, If the value is true, CXF will chose the document-literal wrapped style",
				"type": "boolean",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"cookieHandler": {
				"title": "Cookie Handler",
				"description": "Configure a cookie handler to maintain a HTTP session",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.http.base.cookie.CookieHandler"
			},
			"defaultOperationName": {
				"title": "Default Operation Name",
				"description": "This option will set the default operationName that will be used by the CxfProducer which invokes the remote service.",
				"type": "string",
				"$comment": "group:producer"
			},
			"defaultOperationNamespace": {
				"title": "Default Operation Namespace",
				"description": "This option will set the default operationNamespace that will be used by the CxfProducer which invokes the remote service.",
				"type": "string",
				"$comment": "group:producer"
			},
			"hostnameVerifier": {
				"title": "Hostname Verifier",
				"description": "The hostname verifier to be used. Use the # notation to reference a HostnameVerifier from the registry.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:javax.net.ssl.HostnameVerifier"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "The Camel SSL setting reference. Use the # notation to reference the SSL Context.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"wrapped": {
				"title": "Wrapped",
				"description": "Which kind of operation that CXF endpoint producer will invoke",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"allowStreaming": {
				"title": "Allow Streaming",
				"description": "This option controls whether the CXF component, when running in PAYLOAD mode, will DOM parse the incoming messages into DOM Elements or keep the payload as a javax.xml.transform.Source object that would allow streaming in some cases.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"bus": {
				"title": "Bus",
				"description": "To use a custom configured CXF Bus.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.cxf.Bus"
			},
			"continuationTimeout": {
				"title": "Continuation Timeout",
				"description": "This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "30000"
			},
			"cxfBinding": {
				"title": "Cxf Binding",
				"description": "To use a custom CxfBinding to control the binding between Camel Message and CXF Message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.cxf.common.CxfBinding"
			},
			"cxfConfigurer": {
				"title": "Cxf Configurer",
				"description": "This option could apply the implementation of org.apache.camel.component.cxf.CxfEndpointConfigurer which supports to configure the CXF endpoint in programmatic way. User can configure the CXF server and client by implementing configure{ServerClient} method of CxfEndpointConfigurer.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.cxf.jaxws.CxfConfigurer"
			},
			"defaultBus": {
				"title": "Default Bus",
				"description": "Will set the default bus when CXF endpoint create a bus by itself",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"mergeProtocolHeaders": {
				"title": "Merge Protocol Headers",
				"description": "Whether to merge protocol headers. If enabled then propagating headers between Camel and CXF becomes more consistent and similar. For more details see CAMEL-6393.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"mtomEnabled": {
				"title": "Mtom Enabled",
				"description": "To enable MTOM (attachments). This requires to use POJO or PAYLOAD data format mode.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"properties": {
				"title": "Properties",
				"description": "To set additional CXF options using the key/value pairs from the Map. For example to turn on stacktraces in SOAP faults, properties.faultStackTraceEnabled=true",
				"type": "object",
				"$comment": "group:advanced"
			},
			"schemaValidationEnabled": {
				"title": "Schema Validation Enabled",
				"description": "Enable schema validation for request and response. Disabled by default for performance reason",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"skipPayloadMessagePartCheck": {
				"title": "Skip Payload Message Part Check",
				"description": "Sets whether SOAP message validation should be disabled.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"loggingFeatureEnabled": {
				"title": "Logging Feature Enabled",
				"description": "This option enables CXF Logging Feature which writes inbound and outbound SOAP messages to log.",
				"type": "boolean",
				"$comment": "group:logging"
			},
			"loggingSizeLimit": {
				"title": "Logging Size Limit",
				"description": "To limit the total size of number of bytes the logger will output when logging feature has been enabled and -1 for no limit.",
				"type": "integer",
				"$comment": "group:logging",
				"default": 49152
			},
			"skipFaultLogging": {
				"title": "Skip Fault Logging",
				"description": "This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.",
				"type": "boolean",
				"$comment": "group:logging"
			},
			"password": {
				"title": "Password",
				"description": "This option is used to set the basic authentication information of password for the CXF client.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "This option is used to set the basic authentication information of username for the CXF client.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"bindingId": {
				"title": "Binding Id",
				"description": "The bindingId for the service model to use.",
				"type": "string",
				"$comment": "group:service"
			},
			"portName": {
				"title": "Port Name",
				"description": "The endpoint name this service is implementing, it maps to the wsdl:portname. In the format of ns:PORT_NAME where ns is a namespace prefix valid at this scope.",
				"type": "string",
				"$comment": "group:service"
			},
			"publishedEndpointUrl": {
				"title": "Published Endpoint Url",
				"description": "This option can override the endpointUrl that published from the WSDL which can be accessed with service address url plus wsd",
				"type": "string",
				"$comment": "group:service"
			},
			"serviceClass": {
				"title": "Service Class",
				"description": "The class name of the SEI (Service Endpoint Interface) class which could have JSR181 annotation or not.",
				"type": "string",
				"$comment": "group:service"
			},
			"serviceName": {
				"title": "Service Name",
				"description": "The service name this service is implementing, it maps to the wsdl:servicename.",
				"type": "string",
				"$comment": "group:service"
			},
			"wsdlURL": {
				"title": "Wsdl URL",
				"description": "The location of the WSDL. Can be on the classpath, file system, or be hosted remotely.",
				"type": "string",
				"$comment": "group:service"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"cxfrs": {
		"properties": {
			"beanId": {
				"title": "Bean Id",
				"description": "To lookup an existing configured CxfRsEndpoint. Must used bean: as prefix.",
				"type": "string",
				"$comment": "group:common"
			},
			"address": {
				"title": "Address",
				"description": "The service publish address.",
				"type": "string",
				"$comment": "group:common"
			},
			"features": {
				"title": "Features",
				"description": "Set the feature list to the CxfRs endpoint.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:common"
			},
			"modelRef": {
				"title": "Model Ref",
				"description": "This option is used to specify the model file which is useful for the resource class without annotation. When using this option, then the service class can be omitted, to emulate document-only endpoints",
				"type": "string",
				"$comment": "group:common"
			},
			"providers": {
				"title": "Providers",
				"description": "Set custom JAX-RS provider(s) list to the CxfRs endpoint. You can specify a string with a list of providers to lookup in the registy separated by comma.",
				"type": "string",
				"$comment": "group:common"
			},
			"resourceClasses": {
				"title": "Resource Classes",
				"description": "The resource classes which you want to export as REST service. Multiple classes can be separated by comma.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:common"
			},
			"schemaLocations": {
				"title": "Schema Locations",
				"description": "Sets the locations of the schema(s) which can be used to validate the incoming XML or JAXB-driven JSON.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:common"
			},
			"skipFaultLogging": {
				"title": "Skip Fault Logging",
				"description": "This option controls whether the PhaseInterceptorChain skips logging the Fault that it catches.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"bindingStyle": {
				"title": "Binding Style",
				"description": "Sets how requests and responses will be mapped to/from Camel. Two values are possible: SimpleConsumer: This binding style processes request parameters, multiparts, etc. and maps them to IN headers, IN attachments and to the message body. It aims to eliminate low-level processing of org.apache.cxf.message.MessageContentsList. It also also adds more flexibility and simplicity to the response mapping. Only available for consumers. Default: The default style. For consumers this passes on a MessageContentsList to the route, requiring low-level processing in the route. This is the traditional binding style, which simply dumps the org.apache.cxf.message.MessageContentsList coming in from the CXF stack onto the IN message body. The user is then responsible for processing it according to the contract defined by the JAX-RS method signature. Custom: allows you to specify a custom binding through the binding option.",
				"type": "string",
				"enum": [
					"SimpleConsumer",
					"Default",
					"Custom"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.cxf.jaxrs.BindingStyle",
				"default": "Default"
			},
			"publishedEndpointUrl": {
				"title": "Published Endpoint Url",
				"description": "This option can override the endpointUrl that published from the WADL which can be accessed with resource address url plus _wadl",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"serviceBeans": {
				"title": "Service Beans",
				"description": "The service beans (the bean ids to lookup in the registry) which you want to export as REST service. Multiple beans can be separated by comma",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"cookieHandler": {
				"title": "Cookie Handler",
				"description": "Configure a cookie handler to maintain a HTTP session",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.http.base.cookie.CookieHandler"
			},
			"hostnameVerifier": {
				"title": "Hostname Verifier",
				"description": "The hostname verifier to be used. Use the # notation to reference a HostnameVerifier from the registry.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:javax.net.ssl.HostnameVerifier"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "The Camel SSL setting reference. Use the # notation to reference the SSL Context.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"throwExceptionOnFailure": {
				"title": "Throw Exception On Failure",
				"description": "This option tells the CxfRsProducer to inspect return codes and will generate an Exception if the return code is larger than 207.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"httpClientAPI": {
				"title": "Http Client API",
				"description": "If it is true, the CxfRsProducer will use the HttpClientAPI to invoke the service. If it is false, the CxfRsProducer will use the ProxyClientAPI to invoke the service",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"ignoreDeleteMethodMessageBody": {
				"title": "Ignore Delete Method Message Body",
				"description": "This option is used to tell CxfRsProducer to ignore the message body of the DELETE method when using HTTP API.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"maxClientCacheSize": {
				"title": "Max Client Cache Size",
				"description": "This option allows you to configure the maximum size of the cache. The implementation caches CXF clients or ClientFactoryBean in CxfProvider and CxfRsProvider.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": 10
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"binding": {
				"title": "Binding",
				"description": "To use a custom CxfBinding to control the binding between Camel Message and CXF Message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.cxf.jaxrs.CxfRsBinding"
			},
			"bus": {
				"title": "Bus",
				"description": "To use a custom configured CXF Bus.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.cxf.Bus"
			},
			"continuationTimeout": {
				"title": "Continuation Timeout",
				"description": "This option is used to set the CXF continuation timeout which could be used in CxfConsumer by default when the CXF server is using Jetty or Servlet transport.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "30000"
			},
			"cxfRsConfigurer": {
				"title": "Cxf Rs Configurer",
				"description": "This option could apply the implementation of org.apache.camel.component.cxf.jaxrs.CxfRsEndpointConfigurer which supports to configure the CXF endpoint in programmatic way. User can configure the CXF server and client by implementing configure{Server/Client} method of CxfEndpointConfigurer.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.cxf.jaxrs.CxfRsConfigurer"
			},
			"defaultBus": {
				"title": "Default Bus",
				"description": "Will set the default bus when CXF endpoint create a bus by itself",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"performInvocation": {
				"title": "Perform Invocation",
				"description": "When the option is true, Camel will perform the invocation of the resource class instance and put the response object into the exchange for further processing.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"propagateContexts": {
				"title": "Propagate Contexts",
				"description": "When the option is true, JAXRS UriInfo, HttpHeaders, Request and SecurityContext contexts will be available to custom CXFRS processors as typed Camel exchange properties. These contexts can be used to analyze the current requests using JAX-RS API.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"loggingFeatureEnabled": {
				"title": "Logging Feature Enabled",
				"description": "This option enables CXF Logging Feature which writes inbound and outbound REST messages to log.",
				"type": "boolean",
				"$comment": "group:logging"
			},
			"loggingSizeLimit": {
				"title": "Logging Size Limit",
				"description": "To limit the total size of number of bytes the logger will output when logging feature has been enabled and -1 for no limit.",
				"type": "integer",
				"$comment": "group:logging",
				"default": 49152
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"dataformat": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of data format",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Operation to use either marshal or unmarshal",
				"type": "string",
				"enum": [
					"marshal",
					"unmarshal"
				],
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"operation"
		]
	},
	"dataset": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of DataSet to lookup in the registry",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.dataset.DataSet"
			},
			"dataSetIndex": {
				"title": "Data Set Index",
				"description": "Controls the behaviour of the CamelDataSetIndex header. off (consumer) the header will not be set. strict (consumer) the header will be set. lenient (consumer) the header will be set. off (producer) the header value will not be verified, and will not be set if it is not present. strict (producer) the header value must be present and will be verified. lenient (producer) the header value will be verified if it is present, and will be set if it is not present.",
				"type": "string",
				"enum": [
					"strict",
					"lenient",
					"off"
				],
				"$comment": "group:common",
				"default": "lenient"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Time period in millis to wait before starting sending messages.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "1000"
			},
			"minRate": {
				"title": "Min Rate",
				"description": "Wait until the DataSet contains at least this number of messages",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 0
			},
			"preloadSize": {
				"title": "Preload Size",
				"description": "Sets how many messages should be preloaded (sent) before the route completes its initialization",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 0
			},
			"produceDelay": {
				"title": "Produce Delay",
				"description": "Allows a delay to be specified which causes a delay when a message is sent by the consumer (to simulate slow processing)",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "3"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"assertPeriod": {
				"title": "Assert Period",
				"description": "Sets a grace period after which the mock endpoint will re-assert to ensure the preliminary assertion is still valid. This is used, for example, to assert that exactly a number of messages arrive. For example, if the expected count was set to 5, then the assertion is satisfied when five or more messages arrive. To ensure that exactly 5 messages arrive, then you would need to wait a little period to ensure no further message arrives. This is what you can use this method for. By default, this period is disabled.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"consumeDelay": {
				"title": "Consume Delay",
				"description": "Allows a delay to be specified which causes a delay when a message is consumed by the producer (to simulate slow processing)",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "0"
			},
			"expectedCount": {
				"title": "Expected Count",
				"description": "Specifies the expected number of message exchanges that should be received by this endpoint. Beware: If you want to expect that 0 messages, then take extra care, as 0 matches when the tests starts, so you need to set a assert period time to let the test run for a while to make sure there are still no messages arrived; for that use setAssertPeriod(long). An alternative is to use NotifyBuilder, and use the notifier to know when Camel is done routing some messages, before you call the assertIsSatisfied() method on the mocks. This allows you to not use a fixed assert period, to speedup testing times. If you want to assert that exactly nth message arrives to this mock endpoint, then see also the setAssertPeriod(long) method for further details.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"failFast": {
				"title": "Fail Fast",
				"description": "Sets whether assertIsSatisfied() should fail fast at the first detected failed expectation while it may otherwise wait for all expected messages to arrive before performing expectations verifications. Is by default true. Set to false to use behavior as in Camel 2.x.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"log": {
				"title": "Log",
				"description": "To turn on logging when the mock receives an incoming message. This will log only one time at INFO level for the incoming message. For more detailed logging then set the logger to DEBUG level for the org.apache.camel.component.mock.MockEndpoint class.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"reportGroup": {
				"title": "Report Group",
				"description": "A number that is used to turn on throughput logging based on groups of the size.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"resultMinimumWaitTime": {
				"title": "Result Minimum Wait Time",
				"description": "Sets the minimum expected amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"resultWaitTime": {
				"title": "Result Wait Time",
				"description": "Sets the maximum amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"retainFirst": {
				"title": "Retain First",
				"description": "Specifies to only retain the first nth number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the first 10 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the first 10 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"retainLast": {
				"title": "Retain Last",
				"description": "Specifies to only retain the last nth number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the last 20 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the last 20 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"sleepForEmptyTest": {
				"title": "Sleep For Empty Test",
				"description": "Allows a sleep to be specified to wait to check that this endpoint really is empty when expectedMessageCount(int) is called with zero",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"copyOnExchange": {
				"title": "Copy On Exchange",
				"description": "Sets whether to make a deep copy of the incoming Exchange when received at this mock endpoint. Is by default true.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"dataset-test": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of endpoint to lookup in the registry to use for polling messages used for testing",
				"type": "string",
				"$comment": "group:producer"
			},
			"anyOrder": {
				"title": "Any Order",
				"description": "Whether the expected messages should arrive in the same order or can be in any order.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"assertPeriod": {
				"title": "Assert Period",
				"description": "Sets a grace period after which the mock endpoint will re-assert to ensure the preliminary assertion is still valid. This is used, for example, to assert that exactly a number of messages arrive. For example, if the expected count was set to 5, then the assertion is satisfied when five or more messages arrive. To ensure that exactly 5 messages arrive, then you would need to wait a little period to ensure no further message arrives. This is what you can use this method for. By default, this period is disabled.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"delimiter": {
				"title": "Delimiter",
				"description": "The split delimiter to use when split is enabled. By default the delimiter is new line based. The delimiter can be a regular expression.",
				"type": "string",
				"$comment": "group:producer"
			},
			"expectedCount": {
				"title": "Expected Count",
				"description": "Specifies the expected number of message exchanges that should be received by this endpoint. Beware: If you want to expect that 0 messages, then take extra care, as 0 matches when the tests starts, so you need to set a assert period time to let the test run for a while to make sure there are still no messages arrived; for that use setAssertPeriod(long). An alternative is to use NotifyBuilder, and use the notifier to know when Camel is done routing some messages, before you call the assertIsSatisfied() method on the mocks. This allows you to not use a fixed assert period, to speedup testing times. If you want to assert that exactly nth message arrives to this mock endpoint, then see also the setAssertPeriod(long) method for further details.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"failFast": {
				"title": "Fail Fast",
				"description": "Sets whether assertIsSatisfied() should fail fast at the first detected failed expectation while it may otherwise wait for all expected messages to arrive before performing expectations verifications. Is by default true. Set to false to use behavior as in Camel 2.x.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"log": {
				"title": "Log",
				"description": "To turn on logging when the mock receives an incoming message. This will log only one time at INFO level for the incoming message. For more detailed logging then set the logger to DEBUG level for the org.apache.camel.component.mock.MockEndpoint class.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"reportGroup": {
				"title": "Report Group",
				"description": "A number that is used to turn on throughput logging based on groups of the size.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"resultMinimumWaitTime": {
				"title": "Result Minimum Wait Time",
				"description": "Sets the minimum expected amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"resultWaitTime": {
				"title": "Result Wait Time",
				"description": "Sets the maximum amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"retainFirst": {
				"title": "Retain First",
				"description": "Specifies to only retain the first nth number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the first 10 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the first 10 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"retainLast": {
				"title": "Retain Last",
				"description": "Specifies to only retain the last nth number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the last 20 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the last 20 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"sleepForEmptyTest": {
				"title": "Sleep For Empty Test",
				"description": "Allows a sleep to be specified to wait to check that this endpoint really is empty when expectedMessageCount(int) is called with zero",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"split": {
				"title": "Split",
				"description": "If enabled the messages loaded from the test endpoint will be split using new line delimiters so each line is an expected message. For example to use a file endpoint to load a file where each line is an expected message.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"timeout": {
				"title": "Timeout",
				"description": "The timeout to use when polling for message bodies from the URI",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "2000"
			},
			"copyOnExchange": {
				"title": "Copy On Exchange",
				"description": "Sets whether to make a deep copy of the incoming Exchange when received at this mock endpoint. Is by default true.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"debezium-db2": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Unique name for the connector. Attempting to register again with the same name will fail.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"additionalProperties": {
				"title": "Additional Properties",
				"description": "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
				"type": "object",
				"$comment": "group:common"
			},
			"internalKeyConverter": {
				"title": "Internal Key Converter",
				"description": "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"internalValueConverter": {
				"title": "Internal Value Converter",
				"description": "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"offsetCommitPolicy": {
				"title": "Offset Commit Policy",
				"description": "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetCommitTimeoutMs": {
				"title": "Offset Commit Timeout Ms",
				"description": "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "5000"
			},
			"offsetFlushIntervalMs": {
				"title": "Offset Flush Interval Ms",
				"description": "Interval at which to try committing offsets. The default is 1 minute.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "60000"
			},
			"offsetStorage": {
				"title": "Offset Storage",
				"description": "The name of the Java class that is responsible for persistence of connector offsets.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.storage.FileOffsetBackingStore"
			},
			"offsetStorageFileName": {
				"title": "Offset Storage File Name",
				"description": "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetStoragePartitions": {
				"title": "Offset Storage Partitions",
				"description": "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageReplicationFactor": {
				"title": "Offset Storage Replication Factor",
				"description": "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageTopic": {
				"title": "Offset Storage Topic",
				"description": "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"cdcChangeTablesSchema": {
				"title": "Cdc Change Tables Schema",
				"description": "The name of the schema where CDC change tables are located; defaults to 'ASNCDC'",
				"type": "string",
				"$comment": "group:db2",
				"default": "ASNCDC"
			},
			"cdcControlSchema": {
				"title": "Cdc Control Schema",
				"description": "The name of the schema where CDC control structures are located; defaults to 'ASNCDC'",
				"type": "string",
				"$comment": "group:db2",
				"default": "ASNCDC"
			},
			"columnExcludeList": {
				"title": "Column Exclude List",
				"description": "Regular expressions matching columns to exclude from change events",
				"type": "string",
				"$comment": "group:db2"
			},
			"columnIncludeList": {
				"title": "Column Include List",
				"description": "Regular expressions matching columns to include in change events",
				"type": "string",
				"$comment": "group:db2"
			},
			"columnPropagateSourceType": {
				"title": "Column Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching fully-qualified names of columns that adds the columns original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:db2"
			},
			"converters": {
				"title": "Converters",
				"description": "Optional list of custom converters that would be used instead of default ones. The converters are defined using '.type' config option and configured using options '.'",
				"type": "string",
				"$comment": "group:db2"
			},
			"customMetricTags": {
				"title": "Custom Metric Tags",
				"description": "The custom metric tags will accept key-value pairs to customize the MBean object name which should be appended the end of regular name, each key would represent a tag for the MBean object name, and the corresponding value would be the value of that tag the key is. For example: k1=v1,k2=v2",
				"type": "string",
				"$comment": "group:db2"
			},
			"databaseDbname": {
				"title": "Database Dbname",
				"description": "The name of the database from which the connector should capture changes",
				"type": "string",
				"$comment": "group:db2"
			},
			"databaseHostname": {
				"title": "Database Hostname",
				"description": "Resolvable hostname or IP address of the database server.",
				"type": "string",
				"$comment": "group:db2"
			},
			"databasePassword": {
				"title": "Database Password",
				"description": "Password of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:db2"
			},
			"databasePort": {
				"title": "Database Port",
				"description": "Port of the database server.",
				"type": "integer",
				"$comment": "group:db2",
				"default": 50000
			},
			"databaseUser": {
				"title": "Database User",
				"description": "Name of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:db2"
			},
			"datatypePropagateSourceType": {
				"title": "Datatype Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching the database-specific data type names that adds the data type's original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:db2"
			},
			"db2Platform": {
				"title": "Db2 Platform",
				"description": "Informs connector which Db2 implementation platform it is connected to. The default is 'LUW', which means Windows, UNIX, Linux. Using a value of 'Z' ensures that the Db2 for z/OS specific SQL statements are used.",
				"type": "string",
				"$comment": "group:db2",
				"default": "LUW"
			},
			"decimalHandlingMode": {
				"title": "Decimal Handling Mode",
				"description": "Specify how DECIMAL and NUMERIC columns should be represented in change events, including: 'precise' (the default) uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'string' uses string to represent values; 'double' represents values using Java's 'double', which may not offer the precision but will be far easier to use in consumers.",
				"type": "string",
				"$comment": "group:db2",
				"default": "precise"
			},
			"errorsMaxRetries": {
				"title": "Errors Max Retries",
				"description": "The maximum number of retries on connection errors before failing (-1 = no limit, 0 = disabled, 0 = num of retries).",
				"type": "integer",
				"$comment": "group:db2",
				"default": -1
			},
			"eventProcessingFailureHandlingMode": {
				"title": "Event Processing Failure Handling Mode",
				"description": "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including: 'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped; 'ignore' the problematic event will be skipped.",
				"type": "string",
				"$comment": "group:db2",
				"default": "fail"
			},
			"heartbeatIntervalMs": {
				"title": "Heartbeat Interval Ms",
				"description": "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
				"type": "string",
				"$comment": "group:db2",
				"format": "duration",
				"default": "0ms"
			},
			"heartbeatTopicsPrefix": {
				"title": "Heartbeat Topics Prefix",
				"description": "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
				"type": "string",
				"$comment": "group:db2",
				"default": "__debezium-heartbeat"
			},
			"includeSchemaChanges": {
				"title": "Include Schema Changes",
				"description": "Whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change will be recorded using a key that contains the database name and whose value include logical description of the new schema and optionally the DDL statement(s). The default is 'true'. This is independent of how the connector internally records database schema history.",
				"type": "boolean",
				"$comment": "group:db2",
				"default": true
			},
			"incrementalSnapshotChunkSize": {
				"title": "Incremental Snapshot Chunk Size",
				"description": "The maximum size of chunk (number of documents/rows) for incremental snapshotting",
				"type": "integer",
				"$comment": "group:db2",
				"default": 1024
			},
			"incrementalSnapshotWatermarkingStrategy": {
				"title": "Incremental Snapshot Watermarking Strategy",
				"description": "Specify the strategy used for watermarking during an incremental snapshot: 'insert_insert' both open and close signal is written into signal data collection (default); 'insert_delete' only open signal is written on signal data collection, the close will delete the relative open signal;",
				"type": "string",
				"$comment": "group:db2",
				"default": "INSERT_INSERT"
			},
			"maxBatchSize": {
				"title": "Max Batch Size",
				"description": "Maximum size of each batch of source records. Defaults to 2048.",
				"type": "integer",
				"$comment": "group:db2",
				"default": 2048
			},
			"maxQueueSize": {
				"title": "Max Queue Size",
				"description": "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
				"type": "integer",
				"$comment": "group:db2",
				"default": 8192
			},
			"maxQueueSizeInBytes": {
				"title": "Max Queue Size In Bytes",
				"description": "Maximum size of the queue in bytes for change events read from the database log but not yet recorded or forwarded. Defaults to 0. Mean the feature is not enabled",
				"type": "integer",
				"$comment": "group:db2",
				"default": 0
			},
			"messageKeyColumns": {
				"title": "Message Key Columns",
				"description": "A semicolon-separated list of expressions that match fully-qualified tables and column(s) to be used as message key. Each expression must match the pattern ':', where the table names could be defined as (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connector, and the key columns are a comma-separated list of columns representing the custom key. For any table without an explicit key configuration the table's primary key column(s) will be used as message key. Example: dbserver1.inventory.orderlines:orderId,orderLineId;dbserver1.inventory.orders:id",
				"type": "string",
				"$comment": "group:db2"
			},
			"notificationEnabledChannels": {
				"title": "Notification Enabled Channels",
				"description": "List of notification channels names that are enabled.",
				"type": "string",
				"$comment": "group:db2"
			},
			"notificationSinkTopicName": {
				"title": "Notification Sink Topic Name",
				"description": "The name of the topic for the notifications. This is required in case 'sink' is in the list of enabled channels",
				"type": "string",
				"$comment": "group:db2"
			},
			"pollIntervalMs": {
				"title": "Poll Interval Ms",
				"description": "Time to wait for new change events to appear after receiving no events, given in milliseconds. Defaults to 500 ms.",
				"type": "string",
				"$comment": "group:db2",
				"format": "duration",
				"default": "500ms"
			},
			"postProcessors": {
				"title": "Post Processors",
				"description": "Optional list of post processors. The processors are defined using '.type' config option and configured using options ''",
				"type": "string",
				"$comment": "group:db2"
			},
			"provideTransactionMetadata": {
				"title": "Provide Transaction Metadata",
				"description": "Enables transaction metadata extraction together with event counting",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"queryFetchSize": {
				"title": "Query Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while streaming. A value of '0' uses the default JDBC fetch size. The default value is '10000'.",
				"type": "integer",
				"$comment": "group:db2",
				"default": 10000
			},
			"retriableRestartConnectorWaitMs": {
				"title": "Retriable Restart Connector Wait Ms",
				"description": "Time to wait before restarting connector after retriable exception occurs. Defaults to 10000ms.",
				"type": "string",
				"$comment": "group:db2",
				"format": "duration",
				"default": "10s"
			},
			"schemaHistoryInternal": {
				"title": "Schema History Internal",
				"description": "The name of the SchemaHistory class that should be used to store and recover database schema changes. The configuration properties for the history are prefixed with the 'schema.history.internal.' string.",
				"type": "string",
				"$comment": "group:db2",
				"default": "io.debezium.storage.kafka.history.KafkaSchemaHistory"
			},
			"schemaHistoryInternalFileFilename": {
				"title": "Schema History Internal File Filename",
				"description": "The path to the file that will be used to record the database schema history",
				"type": "string",
				"$comment": "group:db2"
			},
			"schemaHistoryInternalSkipUnparseableDdl": {
				"title": "Schema History Internal Skip Unparseable Ddl",
				"description": "Controls the action Debezium will take when it meets a DDL statement in binlog, that it cannot parse.By default the connector will stop operating but by changing the setting it can ignore the statements which it cannot parse. If skipping is enabled then Debezium can miss metadata changes.",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"schemaHistoryInternalStoreOnlyCapturedDatabasesDdl": {
				"title": "Schema History Internal Store Only Captured Databases Ddl",
				"description": "Controls what DDL will Debezium store in database schema history. By default (false) Debezium will store all incoming DDL statements. If set to true, then only DDL that manipulates a table from captured schema/database will be stored.",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"schemaHistoryInternalStoreOnlyCapturedTablesDdl": {
				"title": "Schema History Internal Store Only Captured Tables Ddl",
				"description": "Controls what DDL will Debezium store in database schema history. By default (false) Debezium will store all incoming DDL statements. If set to true, then only DDL that manipulates a captured table will be stored.",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"schemaNameAdjustmentMode": {
				"title": "Schema Name Adjustment Mode",
				"description": "Specify how schema names should be adjusted for compatibility with the message converter used by the connector, including: 'avro' replaces the characters that cannot be used in the Avro type name with underscore; 'avro_unicode' replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java;'none' does not apply any adjustment (default)",
				"type": "string",
				"$comment": "group:db2",
				"default": "none"
			},
			"signalDataCollection": {
				"title": "Signal Data Collection",
				"description": "The name of the data collection that is used to send signals/commands to Debezium. Signaling is disabled when not set.",
				"type": "string",
				"$comment": "group:db2"
			},
			"signalEnabledChannels": {
				"title": "Signal Enabled Channels",
				"description": "List of channels names that are enabled. Source channel is enabled by default",
				"type": "string",
				"$comment": "group:db2",
				"default": "source"
			},
			"signalPollIntervalMs": {
				"title": "Signal Poll Interval Ms",
				"description": "Interval for looking for new signals in registered channels, given in milliseconds. Defaults to 5 seconds.",
				"type": "string",
				"$comment": "group:db2",
				"format": "duration",
				"default": "5s"
			},
			"skippedOperations": {
				"title": "Skipped Operations",
				"description": "The comma-separated list of operations to skip during streaming, defined as: 'c' for inserts/create; 'u' for updates; 'd' for deletes, 't' for truncates, and 'none' to indicate nothing skipped. By default, only truncate operations will be skipped.",
				"type": "string",
				"$comment": "group:db2",
				"default": "t"
			},
			"snapshotDelayMs": {
				"title": "Snapshot Delay Ms",
				"description": "A delay period before a snapshot will begin, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:db2",
				"format": "duration",
				"default": "0ms"
			},
			"snapshotFetchSize": {
				"title": "Snapshot Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while performing a snapshot.",
				"type": "integer",
				"$comment": "group:db2"
			},
			"snapshotIncludeCollectionList": {
				"title": "Snapshot Include Collection List",
				"description": "This setting must be set to specify a list of tables/collections whose snapshot must be taken on creating or restarting the connector.",
				"type": "string",
				"$comment": "group:db2"
			},
			"snapshotLockTimeoutMs": {
				"title": "Snapshot Lock Timeout Ms",
				"description": "The maximum number of millis to wait for table locks at the beginning of a snapshot. If locks cannot be acquired in this time frame, the snapshot will be aborted. Defaults to 10 seconds",
				"type": "string",
				"$comment": "group:db2",
				"format": "duration",
				"default": "10s"
			},
			"snapshotMode": {
				"title": "Snapshot Mode",
				"description": "The criteria for running a snapshot upon startup of the connector. Options include: 'initial' (the default) to specify the connector should run a snapshot only when no offsets are available for the logical server name; 'schema_only' to specify the connector should run a snapshot of the schema when no offsets are available for the logical server name.",
				"type": "string",
				"$comment": "group:db2",
				"default": "initial"
			},
			"snapshotModeConfigurationBasedSnapshotData": {
				"title": "Snapshot Mode Configuration Based Snapshot Data",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"snapshotModeConfigurationBasedSnapshotOnDataError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Data Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"snapshotModeConfigurationBasedSnapshotOnSchemaError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Schema Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"snapshotModeConfigurationBasedSnapshotSchema": {
				"title": "Snapshot Mode Configuration Based Snapshot Schema",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"snapshotModeConfigurationBasedStartStream": {
				"title": "Snapshot Mode Configuration Based Start Stream",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the stream should start or not after snapshot.",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"snapshotModeCustomName": {
				"title": "Snapshot Mode Custom Name",
				"description": "When 'snapshot.mode' is set as custom, this setting must be set to specify a the name of the custom implementation provided in the 'name()' method. The implementations must implement the 'Snapshotter' interface and is called on each app boot to determine whether to do a snapshot.",
				"type": "string",
				"$comment": "group:db2"
			},
			"snapshotSelectStatementOverrides": {
				"title": "Snapshot Select Statement Overrides",
				"description": "This property contains a comma-separated list of fully-qualified tables (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connectors. Select statements for the individual tables are specified in further configuration properties, one for each table, identified by the id 'snapshot.select.statement.overrides.DB_NAME.TABLE_NAME' or 'snapshot.select.statement.overrides.SCHEMA_NAME.TABLE_NAME', respectively. The value of those properties is the select statement to use when retrieving data from the specific table during snapshotting. A possible use case for large append-only tables is setting a specific point where to start (resume) snapshotting, in case a previous snapshotting was interrupted.",
				"type": "string",
				"$comment": "group:db2"
			},
			"snapshotTablesOrderByRowCount": {
				"title": "Snapshot Tables Order By Row Count",
				"description": "Controls the order in which tables are processed in the initial snapshot. A descending value will order the tables by row count descending. A ascending value will order the tables by row count ascending. A value of disabled (the default) will disable ordering by row count.",
				"type": "string",
				"$comment": "group:db2",
				"default": "disabled"
			},
			"sourceinfoStructMaker": {
				"title": "Sourceinfo Struct Maker",
				"description": "The name of the SourceInfoStructMaker class that returns SourceInfo schema and struct.",
				"type": "string",
				"$comment": "group:db2",
				"default": "io.debezium.connector.db2.Db2SourceInfoStructMaker"
			},
			"streamingDelayMs": {
				"title": "Streaming Delay Ms",
				"description": "A delay period after the snapshot is completed and the streaming begins, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:db2",
				"format": "duration",
				"default": "0ms"
			},
			"tableExcludeList": {
				"title": "Table Exclude List",
				"description": "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring",
				"type": "string",
				"$comment": "group:db2"
			},
			"tableIgnoreBuiltin": {
				"title": "Table Ignore Builtin",
				"description": "Flag specifying whether built-in tables should be ignored.",
				"type": "boolean",
				"$comment": "group:db2",
				"default": true
			},
			"tableIncludeList": {
				"title": "Table Include List",
				"description": "The tables for which changes are to be captured",
				"type": "string",
				"$comment": "group:db2"
			},
			"timePrecisionMode": {
				"title": "Time Precision Mode",
				"description": "Time, date, and timestamps can be represented with different kinds of precisions, including: 'adaptive' (the default) bases the precision of time, date, and timestamp values on the database column's precision; 'adaptive_time_microseconds' like 'adaptive' mode, but TIME fields always use microseconds precision; 'connect' always represents time, date, and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision.",
				"type": "string",
				"$comment": "group:db2",
				"default": "adaptive"
			},
			"tombstonesOnDelete": {
				"title": "Tombstones On Delete",
				"description": "Whether delete operations should be represented by a delete event and a subsequent tombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
				"type": "boolean",
				"$comment": "group:db2"
			},
			"topicNamingStrategy": {
				"title": "Topic Naming Strategy",
				"description": "The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc.",
				"type": "string",
				"$comment": "group:db2",
				"default": "io.debezium.schema.SchemaTopicNamingStrategy"
			},
			"topicPrefix": {
				"title": "Topic Prefix",
				"description": "Topic prefix that identifies and provides a namespace for the particular database server/cluster is capturing changes. The topic prefix should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector. Only alphanumeric characters, hyphens, dots and underscores must be accepted.",
				"type": "string",
				"$comment": "group:db2"
			},
			"transactionMetadataFactory": {
				"title": "Transaction Metadata Factory",
				"description": "Class to make transaction context & transaction struct/schemas",
				"type": "string",
				"$comment": "group:db2",
				"default": "io.debezium.pipeline.txmetadata.DefaultTransactionMetadataFactory"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"databasePassword",
			"topicPrefix"
		]
	},
	"debezium-mongodb": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Unique name for the connector. Attempting to register again with the same name will fail.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"additionalProperties": {
				"title": "Additional Properties",
				"description": "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
				"type": "object",
				"$comment": "group:common"
			},
			"internalKeyConverter": {
				"title": "Internal Key Converter",
				"description": "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"internalValueConverter": {
				"title": "Internal Value Converter",
				"description": "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"offsetCommitPolicy": {
				"title": "Offset Commit Policy",
				"description": "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetCommitTimeoutMs": {
				"title": "Offset Commit Timeout Ms",
				"description": "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "5000"
			},
			"offsetFlushIntervalMs": {
				"title": "Offset Flush Interval Ms",
				"description": "Interval at which to try committing offsets. The default is 1 minute.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "60000"
			},
			"offsetStorage": {
				"title": "Offset Storage",
				"description": "The name of the Java class that is responsible for persistence of connector offsets.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.storage.FileOffsetBackingStore"
			},
			"offsetStorageFileName": {
				"title": "Offset Storage File Name",
				"description": "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetStoragePartitions": {
				"title": "Offset Storage Partitions",
				"description": "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageReplicationFactor": {
				"title": "Offset Storage Replication Factor",
				"description": "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageTopic": {
				"title": "Offset Storage Topic",
				"description": "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"captureMode": {
				"title": "Capture Mode",
				"description": "The method used to capture changes from MongoDB server. Options include: 'change_streams' to capture changes via MongoDB Change Streams, update events do not contain full documents; 'change_streams_update_full' (the default) to capture changes via MongoDB Change Streams, update events contain full documents",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "change_streams_update_full"
			},
			"collectionExcludeList": {
				"title": "Collection Exclude List",
				"description": "A comma-separated list of regular expressions or literals that match the collection names for which changes are to be excluded",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"collectionIncludeList": {
				"title": "Collection Include List",
				"description": "A comma-separated list of regular expressions or literals that match the collection names for which changes are to be captured",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"converters": {
				"title": "Converters",
				"description": "Optional list of custom converters that would be used instead of default ones. The converters are defined using '.type' config option and configured using options '.'",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"cursorMaxAwaitTimeMs": {
				"title": "Cursor Max Await Time Ms",
				"description": "The maximum processing time in milliseconds to wait for the oplog cursor to process a single poll request",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration"
			},
			"customMetricTags": {
				"title": "Custom Metric Tags",
				"description": "The custom metric tags will accept key-value pairs to customize the MBean object name which should be appended the end of regular name, each key would represent a tag for the MBean object name, and the corresponding value would be the value of that tag the key is. For example: k1=v1,k2=v2",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"databaseExcludeList": {
				"title": "Database Exclude List",
				"description": "A comma-separated list of regular expressions or literals that match the database names for which changes are to be excluded",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"databaseIncludeList": {
				"title": "Database Include List",
				"description": "A comma-separated list of regular expressions or literals that match the database names for which changes are to be captured",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"errorsMaxRetries": {
				"title": "Errors Max Retries",
				"description": "The maximum number of retries on connection errors before failing (-1 = no limit, 0 = disabled, 0 = num of retries).",
				"type": "integer",
				"$comment": "group:mongodb",
				"default": -1
			},
			"eventProcessingFailureHandlingMode": {
				"title": "Event Processing Failure Handling Mode",
				"description": "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including: 'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped; 'ignore' the problematic event will be skipped.",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "fail"
			},
			"fieldExcludeList": {
				"title": "Field Exclude List",
				"description": "A comma-separated list of the fully-qualified names of fields that should be excluded from change event message values",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"fieldRenames": {
				"title": "Field Renames",
				"description": "A comma-separated list of the fully-qualified replacements of fields that should be used to rename fields in change event message values. Fully-qualified replacements for fields are of the form databaseName.collectionName.fieldName.nestedFieldName:newNestedFieldName, where databaseName and collectionName may contain the wildcard () which matches any characters, the colon character (:) is used to determine rename mapping of field.",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"heartbeatIntervalMs": {
				"title": "Heartbeat Interval Ms",
				"description": "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "0ms"
			},
			"heartbeatTopicsPrefix": {
				"title": "Heartbeat Topics Prefix",
				"description": "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "__debezium-heartbeat"
			},
			"incrementalSnapshotWatermarkingStrategy": {
				"title": "Incremental Snapshot Watermarking Strategy",
				"description": "Specify the strategy used for watermarking during an incremental snapshot: 'insert_insert' both open and close signal is written into signal data collection (default); 'insert_delete' only open signal is written on signal data collection, the close will delete the relative open signal;",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "INSERT_INSERT"
			},
			"maxBatchSize": {
				"title": "Max Batch Size",
				"description": "Maximum size of each batch of source records. Defaults to 2048.",
				"type": "integer",
				"$comment": "group:mongodb",
				"default": 2048
			},
			"maxQueueSize": {
				"title": "Max Queue Size",
				"description": "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
				"type": "integer",
				"$comment": "group:mongodb",
				"default": 8192
			},
			"maxQueueSizeInBytes": {
				"title": "Max Queue Size In Bytes",
				"description": "Maximum size of the queue in bytes for change events read from the database log but not yet recorded or forwarded. Defaults to 0. Mean the feature is not enabled",
				"type": "integer",
				"$comment": "group:mongodb",
				"default": 0
			},
			"mongodbAuthsource": {
				"title": "Mongodb Authsource",
				"description": "Database containing user credentials.",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "admin"
			},
			"mongodbConnectionString": {
				"title": "Mongodb Connection String",
				"description": "Database connection string.",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"mongodbConnectTimeoutMs": {
				"title": "Mongodb Connect Timeout Ms",
				"description": "The connection timeout, given in milliseconds. Defaults to 10 seconds (10,000 ms).",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "10s"
			},
			"mongodbHeartbeatFrequencyMs": {
				"title": "Mongodb Heartbeat Frequency Ms",
				"description": "The frequency that the cluster monitor attempts to reach each server. Defaults to 10 seconds (10,000 ms).",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "10s"
			},
			"mongodbPassword": {
				"title": "Mongodb Password",
				"description": "Password to be used when connecting to MongoDB, if necessary.",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"mongodbPollIntervalMs": {
				"title": "Mongodb Poll Interval Ms",
				"description": "Interval for looking for new, removed, or changed replica sets, given in milliseconds. Defaults to 30 seconds (30,000 ms).",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "30s"
			},
			"mongodbServerSelectionTimeoutMs": {
				"title": "Mongodb Server Selection Timeout Ms",
				"description": "The server selection timeout, given in milliseconds. Defaults to 10 seconds (10,000 ms).",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "30s"
			},
			"mongodbSocketTimeoutMs": {
				"title": "Mongodb Socket Timeout Ms",
				"description": "The socket timeout, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "0ms"
			},
			"mongodbSslEnabled": {
				"title": "Mongodb Ssl Enabled",
				"description": "Should connector use SSL to connect to MongoDB instances",
				"type": "boolean",
				"$comment": "group:mongodb"
			},
			"mongodbSslInvalidHostnameAllowed": {
				"title": "Mongodb Ssl Invalid Hostname Allowed",
				"description": "Whether invalid host names are allowed when using SSL. If true the connection will not prevent man-in-the-middle attacks",
				"type": "boolean",
				"$comment": "group:mongodb"
			},
			"mongodbUser": {
				"title": "Mongodb User",
				"description": "Database user for connecting to MongoDB, if necessary.",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"notificationEnabledChannels": {
				"title": "Notification Enabled Channels",
				"description": "List of notification channels names that are enabled.",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"notificationSinkTopicName": {
				"title": "Notification Sink Topic Name",
				"description": "The name of the topic for the notifications. This is required in case 'sink' is in the list of enabled channels",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"pollIntervalMs": {
				"title": "Poll Interval Ms",
				"description": "Time to wait for new change events to appear after receiving no events, given in milliseconds. Defaults to 500 ms.",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "500ms"
			},
			"postProcessors": {
				"title": "Post Processors",
				"description": "Optional list of post processors. The processors are defined using '.type' config option and configured using options ''",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"provideTransactionMetadata": {
				"title": "Provide Transaction Metadata",
				"description": "Enables transaction metadata extraction together with event counting",
				"type": "boolean",
				"$comment": "group:mongodb"
			},
			"queryFetchSize": {
				"title": "Query Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while streaming. A value of '0' uses the default JDBC fetch size.",
				"type": "integer",
				"$comment": "group:mongodb",
				"default": 0
			},
			"retriableRestartConnectorWaitMs": {
				"title": "Retriable Restart Connector Wait Ms",
				"description": "Time to wait before restarting connector after retriable exception occurs. Defaults to 10000ms.",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "10s"
			},
			"schemaHistoryInternalFileFilename": {
				"title": "Schema History Internal File Filename",
				"description": "The path to the file that will be used to record the database schema history",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"schemaNameAdjustmentMode": {
				"title": "Schema Name Adjustment Mode",
				"description": "Specify how schema names should be adjusted for compatibility with the message converter used by the connector, including: 'avro' replaces the characters that cannot be used in the Avro type name with underscore; 'avro_unicode' replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java;'none' does not apply any adjustment (default)",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "none"
			},
			"signalDataCollection": {
				"title": "Signal Data Collection",
				"description": "The name of the data collection that is used to send signals/commands to Debezium. Signaling is disabled when not set.",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"signalEnabledChannels": {
				"title": "Signal Enabled Channels",
				"description": "List of channels names that are enabled. Source channel is enabled by default",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "source"
			},
			"signalPollIntervalMs": {
				"title": "Signal Poll Interval Ms",
				"description": "Interval for looking for new signals in registered channels, given in milliseconds. Defaults to 5 seconds.",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "5s"
			},
			"skippedOperations": {
				"title": "Skipped Operations",
				"description": "The comma-separated list of operations to skip during streaming, defined as: 'c' for inserts/create; 'u' for updates; 'd' for deletes, 't' for truncates, and 'none' to indicate nothing skipped. By default, only truncate operations will be skipped.",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "t"
			},
			"snapshotCollectionFilterOverrides": {
				"title": "Snapshot Collection Filter Overrides",
				"description": "This property contains a comma-separated list of ., for which the initial snapshot may be a subset of data present in the data source. The subset would be defined by mongodb filter query specified as value for property snapshot.collection.filter.override..",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"snapshotDelayMs": {
				"title": "Snapshot Delay Ms",
				"description": "A delay period before a snapshot will begin, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "0ms"
			},
			"snapshotFetchSize": {
				"title": "Snapshot Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while performing a snapshot.",
				"type": "integer",
				"$comment": "group:mongodb"
			},
			"snapshotIncludeCollectionList": {
				"title": "Snapshot Include Collection List",
				"description": "This setting must be set to specify a list of tables/collections whose snapshot must be taken on creating or restarting the connector.",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"snapshotMaxThreads": {
				"title": "Snapshot Max Threads",
				"description": "The maximum number of threads used to perform the snapshot. Defaults to 1.",
				"type": "integer",
				"$comment": "group:mongodb",
				"default": 1
			},
			"snapshotMode": {
				"title": "Snapshot Mode",
				"description": "The criteria for running a snapshot upon startup of the connector. Select one of the following snapshot options: 'initial' (default): If the connector does not detect any offsets for the logical server name, it runs a snapshot that captures the current full state of the configured tables. After the snapshot completes, the connector begins to stream changes from the oplog. 'never': The connector does not run a snapshot. Upon first startup, the connector immediately begins reading from the beginning of the oplog.",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "initial"
			},
			"snapshotModeConfigurationBasedSnapshotData": {
				"title": "Snapshot Mode Configuration Based Snapshot Data",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:mongodb"
			},
			"snapshotModeConfigurationBasedSnapshotOnDataError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Data Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:mongodb"
			},
			"snapshotModeConfigurationBasedSnapshotOnSchemaError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Schema Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:mongodb"
			},
			"snapshotModeConfigurationBasedSnapshotSchema": {
				"title": "Snapshot Mode Configuration Based Snapshot Schema",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:mongodb"
			},
			"snapshotModeConfigurationBasedStartStream": {
				"title": "Snapshot Mode Configuration Based Start Stream",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the stream should start or not after snapshot.",
				"type": "boolean",
				"$comment": "group:mongodb"
			},
			"snapshotModeCustomName": {
				"title": "Snapshot Mode Custom Name",
				"description": "When 'snapshot.mode' is set as custom, this setting must be set to specify a the name of the custom implementation provided in the 'name()' method. The implementations must implement the 'Snapshotter' interface and is called on each app boot to determine whether to do a snapshot.",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"sourceinfoStructMaker": {
				"title": "Sourceinfo Struct Maker",
				"description": "The name of the SourceInfoStructMaker class that returns SourceInfo schema and struct.",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "io.debezium.connector.mongodb.MongoDbSourceInfoStructMaker"
			},
			"streamingDelayMs": {
				"title": "Streaming Delay Ms",
				"description": "A delay period after the snapshot is completed and the streaming begins, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:mongodb",
				"format": "duration",
				"default": "0ms"
			},
			"tombstonesOnDelete": {
				"title": "Tombstones On Delete",
				"description": "Whether delete operations should be represented by a delete event and a subsequent tombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
				"type": "boolean",
				"$comment": "group:mongodb"
			},
			"topicNamingStrategy": {
				"title": "Topic Naming Strategy",
				"description": "The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc.",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "io.debezium.schema.SchemaTopicNamingStrategy"
			},
			"topicPrefix": {
				"title": "Topic Prefix",
				"description": "Topic prefix that identifies and provides a namespace for the particular database server/cluster is capturing changes. The topic prefix should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector. Only alphanumeric characters, hyphens, dots and underscores must be accepted.",
				"type": "string",
				"$comment": "group:mongodb"
			},
			"transactionMetadataFactory": {
				"title": "Transaction Metadata Factory",
				"description": "Class to make transaction context & transaction struct/schemas",
				"type": "string",
				"$comment": "group:mongodb",
				"default": "io.debezium.pipeline.txmetadata.DefaultTransactionMetadataFactory"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"mongodbPassword",
			"topicPrefix"
		]
	},
	"debezium-mysql": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Unique name for the connector. Attempting to register again with the same name will fail.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"additionalProperties": {
				"title": "Additional Properties",
				"description": "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
				"type": "object",
				"$comment": "group:common"
			},
			"internalKeyConverter": {
				"title": "Internal Key Converter",
				"description": "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"internalValueConverter": {
				"title": "Internal Value Converter",
				"description": "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"offsetCommitPolicy": {
				"title": "Offset Commit Policy",
				"description": "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetCommitTimeoutMs": {
				"title": "Offset Commit Timeout Ms",
				"description": "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "5000"
			},
			"offsetFlushIntervalMs": {
				"title": "Offset Flush Interval Ms",
				"description": "Interval at which to try committing offsets. The default is 1 minute.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "60000"
			},
			"offsetStorage": {
				"title": "Offset Storage",
				"description": "The name of the Java class that is responsible for persistence of connector offsets.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.storage.FileOffsetBackingStore"
			},
			"offsetStorageFileName": {
				"title": "Offset Storage File Name",
				"description": "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetStoragePartitions": {
				"title": "Offset Storage Partitions",
				"description": "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageReplicationFactor": {
				"title": "Offset Storage Replication Factor",
				"description": "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageTopic": {
				"title": "Offset Storage Topic",
				"description": "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"bigintUnsignedHandlingMode": {
				"title": "Bigint Unsigned Handling Mode",
				"description": "Specify how BIGINT UNSIGNED columns should be represented in change events, including: 'precise' uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'long' (the default) represents values using Java's 'long', which may not offer the precision but will be far easier to use in consumers.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "long"
			},
			"binlogBufferSize": {
				"title": "Binlog Buffer Size",
				"description": "The size of a look-ahead buffer used by the binlog reader to decide whether the transaction in progress is going to be committed or rolled back. Use 0 to disable look-ahead buffering. Defaults to 0 (i.e. buffering is disabled.",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 0
			},
			"columnExcludeList": {
				"title": "Column Exclude List",
				"description": "Regular expressions matching columns to exclude from change events",
				"type": "string",
				"$comment": "group:mysql"
			},
			"columnIncludeList": {
				"title": "Column Include List",
				"description": "Regular expressions matching columns to include in change events",
				"type": "string",
				"$comment": "group:mysql"
			},
			"columnPropagateSourceType": {
				"title": "Column Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching fully-qualified names of columns that adds the columns original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"connectKeepAlive": {
				"title": "Connect Keep Alive",
				"description": "Whether a separate thread should be used to ensure the connection is kept alive.",
				"type": "boolean",
				"$comment": "group:mysql",
				"default": true
			},
			"connectKeepAliveIntervalMs": {
				"title": "Connect Keep Alive Interval Ms",
				"description": "Interval for connection checking if keep alive thread is used, given in milliseconds Defaults to 1 minute (60,000 ms).",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "1m"
			},
			"connectTimeoutMs": {
				"title": "Connect Timeout Ms",
				"description": "Maximum time to wait after trying to connect to the database before timing out, given in milliseconds. Defaults to 30 seconds (30,000 ms).",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "30s"
			},
			"converters": {
				"title": "Converters",
				"description": "Optional list of custom converters that would be used instead of default ones. The converters are defined using '.type' config option and configured using options '.'",
				"type": "string",
				"$comment": "group:mysql"
			},
			"customMetricTags": {
				"title": "Custom Metric Tags",
				"description": "The custom metric tags will accept key-value pairs to customize the MBean object name which should be appended the end of regular name, each key would represent a tag for the MBean object name, and the corresponding value would be the value of that tag the key is. For example: k1=v1,k2=v2",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databaseExcludeList": {
				"title": "Database Exclude List",
				"description": "A comma-separated list of regular expressions that match database names to be excluded from monitoring",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databaseHostname": {
				"title": "Database Hostname",
				"description": "Resolvable hostname or IP address of the database server.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databaseIncludeList": {
				"title": "Database Include List",
				"description": "The databases for which changes are to be captured",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databaseInitialStatements": {
				"title": "Database Initial Statements",
				"description": "A semicolon separated list of SQL statements to be executed when a JDBC connection (not binlog reading connection) to the database is established. Note that the connector may establish JDBC connections at its own discretion, so this should typically be used for configuration of session parameters only, but not for executing DML statements. Use doubled semicolon (';;') to use a semicolon as a character and not as a delimiter.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databaseJdbcDriver": {
				"title": "Database Jdbc Driver",
				"description": "JDBC Driver class name used to connect to the MySQL database server.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "com.mysql.cj.jdbc.Driver"
			},
			"databasePassword": {
				"title": "Database Password",
				"description": "Password of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databasePort": {
				"title": "Database Port",
				"description": "Port of the database server.",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 3306
			},
			"databaseProtocol": {
				"title": "Database Protocol",
				"description": "JDBC protocol to use with the driver.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "jdbc:mysql"
			},
			"databaseQueryTimeoutMs": {
				"title": "Database Query Timeout Ms",
				"description": "Time to wait for a query to execute, given in milliseconds. Defaults to 600 seconds (600,000 ms); zero means there is no limit.",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "10m"
			},
			"databaseServerId": {
				"title": "Database Server Id",
				"description": "A numeric ID of this database client, which must be unique across all currently-running database processes in the cluster. This connector joins the database cluster as another server (with this unique ID) so it can read the binlog.",
				"type": "integer",
				"$comment": "group:mysql"
			},
			"databaseServerIdOffset": {
				"title": "Database Server Id Offset",
				"description": "Only relevant if parallel snapshotting is configured. During parallel snapshotting, multiple (4) connections open to the database client, and they each need their own unique connection ID. This offset is used to generate those IDs from the base configured cluster ID.",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 10000
			},
			"databaseSslKeystore": {
				"title": "Database Ssl Keystore",
				"description": "The location of the key store file. This is optional and can be used for two-way authentication between the client and the database.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databaseSslKeystorePassword": {
				"title": "Database Ssl Keystore Password",
				"description": "The password for the key store file. This is optional and only needed if 'database.ssl.keystore' is configured.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databaseSslMode": {
				"title": "Database Ssl Mode",
				"description": "Whether to use an encrypted connection to the database. Options include: 'disabled' to use an unencrypted connection; 'preferred' (the default) to establish a secure (encrypted) connection if the server supports secure connections, but fall back to an unencrypted connection otherwise; 'required' to use a secure (encrypted) connection, and fail if one cannot be established; 'verify_ca' like 'required' but additionally verify the server TLS certificate against the configured Certificate Authority (CA) certificates, or fail if no valid matching CA certificates are found; or 'verify_identity' like 'verify_ca' but additionally verify that the server certificate matches the host to which the connection is attempted.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "preferred"
			},
			"databaseSslTruststore": {
				"title": "Database Ssl Truststore",
				"description": "The location of the trust store file for the server certificate verification.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databaseSslTruststorePassword": {
				"title": "Database Ssl Truststore Password",
				"description": "The password for the trust store file. Used to check the integrity of the truststore, and unlock the truststore.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"databaseUser": {
				"title": "Database User",
				"description": "Name of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"datatypePropagateSourceType": {
				"title": "Datatype Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching the database-specific data type names that adds the data type's original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"decimalHandlingMode": {
				"title": "Decimal Handling Mode",
				"description": "Specify how DECIMAL and NUMERIC columns should be represented in change events, including: 'precise' (the default) uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'string' uses string to represent values; 'double' represents values using Java's 'double', which may not offer the precision but will be far easier to use in consumers.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "precise"
			},
			"enableTimeAdjuster": {
				"title": "Enable Time Adjuster",
				"description": "The database allows the user to insert year value as either 2-digit or 4-digit. In case of two digit the value is automatically mapped into 1970 - 2069.false - delegates the implicit conversion to the database; true - (the default) Debezium makes the conversion",
				"type": "boolean",
				"$comment": "group:mysql",
				"default": true
			},
			"errorsMaxRetries": {
				"title": "Errors Max Retries",
				"description": "The maximum number of retries on connection errors before failing (-1 = no limit, 0 = disabled, 0 = num of retries).",
				"type": "integer",
				"$comment": "group:mysql",
				"default": -1
			},
			"eventDeserializationFailureHandlingMode": {
				"title": "Event Deserialization Failure Handling Mode",
				"description": "Specify how failures during deserialization of binlog events (i.e. when encountering a corrupted event) should be handled, including: 'fail' (the default) an exception indicating the problematic event and its binlog position is raised, causing the connector to be stopped; 'warn' the problematic event and its binlog position will be logged and the event will be skipped; 'ignore' the problematic event will be skipped.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "fail"
			},
			"eventProcessingFailureHandlingMode": {
				"title": "Event Processing Failure Handling Mode",
				"description": "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including: 'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped; 'ignore' the problematic event will be skipped.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "fail"
			},
			"gtidSourceExcludes": {
				"title": "Gtid Source Excludes",
				"description": "The source UUIDs used to exclude GTID ranges when determine the starting position in the MySQL server's binlog.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"gtidSourceFilterDmlEvents": {
				"title": "Gtid Source Filter Dml Events",
				"description": "When set to true, only produce DML events for transactions that were written on the server with matching GTIDs defined by the gtid.source.includes or gtid.source.excludes, if they were specified.",
				"type": "boolean",
				"$comment": "group:mysql",
				"default": true
			},
			"gtidSourceIncludes": {
				"title": "Gtid Source Includes",
				"description": "The source UUIDs used to include GTID ranges when determine the starting position in the MySQL server's binlog.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"heartbeatActionQuery": {
				"title": "Heartbeat Action Query",
				"description": "The query executed with every heartbeat.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"heartbeatIntervalMs": {
				"title": "Heartbeat Interval Ms",
				"description": "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "0ms"
			},
			"heartbeatTopicsPrefix": {
				"title": "Heartbeat Topics Prefix",
				"description": "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "__debezium-heartbeat"
			},
			"includeQuery": {
				"title": "Include Query",
				"description": "Whether the connector should include the original SQL query that generated the change event. Note: This option requires the database to be configured using the server option binlog_rows_query_log_events (MySQL) or binlog_annotate_row_events (MariaDB) set to ON.Query will not be present for events generated from snapshot. WARNING: Enabling this option may expose tables or fields explicitly excluded or masked by including the original SQL statement in the change event. For this reason the default value is 'false'.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"includeSchemaChanges": {
				"title": "Include Schema Changes",
				"description": "Whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change will be recorded using a key that contains the database name and whose value include logical description of the new schema and optionally the DDL statement(s). The default is 'true'. This is independent of how the connector internally records database schema history.",
				"type": "boolean",
				"$comment": "group:mysql",
				"default": true
			},
			"includeSchemaComments": {
				"title": "Include Schema Comments",
				"description": "Whether the connector parse table and column's comment to metadata object. Note: Enable this option will bring the implications on memory usage. The number and size of ColumnImpl objects is what largely impacts how much memory is consumed by the Debezium connectors, and adding a String to each of them can potentially be quite heavy. The default is 'false'.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"inconsistentSchemaHandlingMode": {
				"title": "Inconsistent Schema Handling Mode",
				"description": "Specify how binlog events that belong to a table missing from internal schema representation (i.e. internal representation is not consistent with database) should be handled, including: 'fail' (the default) an exception indicating the problematic event and its binlog position is raised, causing the connector to be stopped; 'warn' the problematic event and its binlog position will be logged and the event will be skipped; 'skip' the problematic event will be skipped.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "fail"
			},
			"incrementalSnapshotAllowSchemaChanges": {
				"title": "Incremental Snapshot Allow Schema Changes",
				"description": "Detect schema change during an incremental snapshot and re-select a current chunk to avoid locking DDLs. Note that changes to a primary key are not supported and can cause incorrect results if performed during an incremental snapshot. Another limitation is that if a schema change affects only columns' default values, then the change won't be detected until the DDL is processed from the binlog stream. This doesn't affect the snapshot events' values, but the schema of snapshot events may have outdated defaults.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"incrementalSnapshotChunkSize": {
				"title": "Incremental Snapshot Chunk Size",
				"description": "The maximum size of chunk (number of documents/rows) for incremental snapshotting",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 1024
			},
			"incrementalSnapshotWatermarkingStrategy": {
				"title": "Incremental Snapshot Watermarking Strategy",
				"description": "Specify the strategy used for watermarking during an incremental snapshot: 'insert_insert' both open and close signal is written into signal data collection (default); 'insert_delete' only open signal is written on signal data collection, the close will delete the relative open signal;",
				"type": "string",
				"$comment": "group:mysql",
				"default": "INSERT_INSERT"
			},
			"maxBatchSize": {
				"title": "Max Batch Size",
				"description": "Maximum size of each batch of source records. Defaults to 2048.",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 2048
			},
			"maxQueueSize": {
				"title": "Max Queue Size",
				"description": "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 8192
			},
			"maxQueueSizeInBytes": {
				"title": "Max Queue Size In Bytes",
				"description": "Maximum size of the queue in bytes for change events read from the database log but not yet recorded or forwarded. Defaults to 0. Mean the feature is not enabled",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 0
			},
			"messageKeyColumns": {
				"title": "Message Key Columns",
				"description": "A semicolon-separated list of expressions that match fully-qualified tables and column(s) to be used as message key. Each expression must match the pattern ':', where the table names could be defined as (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connector, and the key columns are a comma-separated list of columns representing the custom key. For any table without an explicit key configuration the table's primary key column(s) will be used as message key. Example: dbserver1.inventory.orderlines:orderId,orderLineId;dbserver1.inventory.orders:id",
				"type": "string",
				"$comment": "group:mysql"
			},
			"minRowCountToStreamResults": {
				"title": "Min Row Count To Stream Results",
				"description": "The number of rows a table must contain to stream results rather than pull all into memory during snapshots. Defaults to 1,000. Use 0 to stream all results and completely avoid checking the size of each table.",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 1000
			},
			"notificationEnabledChannels": {
				"title": "Notification Enabled Channels",
				"description": "List of notification channels names that are enabled.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"notificationSinkTopicName": {
				"title": "Notification Sink Topic Name",
				"description": "The name of the topic for the notifications. This is required in case 'sink' is in the list of enabled channels",
				"type": "string",
				"$comment": "group:mysql"
			},
			"pollIntervalMs": {
				"title": "Poll Interval Ms",
				"description": "Time to wait for new change events to appear after receiving no events, given in milliseconds. Defaults to 500 ms.",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "500ms"
			},
			"postProcessors": {
				"title": "Post Processors",
				"description": "Optional list of post processors. The processors are defined using '.type' config option and configured using options ''",
				"type": "string",
				"$comment": "group:mysql"
			},
			"provideTransactionMetadata": {
				"title": "Provide Transaction Metadata",
				"description": "Enables transaction metadata extraction together with event counting",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"queryFetchSize": {
				"title": "Query Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while streaming. A value of '0' uses the default JDBC fetch size.",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 0
			},
			"retriableRestartConnectorWaitMs": {
				"title": "Retriable Restart Connector Wait Ms",
				"description": "Time to wait before restarting connector after retriable exception occurs. Defaults to 10000ms.",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "10s"
			},
			"schemaHistoryInternal": {
				"title": "Schema History Internal",
				"description": "The name of the SchemaHistory class that should be used to store and recover database schema changes. The configuration properties for the history are prefixed with the 'schema.history.internal.' string.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "io.debezium.storage.kafka.history.KafkaSchemaHistory"
			},
			"schemaHistoryInternalFileFilename": {
				"title": "Schema History Internal File Filename",
				"description": "The path to the file that will be used to record the database schema history",
				"type": "string",
				"$comment": "group:mysql"
			},
			"schemaHistoryInternalSkipUnparseableDdl": {
				"title": "Schema History Internal Skip Unparseable Ddl",
				"description": "Controls the action Debezium will take when it meets a DDL statement in binlog, that it cannot parse.By default the connector will stop operating but by changing the setting it can ignore the statements which it cannot parse. If skipping is enabled then Debezium can miss metadata changes.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"schemaHistoryInternalStoreOnlyCapturedDatabasesDdl": {
				"title": "Schema History Internal Store Only Captured Databases Ddl",
				"description": "Controls what DDL will Debezium store in database schema history. By default (false) Debezium will store all incoming DDL statements. If set to true, then only DDL that manipulates a table from captured schema/database will be stored.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"schemaHistoryInternalStoreOnlyCapturedTablesDdl": {
				"title": "Schema History Internal Store Only Captured Tables Ddl",
				"description": "Controls what DDL will Debezium store in database schema history. By default (false) Debezium will store all incoming DDL statements. If set to true, then only DDL that manipulates a captured table will be stored.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"schemaNameAdjustmentMode": {
				"title": "Schema Name Adjustment Mode",
				"description": "Specify how schema names should be adjusted for compatibility with the message converter used by the connector, including: 'avro' replaces the characters that cannot be used in the Avro type name with underscore; 'avro_unicode' replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java;'none' does not apply any adjustment (default)",
				"type": "string",
				"$comment": "group:mysql",
				"default": "none"
			},
			"signalDataCollection": {
				"title": "Signal Data Collection",
				"description": "The name of the data collection that is used to send signals/commands to Debezium. Signaling is disabled when not set.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"signalEnabledChannels": {
				"title": "Signal Enabled Channels",
				"description": "List of channels names that are enabled. Source channel is enabled by default",
				"type": "string",
				"$comment": "group:mysql",
				"default": "source"
			},
			"signalPollIntervalMs": {
				"title": "Signal Poll Interval Ms",
				"description": "Interval for looking for new signals in registered channels, given in milliseconds. Defaults to 5 seconds.",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "5s"
			},
			"skippedOperations": {
				"title": "Skipped Operations",
				"description": "The comma-separated list of operations to skip during streaming, defined as: 'c' for inserts/create; 'u' for updates; 'd' for deletes, 't' for truncates, and 'none' to indicate nothing skipped. By default, only truncate operations will be skipped.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "t"
			},
			"snapshotDelayMs": {
				"title": "Snapshot Delay Ms",
				"description": "A delay period before a snapshot will begin, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "0ms"
			},
			"snapshotFetchSize": {
				"title": "Snapshot Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while performing a snapshot.",
				"type": "integer",
				"$comment": "group:mysql"
			},
			"snapshotIncludeCollectionList": {
				"title": "Snapshot Include Collection List",
				"description": "This setting must be set to specify a list of tables/collections whose snapshot must be taken on creating or restarting the connector.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"snapshotLockingMode": {
				"title": "Snapshot Locking Mode",
				"description": "Controls how long the connector holds onto the global read lock while it is performing a snapshot. The default is 'minimal', which means the connector holds the global read lock (and thus prevents any updates) for just the initial portion of the snapshot while the database schemas and other metadata are being read. The remaining work in a snapshot involves selecting all rows from each table, and this can be done using the snapshot process' REPEATABLE READ transaction even when the lock is no longer held and other operations are updating the database. However, in some cases it may be desirable to block all writes for the entire duration of the snapshot; in such cases set this property to 'extended'. Using a value of 'none' will prevent the connector from acquiring any table locks during the snapshot process. This mode can only be used in combination with snapshot.mode values of 'schema_only' or 'schema_only_recovery' and is only safe to use if no schema changes are happening while the snapshot is taken.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "minimal"
			},
			"snapshotLockTimeoutMs": {
				"title": "Snapshot Lock Timeout Ms",
				"description": "The maximum number of millis to wait for table locks at the beginning of a snapshot. If locks cannot be acquired in this time frame, the snapshot will be aborted. Defaults to 10 seconds",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "10s"
			},
			"snapshotMaxThreads": {
				"title": "Snapshot Max Threads",
				"description": "The maximum number of threads used to perform the snapshot. Defaults to 1.",
				"type": "integer",
				"$comment": "group:mysql",
				"default": 1
			},
			"snapshotMode": {
				"title": "Snapshot Mode",
				"description": "The criteria for running a snapshot upon startup of the connector. Select one of the following snapshot options: 'when_needed': On startup, the connector runs a snapshot if one is needed.; 'schema_only': If the connector does not detect any offsets for the logical server name, it runs a snapshot that captures only the schema (table structures), but not any table data. After the snapshot completes, the connector begins to stream changes from the binlog.; 'schema_only_recovery': The connector performs a snapshot that captures only the database schema history. The connector then transitions back to streaming. Use this setting to restore a corrupted or lost database schema history topic. Do not use if the database schema was modified after the connector stopped.; 'initial' (default): If the connector does not detect any offsets for the logical server name, it runs a snapshot that captures the current full state of the configured tables. After the snapshot completes, the connector begins to stream changes from the binlog.; 'initial_only': The connector performs a snapshot as it does for the 'initial' option, but after the connector completes the snapshot, it stops, and does not stream changes from the binlog.; 'never': The connector does not run a snapshot. Upon first startup, the connector immediately begins reading from the beginning of the binlog. The 'never' mode should be used with care, and only when the binlog is known to contain all history.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "initial"
			},
			"snapshotModeConfigurationBasedSnapshotData": {
				"title": "Snapshot Mode Configuration Based Snapshot Data",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"snapshotModeConfigurationBasedSnapshotOnDataError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Data Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"snapshotModeConfigurationBasedSnapshotOnSchemaError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Schema Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"snapshotModeConfigurationBasedSnapshotSchema": {
				"title": "Snapshot Mode Configuration Based Snapshot Schema",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"snapshotModeConfigurationBasedStartStream": {
				"title": "Snapshot Mode Configuration Based Start Stream",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the stream should start or not after snapshot.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"snapshotModeCustomName": {
				"title": "Snapshot Mode Custom Name",
				"description": "When 'snapshot.mode' is set as custom, this setting must be set to specify a the name of the custom implementation provided in the 'name()' method. The implementations must implement the 'Snapshotter' interface and is called on each app boot to determine whether to do a snapshot.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"snapshotQueryMode": {
				"title": "Snapshot Query Mode",
				"description": "Controls query used during the snapshot",
				"type": "string",
				"$comment": "group:mysql",
				"default": "select_all"
			},
			"snapshotQueryModeCustomName": {
				"title": "Snapshot Query Mode Custom Name",
				"description": "When 'snapshot.query.mode' is set as custom, this setting must be set to specify a the name of the custom implementation provided in the 'name()' method. The implementations must implement the 'SnapshotterQuery' interface and is called to determine how to build queries during snapshot.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"snapshotSelectStatementOverrides": {
				"title": "Snapshot Select Statement Overrides",
				"description": "This property contains a comma-separated list of fully-qualified tables (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connectors. Select statements for the individual tables are specified in further configuration properties, one for each table, identified by the id 'snapshot.select.statement.overrides.DB_NAME.TABLE_NAME' or 'snapshot.select.statement.overrides.SCHEMA_NAME.TABLE_NAME', respectively. The value of those properties is the select statement to use when retrieving data from the specific table during snapshotting. A possible use case for large append-only tables is setting a specific point where to start (resume) snapshotting, in case a previous snapshotting was interrupted.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"snapshotTablesOrderByRowCount": {
				"title": "Snapshot Tables Order By Row Count",
				"description": "Controls the order in which tables are processed in the initial snapshot. A descending value will order the tables by row count descending. A ascending value will order the tables by row count ascending. A value of disabled (the default) will disable ordering by row count.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "disabled"
			},
			"sourceinfoStructMaker": {
				"title": "Sourceinfo Struct Maker",
				"description": "The name of the SourceInfoStructMaker class that returns SourceInfo schema and struct.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "io.debezium.connector.mysql.MySqlSourceInfoStructMaker"
			},
			"streamingDelayMs": {
				"title": "Streaming Delay Ms",
				"description": "A delay period after the snapshot is completed and the streaming begins, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:mysql",
				"format": "duration",
				"default": "0ms"
			},
			"tableExcludeList": {
				"title": "Table Exclude List",
				"description": "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring",
				"type": "string",
				"$comment": "group:mysql"
			},
			"tableIgnoreBuiltin": {
				"title": "Table Ignore Builtin",
				"description": "Flag specifying whether built-in tables should be ignored.",
				"type": "boolean",
				"$comment": "group:mysql",
				"default": true
			},
			"tableIncludeList": {
				"title": "Table Include List",
				"description": "The tables for which changes are to be captured",
				"type": "string",
				"$comment": "group:mysql"
			},
			"timePrecisionMode": {
				"title": "Time Precision Mode",
				"description": "Time, date and timestamps can be represented with different kinds of precisions, including: 'adaptive_time_microseconds': the precision of date and timestamp values is based the database column's precision; but time fields always use microseconds precision; 'connect': always represents time, date and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "adaptive_time_microseconds"
			},
			"tombstonesOnDelete": {
				"title": "Tombstones On Delete",
				"description": "Whether delete operations should be represented by a delete event and a subsequent tombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
				"type": "boolean",
				"$comment": "group:mysql"
			},
			"topicNamingStrategy": {
				"title": "Topic Naming Strategy",
				"description": "The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc.",
				"type": "string",
				"$comment": "group:mysql",
				"default": "io.debezium.schema.SchemaTopicNamingStrategy"
			},
			"topicPrefix": {
				"title": "Topic Prefix",
				"description": "Topic prefix that identifies and provides a namespace for the particular database server/cluster is capturing changes. The topic prefix should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector. Only alphanumeric characters, hyphens, dots and underscores must be accepted.",
				"type": "string",
				"$comment": "group:mysql"
			},
			"transactionMetadataFactory": {
				"title": "Transaction Metadata Factory",
				"description": "Class to make transaction context & transaction struct/schemas",
				"type": "string",
				"$comment": "group:mysql",
				"default": "io.debezium.pipeline.txmetadata.DefaultTransactionMetadataFactory"
			},
			"useNongracefulDisconnect": {
				"title": "Use Nongraceful Disconnect",
				"description": "Whether to use socket.setSoLinger(true, 0) when BinaryLogClient keepalive thread triggers a disconnect for a stale connection.",
				"type": "boolean",
				"$comment": "group:mysql"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"databasePassword",
			"topicPrefix"
		]
	},
	"debezium-oracle": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Unique name for the connector. Attempting to register again with the same name will fail.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"additionalProperties": {
				"title": "Additional Properties",
				"description": "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
				"type": "object",
				"$comment": "group:common"
			},
			"internalKeyConverter": {
				"title": "Internal Key Converter",
				"description": "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"internalValueConverter": {
				"title": "Internal Value Converter",
				"description": "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"offsetCommitPolicy": {
				"title": "Offset Commit Policy",
				"description": "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetCommitTimeoutMs": {
				"title": "Offset Commit Timeout Ms",
				"description": "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "5000"
			},
			"offsetFlushIntervalMs": {
				"title": "Offset Flush Interval Ms",
				"description": "Interval at which to try committing offsets. The default is 1 minute.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "60000"
			},
			"offsetStorage": {
				"title": "Offset Storage",
				"description": "The name of the Java class that is responsible for persistence of connector offsets.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.storage.FileOffsetBackingStore"
			},
			"offsetStorageFileName": {
				"title": "Offset Storage File Name",
				"description": "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetStoragePartitions": {
				"title": "Offset Storage Partitions",
				"description": "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageReplicationFactor": {
				"title": "Offset Storage Replication Factor",
				"description": "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageTopic": {
				"title": "Offset Storage Topic",
				"description": "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"archiveDestinationName": {
				"title": "Archive Destination Name",
				"description": "Sets the specific archive log destination as the source for reading archive logs.When not set, the connector will automatically select the first LOCAL and VALID destination.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"archiveLogHours": {
				"title": "Archive Log Hours",
				"description": "The number of hours in the past from SYSDATE to mine archive logs. Using 0 mines all available archive logs",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 0
			},
			"binaryHandlingMode": {
				"title": "Binary Handling Mode",
				"description": "Specify how binary (blob, binary, etc.) columns should be represented in change events, including: 'bytes' represents binary data as byte array (default); 'base64' represents binary data as base64-encoded string; 'base64-url-safe' represents binary data as base64-url-safe-encoded string; 'hex' represents binary data as hex-encoded (base16) string",
				"type": "string",
				"$comment": "group:oracle",
				"default": "bytes"
			},
			"columnExcludeList": {
				"title": "Column Exclude List",
				"description": "Regular expressions matching columns to exclude from change events",
				"type": "string",
				"$comment": "group:oracle"
			},
			"columnIncludeList": {
				"title": "Column Include List",
				"description": "Regular expressions matching columns to include in change events",
				"type": "string",
				"$comment": "group:oracle"
			},
			"columnPropagateSourceType": {
				"title": "Column Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching fully-qualified names of columns that adds the columns original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"converters": {
				"title": "Converters",
				"description": "Optional list of custom converters that would be used instead of default ones. The converters are defined using '.type' config option and configured using options '.'",
				"type": "string",
				"$comment": "group:oracle"
			},
			"customMetricTags": {
				"title": "Custom Metric Tags",
				"description": "The custom metric tags will accept key-value pairs to customize the MBean object name which should be appended the end of regular name, each key would represent a tag for the MBean object name, and the corresponding value would be the value of that tag the key is. For example: k1=v1,k2=v2",
				"type": "string",
				"$comment": "group:oracle"
			},
			"databaseConnectionAdapter": {
				"title": "Database Connection Adapter",
				"description": "The adapter to use when capturing changes from the database. Options include: 'logminer': (the default) to capture changes using native Oracle LogMiner; 'xstream' to capture changes using Oracle XStreams",
				"type": "string",
				"$comment": "group:oracle",
				"default": "LogMiner"
			},
			"databaseDbname": {
				"title": "Database Dbname",
				"description": "The name of the database from which the connector should capture changes",
				"type": "string",
				"$comment": "group:oracle"
			},
			"databaseHostname": {
				"title": "Database Hostname",
				"description": "Resolvable hostname or IP address of the database server.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"databaseOutServerName": {
				"title": "Database Out Server Name",
				"description": "Name of the XStream Out server to connect to.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"databasePassword": {
				"title": "Database Password",
				"description": "Password of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"databasePdbName": {
				"title": "Database Pdb Name",
				"description": "Name of the pluggable database when working with a multi-tenant set-up. The CDB name must be given via database.dbname in this case.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"databasePort": {
				"title": "Database Port",
				"description": "Port of the database server.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 1528
			},
			"databaseQueryTimeoutMs": {
				"title": "Database Query Timeout Ms",
				"description": "Time to wait for a query to execute, given in milliseconds. Defaults to 600 seconds (600,000 ms); zero means there is no limit.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "10m"
			},
			"databaseUrl": {
				"title": "Database Url",
				"description": "Complete JDBC URL as an alternative to specifying hostname, port and database provided as a way to support alternative connection scenarios.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"databaseUser": {
				"title": "Database User",
				"description": "Name of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"datatypePropagateSourceType": {
				"title": "Datatype Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching the database-specific data type names that adds the data type's original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"decimalHandlingMode": {
				"title": "Decimal Handling Mode",
				"description": "Specify how DECIMAL and NUMERIC columns should be represented in change events, including: 'precise' (the default) uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'string' uses string to represent values; 'double' represents values using Java's 'double', which may not offer the precision but will be far easier to use in consumers.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "precise"
			},
			"errorsMaxRetries": {
				"title": "Errors Max Retries",
				"description": "The maximum number of retries on connection errors before failing (-1 = no limit, 0 = disabled, 0 = num of retries).",
				"type": "integer",
				"$comment": "group:oracle",
				"default": -1
			},
			"eventProcessingFailureHandlingMode": {
				"title": "Event Processing Failure Handling Mode",
				"description": "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including: 'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped; 'ignore' the problematic event will be skipped.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "fail"
			},
			"heartbeatActionQuery": {
				"title": "Heartbeat Action Query",
				"description": "The query executed with every heartbeat.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"heartbeatIntervalMs": {
				"title": "Heartbeat Interval Ms",
				"description": "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "0ms"
			},
			"heartbeatTopicsPrefix": {
				"title": "Heartbeat Topics Prefix",
				"description": "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "__debezium-heartbeat"
			},
			"includeSchemaChanges": {
				"title": "Include Schema Changes",
				"description": "Whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change will be recorded using a key that contains the database name and whose value include logical description of the new schema and optionally the DDL statement(s). The default is 'true'. This is independent of how the connector internally records database schema history.",
				"type": "boolean",
				"$comment": "group:oracle",
				"default": true
			},
			"includeSchemaComments": {
				"title": "Include Schema Comments",
				"description": "Whether the connector parse table and column's comment to metadata object. Note: Enable this option will bring the implications on memory usage. The number and size of ColumnImpl objects is what largely impacts how much memory is consumed by the Debezium connectors, and adding a String to each of them can potentially be quite heavy. The default is 'false'.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"incrementalSnapshotWatermarkingStrategy": {
				"title": "Incremental Snapshot Watermarking Strategy",
				"description": "Specify the strategy used for watermarking during an incremental snapshot: 'insert_insert' both open and close signal is written into signal data collection (default); 'insert_delete' only open signal is written on signal data collection, the close will delete the relative open signal;",
				"type": "string",
				"$comment": "group:oracle",
				"default": "INSERT_INSERT"
			},
			"intervalHandlingMode": {
				"title": "Interval Handling Mode",
				"description": "Specify how INTERVAL columns should be represented in change events, including: 'string' represents values as an exact ISO formatted string; 'numeric' (default) represents values using the inexact conversion into microseconds",
				"type": "string",
				"$comment": "group:oracle",
				"default": "numeric"
			},
			"lobEnabled": {
				"title": "Lob Enabled",
				"description": "When set to 'false', the default, LOB fields will not be captured nor emitted. When set to 'true', the connector will capture LOB fields and emit changes for those fields like any other column type.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"logMiningArchiveLogOnlyMode": {
				"title": "Log Mining Archive Log Only Mode",
				"description": "When set to 'false', the default, the connector will mine both archive log and redo logs to emit change events. When set to 'true', the connector will only mine archive logs. There are circumstances where its advantageous to only mine archive logs and accept latency in event emission due to frequent revolving redo logs.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"logMiningArchiveLogOnlyScnPollIntervalMs": {
				"title": "Log Mining Archive Log Only Scn Poll Interval Ms",
				"description": "The interval in milliseconds to wait between polls checking to see if the SCN is in the archive logs.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "10s"
			},
			"logMiningBatchSizeDefault": {
				"title": "Log Mining Batch Size Default",
				"description": "The starting SCN interval size that the connector will use for reading data from redo/archive logs.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 20000
			},
			"logMiningBatchSizeIncrement": {
				"title": "Log Mining Batch Size Increment",
				"description": "Active batch size will be also increased/decreased by this amount for tuning connector throughput when needed.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 20000
			},
			"logMiningBatchSizeMax": {
				"title": "Log Mining Batch Size Max",
				"description": "The maximum SCN interval size that this connector will use when reading from redo/archive logs.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 100000
			},
			"logMiningBatchSizeMin": {
				"title": "Log Mining Batch Size Min",
				"description": "The minimum SCN interval size that this connector will try to read from redo/archive logs.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 1000
			},
			"logMiningBufferDropOnStop": {
				"title": "Log Mining Buffer Drop On Stop",
				"description": "When set to true the underlying buffer cache is not retained when the connector is stopped. When set to false (the default), the buffer cache is retained across restarts.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"logMiningBufferEhcacheEventsConfig": {
				"title": "Log Mining Buffer Ehcache Events Config",
				"description": "Specifies the inner body the Ehcache tag for the events cache, but should not include the nor the attributes as these are managed by Debezium.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferEhcacheGlobalConfig": {
				"title": "Log Mining Buffer Ehcache Global Config",
				"description": "Specifies any Ehcache global configurations such as services or persistence. This cannot include nor tags as these are managed by Debezium.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferEhcacheProcessedtransactionsConfig": {
				"title": "Log Mining Buffer Ehcache Processedtransactions Config",
				"description": "Specifies the inner body the Ehcache tag for the processed transaction cache, but should not include the nor the attributes as these are managed by Debezium.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferEhcacheSchemachangesConfig": {
				"title": "Log Mining Buffer Ehcache Schemachanges Config",
				"description": "Specifies the inner body the Ehcache tag for the schema changes cache, but should not include the nor the attributes as these are managed by Debezium.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferEhcacheTransactionsConfig": {
				"title": "Log Mining Buffer Ehcache Transactions Config",
				"description": "Specifies the inner body the Ehcache tag for the transaction cache, but should not include the nor the attributes as these are managed by Debezium.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferInfinispanCacheEvents": {
				"title": "Log Mining Buffer Infinispan Cache Events",
				"description": "Specifies the XML configuration for the Infinispan 'events' cache",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferInfinispanCacheGlobal": {
				"title": "Log Mining Buffer Infinispan Cache Global",
				"description": "Specifies the XML configuration for the Infinispan 'global' configuration",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferInfinispanCacheProcessedTransactions": {
				"title": "Log Mining Buffer Infinispan Cache Processed Transactions",
				"description": "Specifies the XML configuration for the Infinispan 'processed-transactions' cache",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferInfinispanCacheSchemaChanges": {
				"title": "Log Mining Buffer Infinispan Cache Schema Changes",
				"description": "Specifies the XML configuration for the Infinispan 'schema-changes' cache",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferInfinispanCacheTransactions": {
				"title": "Log Mining Buffer Infinispan Cache Transactions",
				"description": "Specifies the XML configuration for the Infinispan 'transactions' cache",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningBufferTransactionEventsThreshold": {
				"title": "Log Mining Buffer Transaction Events Threshold",
				"description": "The number of events a transaction can include before the transaction is discarded. This is useful for managing buffer memory and/or space when dealing with very large transactions. Defaults to 0, meaning that no threshold is applied and transactions can have unlimited events.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 0
			},
			"logMiningBufferType": {
				"title": "Log Mining Buffer Type",
				"description": "The buffer type controls how the connector manages buffering transaction data. memory - Uses the JVM process' heap to buffer all transaction data. infinispan_embedded - This option uses an embedded Infinispan cache to buffer transaction data and persist it to disk. infinispan_remote - This option uses a remote Infinispan cluster to buffer transaction data and persist it to disk. ehcache - Use ehcache in embedded mode to buffer transaction data and persist it to disk.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "memory"
			},
			"logMiningFlushTableName": {
				"title": "Log Mining Flush Table Name",
				"description": "The name of the flush table used by the connector, defaults to LOG_MINING_FLUSH.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "LOG_MINING_FLUSH"
			},
			"logMiningIncludeRedoSql": {
				"title": "Log Mining Include Redo Sql",
				"description": "When enabled, the transaction log REDO SQL will be included in the source information block.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"logMiningQueryFilterMode": {
				"title": "Log Mining Query Filter Mode",
				"description": "Specifies how the filter configuration is applied to the LogMiner database query. none - The query does not apply any schema or table filters, all filtering is at runtime by the connector. in - The query uses SQL in-clause expressions to specify the schema or table filters. regex - The query uses Oracle REGEXP_LIKE expressions to specify the schema or table filters.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "none"
			},
			"logMiningRestartConnection": {
				"title": "Log Mining Restart Connection",
				"description": "Debezium opens a database connection and keeps that connection open throughout the entire streaming phase. In some situations, this can lead to excessive SGA memory usage. By setting this option to 'true' (the default is 'false'), the connector will close and re-open a database connection after every detected log switch or if the log.mining.session.max.ms has been reached.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"logMiningScnGapDetectionGapSizeMin": {
				"title": "Log Mining Scn Gap Detection Gap Size Min",
				"description": "Used for SCN gap detection, if the difference between current SCN and previous end SCN is bigger than this value, and the time difference of current SCN and previous end SCN is smaller than log.mining.scn.gap.detection.time.interval.max.ms, consider it a SCN gap.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 1000000
			},
			"logMiningScnGapDetectionTimeIntervalMaxMs": {
				"title": "Log Mining Scn Gap Detection Time Interval Max Ms",
				"description": "Used for SCN gap detection, if the difference between current SCN and previous end SCN is bigger than log.mining.scn.gap.detection.gap.size.min, and the time difference of current SCN and previous end SCN is smaller than this value, consider it a SCN gap.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "20s"
			},
			"logMiningSessionMaxMs": {
				"title": "Log Mining Session Max Ms",
				"description": "The maximum number of milliseconds that a LogMiner session lives for before being restarted. Defaults to 0 (indefinite until a log switch occurs)",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "0ms"
			},
			"logMiningSleepTimeDefaultMs": {
				"title": "Log Mining Sleep Time Default Ms",
				"description": "The amount of time that the connector will sleep after reading data from redo/archive logs and before starting reading data again. Value is in milliseconds.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "1s"
			},
			"logMiningSleepTimeIncrementMs": {
				"title": "Log Mining Sleep Time Increment Ms",
				"description": "The maximum amount of time that the connector will use to tune the optimal sleep time when reading data from LogMiner. Value is in milliseconds.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "200ms"
			},
			"logMiningSleepTimeMaxMs": {
				"title": "Log Mining Sleep Time Max Ms",
				"description": "The maximum amount of time that the connector will sleep after reading data from redo/archive logs and before starting reading data again. Value is in milliseconds.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "3s"
			},
			"logMiningSleepTimeMinMs": {
				"title": "Log Mining Sleep Time Min Ms",
				"description": "The minimum amount of time that the connector will sleep after reading data from redo/archive logs and before starting reading data again. Value is in milliseconds.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "0ms"
			},
			"logMiningStrategy": {
				"title": "Log Mining Strategy",
				"description": "There are strategies: Online catalog with faster mining but no captured DDL. Another - with data dictionary loaded into REDO LOG files",
				"type": "string",
				"$comment": "group:oracle",
				"default": "online_catalog"
			},
			"logMiningTransactionRetentionMs": {
				"title": "Log Mining Transaction Retention Ms",
				"description": "Duration in milliseconds to keep long running transactions in transaction buffer between log mining sessions. By default, all transactions are retained.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "0ms"
			},
			"logMiningUsernameExcludeList": {
				"title": "Log Mining Username Exclude List",
				"description": "Comma separated list of usernames to exclude from LogMiner query.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"logMiningUsernameIncludeList": {
				"title": "Log Mining Username Include List",
				"description": "Comma separated list of usernames to include from LogMiner query.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"maxBatchSize": {
				"title": "Max Batch Size",
				"description": "Maximum size of each batch of source records. Defaults to 2048.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 2048
			},
			"maxQueueSize": {
				"title": "Max Queue Size",
				"description": "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 8192
			},
			"maxQueueSizeInBytes": {
				"title": "Max Queue Size In Bytes",
				"description": "Maximum size of the queue in bytes for change events read from the database log but not yet recorded or forwarded. Defaults to 0. Mean the feature is not enabled",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 0
			},
			"messageKeyColumns": {
				"title": "Message Key Columns",
				"description": "A semicolon-separated list of expressions that match fully-qualified tables and column(s) to be used as message key. Each expression must match the pattern ':', where the table names could be defined as (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connector, and the key columns are a comma-separated list of columns representing the custom key. For any table without an explicit key configuration the table's primary key column(s) will be used as message key. Example: dbserver1.inventory.orderlines:orderId,orderLineId;dbserver1.inventory.orders:id",
				"type": "string",
				"$comment": "group:oracle"
			},
			"notificationEnabledChannels": {
				"title": "Notification Enabled Channels",
				"description": "List of notification channels names that are enabled.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"notificationSinkTopicName": {
				"title": "Notification Sink Topic Name",
				"description": "The name of the topic for the notifications. This is required in case 'sink' is in the list of enabled channels",
				"type": "string",
				"$comment": "group:oracle"
			},
			"openlogreplicatorHost": {
				"title": "Openlogreplicator Host",
				"description": "The hostname of the OpenLogReplicator network service",
				"type": "string",
				"$comment": "group:oracle"
			},
			"openlogreplicatorPort": {
				"title": "Openlogreplicator Port",
				"description": "The port of the OpenLogReplicator network service",
				"type": "integer",
				"$comment": "group:oracle"
			},
			"openlogreplicatorSource": {
				"title": "Openlogreplicator Source",
				"description": "The configured logical source name in the OpenLogReplicator configuration that is to stream changes",
				"type": "string",
				"$comment": "group:oracle"
			},
			"pollIntervalMs": {
				"title": "Poll Interval Ms",
				"description": "Time to wait for new change events to appear after receiving no events, given in milliseconds. Defaults to 500 ms.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "500ms"
			},
			"postProcessors": {
				"title": "Post Processors",
				"description": "Optional list of post processors. The processors are defined using '.type' config option and configured using options ''",
				"type": "string",
				"$comment": "group:oracle"
			},
			"provideTransactionMetadata": {
				"title": "Provide Transaction Metadata",
				"description": "Enables transaction metadata extraction together with event counting",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"queryFetchSize": {
				"title": "Query Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while streaming. A value of '0' uses the default JDBC fetch size, defaults to '2000'.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 10000
			},
			"racNodes": {
				"title": "Rac Nodes",
				"description": "A comma-separated list of RAC node hostnames or ip addresses",
				"type": "string",
				"$comment": "group:oracle"
			},
			"retriableRestartConnectorWaitMs": {
				"title": "Retriable Restart Connector Wait Ms",
				"description": "Time to wait before restarting connector after retriable exception occurs. Defaults to 10000ms.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "10s"
			},
			"schemaHistoryInternal": {
				"title": "Schema History Internal",
				"description": "The name of the SchemaHistory class that should be used to store and recover database schema changes. The configuration properties for the history are prefixed with the 'schema.history.internal.' string.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "io.debezium.storage.kafka.history.KafkaSchemaHistory"
			},
			"schemaHistoryInternalFileFilename": {
				"title": "Schema History Internal File Filename",
				"description": "The path to the file that will be used to record the database schema history",
				"type": "string",
				"$comment": "group:oracle"
			},
			"schemaHistoryInternalSkipUnparseableDdl": {
				"title": "Schema History Internal Skip Unparseable Ddl",
				"description": "Controls the action Debezium will take when it meets a DDL statement in binlog, that it cannot parse.By default the connector will stop operating but by changing the setting it can ignore the statements which it cannot parse. If skipping is enabled then Debezium can miss metadata changes.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"schemaHistoryInternalStoreOnlyCapturedDatabasesDdl": {
				"title": "Schema History Internal Store Only Captured Databases Ddl",
				"description": "Controls what DDL will Debezium store in database schema history. By default (false) Debezium will store all incoming DDL statements. If set to true, then only DDL that manipulates a table from captured schema/database will be stored.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"schemaHistoryInternalStoreOnlyCapturedTablesDdl": {
				"title": "Schema History Internal Store Only Captured Tables Ddl",
				"description": "Controls what DDL will Debezium store in database schema history. By default (false) Debezium will store all incoming DDL statements. If set to true, then only DDL that manipulates a captured table will be stored.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"schemaNameAdjustmentMode": {
				"title": "Schema Name Adjustment Mode",
				"description": "Specify how schema names should be adjusted for compatibility with the message converter used by the connector, including: 'avro' replaces the characters that cannot be used in the Avro type name with underscore; 'avro_unicode' replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java;'none' does not apply any adjustment (default)",
				"type": "string",
				"$comment": "group:oracle",
				"default": "none"
			},
			"signalDataCollection": {
				"title": "Signal Data Collection",
				"description": "The name of the data collection that is used to send signals/commands to Debezium. Signaling is disabled when not set.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"signalEnabledChannels": {
				"title": "Signal Enabled Channels",
				"description": "List of channels names that are enabled. Source channel is enabled by default",
				"type": "string",
				"$comment": "group:oracle",
				"default": "source"
			},
			"signalPollIntervalMs": {
				"title": "Signal Poll Interval Ms",
				"description": "Interval for looking for new signals in registered channels, given in milliseconds. Defaults to 5 seconds.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "5s"
			},
			"skippedOperations": {
				"title": "Skipped Operations",
				"description": "The comma-separated list of operations to skip during streaming, defined as: 'c' for inserts/create; 'u' for updates; 'd' for deletes, 't' for truncates, and 'none' to indicate nothing skipped. By default, only truncate operations will be skipped.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "t"
			},
			"snapshotDatabaseErrorsMaxRetries": {
				"title": "Snapshot Database Errors Max Retries",
				"description": "The number of attempts to retry database errors during snapshots before failing.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 0
			},
			"snapshotDelayMs": {
				"title": "Snapshot Delay Ms",
				"description": "A delay period before a snapshot will begin, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "0ms"
			},
			"snapshotFetchSize": {
				"title": "Snapshot Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while performing a snapshot.",
				"type": "integer",
				"$comment": "group:oracle"
			},
			"snapshotIncludeCollectionList": {
				"title": "Snapshot Include Collection List",
				"description": "This setting must be set to specify a list of tables/collections whose snapshot must be taken on creating or restarting the connector.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"snapshotLockingMode": {
				"title": "Snapshot Locking Mode",
				"description": "Controls how the connector holds locks on tables while performing the schema snapshot. The default is 'shared', which means the connector will hold a table lock that prevents exclusive table access for just the initial portion of the snapshot while the database schemas and other metadata are being read. The remaining work in a snapshot involves selecting all rows from each table, and this is done using a flashback query that requires no locks. However, in some cases it may be desirable to avoid locks entirely which can be done by specifying 'none'. This mode is only safe to use if no schema changes are happening while the snapshot is taken.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "shared"
			},
			"snapshotLockTimeoutMs": {
				"title": "Snapshot Lock Timeout Ms",
				"description": "The maximum number of millis to wait for table locks at the beginning of a snapshot. If locks cannot be acquired in this time frame, the snapshot will be aborted. Defaults to 10 seconds",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "10s"
			},
			"snapshotMaxThreads": {
				"title": "Snapshot Max Threads",
				"description": "The maximum number of threads used to perform the snapshot. Defaults to 1.",
				"type": "integer",
				"$comment": "group:oracle",
				"default": 1
			},
			"snapshotMode": {
				"title": "Snapshot Mode",
				"description": "The criteria for running a snapshot upon startup of the connector. Select one of the following snapshot options: 'always': The connector runs a snapshot every time that it starts. After the snapshot completes, the connector begins to stream changes from the redo logs.; 'initial' (default): If the connector does not detect any offsets for the logical server name, it runs a snapshot that captures the current full state of the configured tables. After the snapshot completes, the connector begins to stream changes from the redo logs. 'initial_only': The connector performs a snapshot as it does for the 'initial' option, but after the connector completes the snapshot, it stops, and does not stream changes from the redo logs.; 'schema_only': If the connector does not detect any offsets for the logical server name, it runs a snapshot that captures only the schema (table structures), but not any table data. After the snapshot completes, the connector begins to stream changes from the redo logs.; 'schema_only_recovery': The connector performs a snapshot that captures only the database schema history. The connector then transitions to streaming from the redo logs. Use this setting to restore a corrupted or lost database schema history topic. Do not use if the database schema was modified after the connector stopped.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "initial"
			},
			"snapshotModeConfigurationBasedSnapshotData": {
				"title": "Snapshot Mode Configuration Based Snapshot Data",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"snapshotModeConfigurationBasedSnapshotOnDataError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Data Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"snapshotModeConfigurationBasedSnapshotOnSchemaError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Schema Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"snapshotModeConfigurationBasedSnapshotSchema": {
				"title": "Snapshot Mode Configuration Based Snapshot Schema",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"snapshotModeConfigurationBasedStartStream": {
				"title": "Snapshot Mode Configuration Based Start Stream",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the stream should start or not after snapshot.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"snapshotModeCustomName": {
				"title": "Snapshot Mode Custom Name",
				"description": "When 'snapshot.mode' is set as custom, this setting must be set to specify a the name of the custom implementation provided in the 'name()' method. The implementations must implement the 'Snapshotter' interface and is called on each app boot to determine whether to do a snapshot.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"snapshotSelectStatementOverrides": {
				"title": "Snapshot Select Statement Overrides",
				"description": "This property contains a comma-separated list of fully-qualified tables (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connectors. Select statements for the individual tables are specified in further configuration properties, one for each table, identified by the id 'snapshot.select.statement.overrides.DB_NAME.TABLE_NAME' or 'snapshot.select.statement.overrides.SCHEMA_NAME.TABLE_NAME', respectively. The value of those properties is the select statement to use when retrieving data from the specific table during snapshotting. A possible use case for large append-only tables is setting a specific point where to start (resume) snapshotting, in case a previous snapshotting was interrupted.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"snapshotTablesOrderByRowCount": {
				"title": "Snapshot Tables Order By Row Count",
				"description": "Controls the order in which tables are processed in the initial snapshot. A descending value will order the tables by row count descending. A ascending value will order the tables by row count ascending. A value of disabled (the default) will disable ordering by row count.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "disabled"
			},
			"sourceinfoStructMaker": {
				"title": "Sourceinfo Struct Maker",
				"description": "The name of the SourceInfoStructMaker class that returns SourceInfo schema and struct.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "io.debezium.connector.oracle.OracleSourceInfoStructMaker"
			},
			"streamingDelayMs": {
				"title": "Streaming Delay Ms",
				"description": "A delay period after the snapshot is completed and the streaming begins, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:oracle",
				"format": "duration",
				"default": "0ms"
			},
			"tableExcludeList": {
				"title": "Table Exclude List",
				"description": "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring",
				"type": "string",
				"$comment": "group:oracle"
			},
			"tableIncludeList": {
				"title": "Table Include List",
				"description": "The tables for which changes are to be captured",
				"type": "string",
				"$comment": "group:oracle"
			},
			"timePrecisionMode": {
				"title": "Time Precision Mode",
				"description": "Time, date, and timestamps can be represented with different kinds of precisions, including: 'adaptive' (the default) bases the precision of time, date, and timestamp values on the database column's precision; 'adaptive_time_microseconds' like 'adaptive' mode, but TIME fields always use microseconds precision; 'connect' always represents time, date, and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "adaptive"
			},
			"tombstonesOnDelete": {
				"title": "Tombstones On Delete",
				"description": "Whether delete operations should be represented by a delete event and a subsequent tombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
				"type": "boolean",
				"$comment": "group:oracle"
			},
			"topicNamingStrategy": {
				"title": "Topic Naming Strategy",
				"description": "The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "io.debezium.schema.SchemaTopicNamingStrategy"
			},
			"topicPrefix": {
				"title": "Topic Prefix",
				"description": "Topic prefix that identifies and provides a namespace for the particular database server/cluster is capturing changes. The topic prefix should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector. Only alphanumeric characters, hyphens, dots and underscores must be accepted.",
				"type": "string",
				"$comment": "group:oracle"
			},
			"transactionMetadataFactory": {
				"title": "Transaction Metadata Factory",
				"description": "Class to make transaction context & transaction struct/schemas",
				"type": "string",
				"$comment": "group:oracle",
				"default": "io.debezium.pipeline.txmetadata.DefaultTransactionMetadataFactory"
			},
			"unavailableValuePlaceholder": {
				"title": "Unavailable Value Placeholder",
				"description": "Specify the constant that will be provided by Debezium to indicate that the original value is unavailable and not provided by the database.",
				"type": "string",
				"$comment": "group:oracle",
				"default": "__debezium_unavailable_value"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"databasePassword",
			"topicPrefix"
		]
	},
	"debezium-postgres": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Unique name for the connector. Attempting to register again with the same name will fail.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"additionalProperties": {
				"title": "Additional Properties",
				"description": "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
				"type": "object",
				"$comment": "group:common"
			},
			"internalKeyConverter": {
				"title": "Internal Key Converter",
				"description": "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"internalValueConverter": {
				"title": "Internal Value Converter",
				"description": "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"offsetCommitPolicy": {
				"title": "Offset Commit Policy",
				"description": "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetCommitTimeoutMs": {
				"title": "Offset Commit Timeout Ms",
				"description": "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "5000"
			},
			"offsetFlushIntervalMs": {
				"title": "Offset Flush Interval Ms",
				"description": "Interval at which to try committing offsets. The default is 1 minute.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "60000"
			},
			"offsetStorage": {
				"title": "Offset Storage",
				"description": "The name of the Java class that is responsible for persistence of connector offsets.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.storage.FileOffsetBackingStore"
			},
			"offsetStorageFileName": {
				"title": "Offset Storage File Name",
				"description": "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetStoragePartitions": {
				"title": "Offset Storage Partitions",
				"description": "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageReplicationFactor": {
				"title": "Offset Storage Replication Factor",
				"description": "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageTopic": {
				"title": "Offset Storage Topic",
				"description": "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"binaryHandlingMode": {
				"title": "Binary Handling Mode",
				"description": "Specify how binary (blob, binary, etc.) columns should be represented in change events, including: 'bytes' represents binary data as byte array (default); 'base64' represents binary data as base64-encoded string; 'base64-url-safe' represents binary data as base64-url-safe-encoded string; 'hex' represents binary data as hex-encoded (base16) string",
				"type": "string",
				"$comment": "group:postgres",
				"default": "bytes"
			},
			"columnExcludeList": {
				"title": "Column Exclude List",
				"description": "Regular expressions matching columns to exclude from change events",
				"type": "string",
				"$comment": "group:postgres"
			},
			"columnIncludeList": {
				"title": "Column Include List",
				"description": "Regular expressions matching columns to include in change events",
				"type": "string",
				"$comment": "group:postgres"
			},
			"columnPropagateSourceType": {
				"title": "Column Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching fully-qualified names of columns that adds the columns original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"converters": {
				"title": "Converters",
				"description": "Optional list of custom converters that would be used instead of default ones. The converters are defined using '.type' config option and configured using options '.'",
				"type": "string",
				"$comment": "group:postgres"
			},
			"customMetricTags": {
				"title": "Custom Metric Tags",
				"description": "The custom metric tags will accept key-value pairs to customize the MBean object name which should be appended the end of regular name, each key would represent a tag for the MBean object name, and the corresponding value would be the value of that tag the key is. For example: k1=v1,k2=v2",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databaseDbname": {
				"title": "Database Dbname",
				"description": "The name of the database from which the connector should capture changes",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databaseHostname": {
				"title": "Database Hostname",
				"description": "Resolvable hostname or IP address of the database server.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databaseInitialStatements": {
				"title": "Database Initial Statements",
				"description": "A semicolon separated list of SQL statements to be executed when a JDBC connection to the database is established. Note that the connector may establish JDBC connections at its own discretion, so this should typically be used for configuration of session parameters only, but not for executing DML statements. Use doubled semicolon (';;') to use a semicolon as a character and not as a delimiter.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databasePassword": {
				"title": "Database Password",
				"description": "Password of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databasePort": {
				"title": "Database Port",
				"description": "Port of the database server.",
				"type": "integer",
				"$comment": "group:postgres",
				"default": 5432
			},
			"databaseQueryTimeoutMs": {
				"title": "Database Query Timeout Ms",
				"description": "Time to wait for a query to execute, given in milliseconds. Defaults to 600 seconds (600,000 ms); zero means there is no limit.",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "10m"
			},
			"databaseSslcert": {
				"title": "Database Sslcert",
				"description": "File containing the SSL Certificate for the client. See the Postgres SSL docs for further information",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databaseSslfactory": {
				"title": "Database Sslfactory",
				"description": "A name of class to that creates SSL Sockets. Use org.postgresql.ssl.NonValidatingFactory to disable SSL validation in development environments",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databaseSslkey": {
				"title": "Database Sslkey",
				"description": "File containing the SSL private key for the client. See the Postgres SSL docs for further information",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databaseSslmode": {
				"title": "Database Sslmode",
				"description": "Whether to use an encrypted connection to Postgres. Options include: 'disable' (the default) to use an unencrypted connection; 'allow' to try and use an unencrypted connection first and, failing that, a secure (encrypted) connection; 'prefer' (the default) to try and use a secure (encrypted) connection first and, failing that, an unencrypted connection; 'require' to use a secure (encrypted) connection, and fail if one cannot be established; 'verify-ca' like 'required' but additionally verify the server TLS certificate against the configured Certificate Authority (CA) certificates, or fail if no valid matching CA certificates are found; or 'verify-full' like 'verify-ca' but additionally verify that the server certificate matches the host to which the connection is attempted.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "prefer"
			},
			"databaseSslpassword": {
				"title": "Database Sslpassword",
				"description": "Password to access the client private key from the file specified by 'database.sslkey'. See the Postgres SSL docs for further information",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databaseSslrootcert": {
				"title": "Database Sslrootcert",
				"description": "File containing the root certificate(s) against which the server is validated. See the Postgres JDBC SSL docs for further information",
				"type": "string",
				"$comment": "group:postgres"
			},
			"databaseTcpkeepalive": {
				"title": "Database Tcpkeepalive",
				"description": "Enable or disable TCP keep-alive probe to avoid dropping TCP connection",
				"type": "boolean",
				"$comment": "group:postgres",
				"default": true
			},
			"databaseUser": {
				"title": "Database User",
				"description": "Name of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"datatypePropagateSourceType": {
				"title": "Datatype Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching the database-specific data type names that adds the data type's original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"decimalHandlingMode": {
				"title": "Decimal Handling Mode",
				"description": "Specify how DECIMAL and NUMERIC columns should be represented in change events, including: 'precise' (the default) uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'string' uses string to represent values; 'double' represents values using Java's 'double', which may not offer the precision but will be far easier to use in consumers.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "precise"
			},
			"errorsMaxRetries": {
				"title": "Errors Max Retries",
				"description": "The maximum number of retries on connection errors before failing (-1 = no limit, 0 = disabled, 0 = num of retries).",
				"type": "integer",
				"$comment": "group:postgres",
				"default": -1
			},
			"eventProcessingFailureHandlingMode": {
				"title": "Event Processing Failure Handling Mode",
				"description": "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including: 'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped; 'ignore' the problematic event will be skipped.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "fail"
			},
			"flushLsnSource": {
				"title": "Flush Lsn Source",
				"description": "Boolean to determine if Debezium should flush LSN in the source postgres database. If set to false, user will have to flush the LSN manually outside Debezium.",
				"type": "boolean",
				"$comment": "group:postgres",
				"default": true
			},
			"heartbeatActionQuery": {
				"title": "Heartbeat Action Query",
				"description": "The query executed with every heartbeat.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"heartbeatIntervalMs": {
				"title": "Heartbeat Interval Ms",
				"description": "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "0ms"
			},
			"heartbeatTopicsPrefix": {
				"title": "Heartbeat Topics Prefix",
				"description": "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "__debezium-heartbeat"
			},
			"hstoreHandlingMode": {
				"title": "Hstore Handling Mode",
				"description": "Specify how HSTORE columns should be represented in change events, including: 'json' represents values as string-ified JSON (default); 'map' represents values as a key/value map",
				"type": "string",
				"$comment": "group:postgres",
				"default": "json"
			},
			"includeSchemaComments": {
				"title": "Include Schema Comments",
				"description": "Whether the connector parse table and column's comment to metadata object. Note: Enable this option will bring the implications on memory usage. The number and size of ColumnImpl objects is what largely impacts how much memory is consumed by the Debezium connectors, and adding a String to each of them can potentially be quite heavy. The default is 'false'.",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"includeUnknownDatatypes": {
				"title": "Include Unknown Datatypes",
				"description": "Specify whether the fields of data type not supported by Debezium should be processed: 'false' (the default) omits the fields; 'true' converts the field into an implementation dependent binary representation.",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"incrementalSnapshotChunkSize": {
				"title": "Incremental Snapshot Chunk Size",
				"description": "The maximum size of chunk (number of documents/rows) for incremental snapshotting",
				"type": "integer",
				"$comment": "group:postgres",
				"default": 1024
			},
			"incrementalSnapshotWatermarkingStrategy": {
				"title": "Incremental Snapshot Watermarking Strategy",
				"description": "Specify the strategy used for watermarking during an incremental snapshot: 'insert_insert' both open and close signal is written into signal data collection (default); 'insert_delete' only open signal is written on signal data collection, the close will delete the relative open signal;",
				"type": "string",
				"$comment": "group:postgres",
				"default": "INSERT_INSERT"
			},
			"intervalHandlingMode": {
				"title": "Interval Handling Mode",
				"description": "Specify how INTERVAL columns should be represented in change events, including: 'string' represents values as an exact ISO formatted string; 'numeric' (default) represents values using the inexact conversion into microseconds",
				"type": "string",
				"$comment": "group:postgres",
				"default": "numeric"
			},
			"maxBatchSize": {
				"title": "Max Batch Size",
				"description": "Maximum size of each batch of source records. Defaults to 2048.",
				"type": "integer",
				"$comment": "group:postgres",
				"default": 2048
			},
			"maxQueueSize": {
				"title": "Max Queue Size",
				"description": "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
				"type": "integer",
				"$comment": "group:postgres",
				"default": 8192
			},
			"maxQueueSizeInBytes": {
				"title": "Max Queue Size In Bytes",
				"description": "Maximum size of the queue in bytes for change events read from the database log but not yet recorded or forwarded. Defaults to 0. Mean the feature is not enabled",
				"type": "integer",
				"$comment": "group:postgres",
				"default": 0
			},
			"messageKeyColumns": {
				"title": "Message Key Columns",
				"description": "A semicolon-separated list of expressions that match fully-qualified tables and column(s) to be used as message key. Each expression must match the pattern ':', where the table names could be defined as (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connector, and the key columns are a comma-separated list of columns representing the custom key. For any table without an explicit key configuration the table's primary key column(s) will be used as message key. Example: dbserver1.inventory.orderlines:orderId,orderLineId;dbserver1.inventory.orders:id",
				"type": "string",
				"$comment": "group:postgres"
			},
			"messagePrefixExcludeList": {
				"title": "Message Prefix Exclude List",
				"description": "A comma-separated list of regular expressions that match the logical decoding message prefixes to be excluded from monitoring.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"messagePrefixIncludeList": {
				"title": "Message Prefix Include List",
				"description": "A comma-separated list of regular expressions that match the logical decoding message prefixes to be monitored. All prefixes are monitored by default.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"notificationEnabledChannels": {
				"title": "Notification Enabled Channels",
				"description": "List of notification channels names that are enabled.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"notificationSinkTopicName": {
				"title": "Notification Sink Topic Name",
				"description": "The name of the topic for the notifications. This is required in case 'sink' is in the list of enabled channels",
				"type": "string",
				"$comment": "group:postgres"
			},
			"pluginName": {
				"title": "Plugin Name",
				"description": "The name of the Postgres logical decoding plugin installed on the server. Supported values are 'decoderbufs' and 'pgoutput'. Defaults to 'decoderbufs'.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "decoderbufs"
			},
			"pollIntervalMs": {
				"title": "Poll Interval Ms",
				"description": "Time to wait for new change events to appear after receiving no events, given in milliseconds. Defaults to 500 ms.",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "500ms"
			},
			"postProcessors": {
				"title": "Post Processors",
				"description": "Optional list of post processors. The processors are defined using '.type' config option and configured using options ''",
				"type": "string",
				"$comment": "group:postgres"
			},
			"provideTransactionMetadata": {
				"title": "Provide Transaction Metadata",
				"description": "Enables transaction metadata extraction together with event counting",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"publicationAutocreateMode": {
				"title": "Publication Autocreate Mode",
				"description": "Applies only when streaming changes using pgoutput.Determine how creation of a publication should work, the default is all_tables.DISABLED - The connector will not attempt to create a publication at all. The expectation is that the user has created the publication up-front. If the publication isn't found to exist upon startup, the connector will throw an exception and stop.ALL_TABLES - If no publication exists, the connector will create a new publication for all tables. Note this requires that the configured user has access. If the publication already exists, it will be used. i.e CREATE PUBLICATION FOR ALL TABLES;FILTERED - If no publication exists, the connector will create a new publication for all those tables matchingthe current filter configuration (see table/database include/exclude list properties). If the publication already exists, it will be used. i.e CREATE PUBLICATION FOR TABLE",
				"type": "string",
				"$comment": "group:postgres",
				"default": "all_tables"
			},
			"publicationName": {
				"title": "Publication Name",
				"description": "The name of the Postgres 10 publication used for streaming changes from a plugin. Defaults to 'dbz_publication'",
				"type": "string",
				"$comment": "group:postgres",
				"default": "dbz_publication"
			},
			"queryFetchSize": {
				"title": "Query Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while streaming. A value of '0' uses the default JDBC fetch size.",
				"type": "integer",
				"$comment": "group:postgres",
				"default": 0
			},
			"replicaIdentityAutosetValues": {
				"title": "Replica Identity Autoset Values",
				"description": "Applies only when streaming changes using pgoutput.Determines the value for Replica Identity at table level. This option will overwrite the existing value in databaseA comma-separated list of regular expressions that match fully-qualified tables and Replica Identity value to be used in the table. Each expression must match the pattern ':', where the table names could be defined as (SCHEMA_NAME.TABLE_NAME), and the replica identity values are: DEFAULT - Records the old values of the columns of the primary key, if any. This is the default for non-system tables.INDEX index_name - Records the old values of the columns covered by the named index, that must be unique, not partial, not deferrable, and include only columns marked NOT NULL. If this index is dropped, the behavior is the same as NOTHING.FULL - Records the old values of all columns in the row.NOTHING - Records no information about the old row. This is the default for system tables.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"retriableRestartConnectorWaitMs": {
				"title": "Retriable Restart Connector Wait Ms",
				"description": "Time to wait before restarting connector after retriable exception occurs. Defaults to 10000ms.",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "10s"
			},
			"schemaExcludeList": {
				"title": "Schema Exclude List",
				"description": "The schemas for which events must not be captured",
				"type": "string",
				"$comment": "group:postgres"
			},
			"schemaHistoryInternalFileFilename": {
				"title": "Schema History Internal File Filename",
				"description": "The path to the file that will be used to record the database schema history",
				"type": "string",
				"$comment": "group:postgres"
			},
			"schemaIncludeList": {
				"title": "Schema Include List",
				"description": "The schemas for which events should be captured",
				"type": "string",
				"$comment": "group:postgres"
			},
			"schemaNameAdjustmentMode": {
				"title": "Schema Name Adjustment Mode",
				"description": "Specify how schema names should be adjusted for compatibility with the message converter used by the connector, including: 'avro' replaces the characters that cannot be used in the Avro type name with underscore; 'avro_unicode' replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java;'none' does not apply any adjustment (default)",
				"type": "string",
				"$comment": "group:postgres",
				"default": "none"
			},
			"schemaRefreshMode": {
				"title": "Schema Refresh Mode",
				"description": "Specify the conditions that trigger a refresh of the in-memory schema for a table. 'columns_diff' (the default) is the safest mode, ensuring the in-memory schema stays in-sync with the database table's schema at all times. 'columns_diff_exclude_unchanged_toast' instructs the connector to refresh the in-memory schema cache if there is a discrepancy between it and the schema derived from the incoming message, unless unchanged TOASTable data fully accounts for the discrepancy. This setting can improve connector performance significantly if there are frequently-updated tables that have TOASTed data that are rarely part of these updates. However, it is possible for the in-memory schema to become outdated if TOASTable columns are dropped from the table.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "columns_diff"
			},
			"signalDataCollection": {
				"title": "Signal Data Collection",
				"description": "The name of the data collection that is used to send signals/commands to Debezium. Signaling is disabled when not set.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"signalEnabledChannels": {
				"title": "Signal Enabled Channels",
				"description": "List of channels names that are enabled. Source channel is enabled by default",
				"type": "string",
				"$comment": "group:postgres",
				"default": "source"
			},
			"signalPollIntervalMs": {
				"title": "Signal Poll Interval Ms",
				"description": "Interval for looking for new signals in registered channels, given in milliseconds. Defaults to 5 seconds.",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "5s"
			},
			"skippedOperations": {
				"title": "Skipped Operations",
				"description": "The comma-separated list of operations to skip during streaming, defined as: 'c' for inserts/create; 'u' for updates; 'd' for deletes, 't' for truncates, and 'none' to indicate nothing skipped. By default, only truncate operations will be skipped.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "t"
			},
			"slotDropOnStop": {
				"title": "Slot Drop On Stop",
				"description": "Whether or not to drop the logical replication slot when the connector finishes orderly. By default the replication is kept so that on restart progress can resume from the last recorded location",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"slotFailover": {
				"title": "Slot Failover",
				"description": "Whether or not to create a failover slot. This is only supported when connecting to a primary server of a Postgres cluster, version 17 or newer. When not specified, or when not connecting to a Postgres 17 primary, no failover slot will be created.",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"slotMaxRetries": {
				"title": "Slot Max Retries",
				"description": "How many times to retry connecting to a replication slot when an attempt fails.",
				"type": "integer",
				"$comment": "group:postgres",
				"default": 6
			},
			"slotName": {
				"title": "Slot Name",
				"description": "The name of the Postgres logical decoding slot created for streaming changes from a plugin. Defaults to 'debezium",
				"type": "string",
				"$comment": "group:postgres",
				"default": "debezium"
			},
			"slotRetryDelayMs": {
				"title": "Slot Retry Delay Ms",
				"description": "Time to wait between retry attempts when the connector fails to connect to a replication slot, given in milliseconds. Defaults to 10 seconds (10,000 ms).",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "10s"
			},
			"slotStreamParams": {
				"title": "Slot Stream Params",
				"description": "Any optional parameters used by logical decoding plugin. Semi-colon separated. E.g. 'add-tables=public.table,public.table2;include-lsn=true'",
				"type": "string",
				"$comment": "group:postgres"
			},
			"snapshotDelayMs": {
				"title": "Snapshot Delay Ms",
				"description": "A delay period before a snapshot will begin, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "0ms"
			},
			"snapshotFetchSize": {
				"title": "Snapshot Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while performing a snapshot.",
				"type": "integer",
				"$comment": "group:postgres"
			},
			"snapshotIncludeCollectionList": {
				"title": "Snapshot Include Collection List",
				"description": "This setting must be set to specify a list of tables/collections whose snapshot must be taken on creating or restarting the connector.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"snapshotIsolationMode": {
				"title": "Snapshot Isolation Mode",
				"description": "Controls which transaction isolation level is used. The default is 'serializable', which means that serializable isolation level is used. When 'repeatable_read' is specified, connector runs the initial snapshot in REPEATABLE READ isolation level. When 'read_committed' is specified, connector runs the initial snapshot in READ COMMITTED isolation level. In 'read_uncommitted' is specified, connector runs the initial snapshot in READ UNCOMMITTED isolation level.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "serializable"
			},
			"snapshotLockingMode": {
				"title": "Snapshot Locking Mode",
				"description": "Controls how the connector holds locks on tables while performing the schema snapshot. The 'shared' which means the connector will hold a table lock that prevents exclusive table access for just the initial portion of the snapshot while the database schemas and other metadata are being read. The remaining work in a snapshot involves selecting all rows from each table, and this is done using a flashback query that requires no locks. However, in some cases it may be desirable to avoid locks entirely which can be done by specifying 'none'. This mode is only safe to use if no schema changes are happening while the snapshot is taken.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "none"
			},
			"snapshotLockingModeCustomName": {
				"title": "Snapshot Locking Mode Custom Name",
				"description": "When 'snapshot.locking.mode' is set as custom, this setting must be set to specify a the name of the custom implementation provided in the 'name()' method. The implementations must implement the 'SnapshotterLocking' interface and is called to determine how to lock tables during schema snapshot.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"snapshotLockTimeoutMs": {
				"title": "Snapshot Lock Timeout Ms",
				"description": "The maximum number of millis to wait for table locks at the beginning of a snapshot. If locks cannot be acquired in this time frame, the snapshot will be aborted. Defaults to 10 seconds",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "10s"
			},
			"snapshotMaxThreads": {
				"title": "Snapshot Max Threads",
				"description": "The maximum number of threads used to perform the snapshot. Defaults to 1.",
				"type": "integer",
				"$comment": "group:postgres",
				"default": 1
			},
			"snapshotMode": {
				"title": "Snapshot Mode",
				"description": "The criteria for running a snapshot upon startup of the connector. Select one of the following snapshot options: 'always': The connector runs a snapshot every time that it starts. After the snapshot completes, the connector begins to stream changes from the transaction log.; 'initial' (default): If the connector does not detect any offsets for the logical server name, it runs a snapshot that captures the current full state of the configured tables. After the snapshot completes, the connector begins to stream changes from the transaction log. 'initial_only': The connector performs a snapshot as it does for the 'initial' option, but after the connector completes the snapshot, it stops, and does not stream changes from the transaction log.; 'never': The connector does not run a snapshot. Upon first startup, the connector immediately begins reading from the beginning of the transaction log. 'exported': This option is deprecated; use 'initial' instead.; 'custom': The connector loads a custom class to specify how the connector performs snapshots. For more information, see Custom snapshotter SPI in the PostgreSQL connector documentation.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "initial"
			},
			"snapshotModeConfigurationBasedSnapshotData": {
				"title": "Snapshot Mode Configuration Based Snapshot Data",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"snapshotModeConfigurationBasedSnapshotOnDataError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Data Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"snapshotModeConfigurationBasedSnapshotOnSchemaError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Schema Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"snapshotModeConfigurationBasedSnapshotSchema": {
				"title": "Snapshot Mode Configuration Based Snapshot Schema",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"snapshotModeConfigurationBasedStartStream": {
				"title": "Snapshot Mode Configuration Based Start Stream",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the stream should start or not after snapshot.",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"snapshotModeCustomName": {
				"title": "Snapshot Mode Custom Name",
				"description": "When 'snapshot.mode' is set as custom, this setting must be set to specify a the name of the custom implementation provided in the 'name()' method. The implementations must implement the 'Snapshotter' interface and is called on each app boot to determine whether to do a snapshot.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"snapshotQueryMode": {
				"title": "Snapshot Query Mode",
				"description": "Controls query used during the snapshot",
				"type": "string",
				"$comment": "group:postgres",
				"default": "select_all"
			},
			"snapshotQueryModeCustomName": {
				"title": "Snapshot Query Mode Custom Name",
				"description": "When 'snapshot.query.mode' is set as custom, this setting must be set to specify a the name of the custom implementation provided in the 'name()' method. The implementations must implement the 'SnapshotterQuery' interface and is called to determine how to build queries during snapshot.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"snapshotSelectStatementOverrides": {
				"title": "Snapshot Select Statement Overrides",
				"description": "This property contains a comma-separated list of fully-qualified tables (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connectors. Select statements for the individual tables are specified in further configuration properties, one for each table, identified by the id 'snapshot.select.statement.overrides.DB_NAME.TABLE_NAME' or 'snapshot.select.statement.overrides.SCHEMA_NAME.TABLE_NAME', respectively. The value of those properties is the select statement to use when retrieving data from the specific table during snapshotting. A possible use case for large append-only tables is setting a specific point where to start (resume) snapshotting, in case a previous snapshotting was interrupted.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"snapshotTablesOrderByRowCount": {
				"title": "Snapshot Tables Order By Row Count",
				"description": "Controls the order in which tables are processed in the initial snapshot. A descending value will order the tables by row count descending. A ascending value will order the tables by row count ascending. A value of disabled (the default) will disable ordering by row count.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "disabled"
			},
			"sourceinfoStructMaker": {
				"title": "Sourceinfo Struct Maker",
				"description": "The name of the SourceInfoStructMaker class that returns SourceInfo schema and struct.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "io.debezium.connector.postgresql.PostgresSourceInfoStructMaker"
			},
			"statusUpdateIntervalMs": {
				"title": "Status Update Interval Ms",
				"description": "Frequency for sending replication connection status updates to the server, given in milliseconds. Defaults to 10 seconds (10,000 ms).",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "10s"
			},
			"streamingDelayMs": {
				"title": "Streaming Delay Ms",
				"description": "A delay period after the snapshot is completed and the streaming begins, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "0ms"
			},
			"tableExcludeList": {
				"title": "Table Exclude List",
				"description": "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring",
				"type": "string",
				"$comment": "group:postgres"
			},
			"tableIgnoreBuiltin": {
				"title": "Table Ignore Builtin",
				"description": "Flag specifying whether built-in tables should be ignored.",
				"type": "boolean",
				"$comment": "group:postgres",
				"default": true
			},
			"tableIncludeList": {
				"title": "Table Include List",
				"description": "The tables for which changes are to be captured",
				"type": "string",
				"$comment": "group:postgres"
			},
			"timePrecisionMode": {
				"title": "Time Precision Mode",
				"description": "Time, date, and timestamps can be represented with different kinds of precisions, including: 'adaptive' (the default) bases the precision of time, date, and timestamp values on the database column's precision; 'adaptive_time_microseconds' like 'adaptive' mode, but TIME fields always use microseconds precision; 'connect' always represents time, date, and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "adaptive"
			},
			"tombstonesOnDelete": {
				"title": "Tombstones On Delete",
				"description": "Whether delete operations should be represented by a delete event and a subsequent tombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
				"type": "boolean",
				"$comment": "group:postgres"
			},
			"topicNamingStrategy": {
				"title": "Topic Naming Strategy",
				"description": "The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "io.debezium.schema.SchemaTopicNamingStrategy"
			},
			"topicPrefix": {
				"title": "Topic Prefix",
				"description": "Topic prefix that identifies and provides a namespace for the particular database server/cluster is capturing changes. The topic prefix should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector. Only alphanumeric characters, hyphens, dots and underscores must be accepted.",
				"type": "string",
				"$comment": "group:postgres"
			},
			"transactionMetadataFactory": {
				"title": "Transaction Metadata Factory",
				"description": "Class to make transaction context & transaction struct/schemas",
				"type": "string",
				"$comment": "group:postgres",
				"default": "io.debezium.pipeline.txmetadata.DefaultTransactionMetadataFactory"
			},
			"unavailableValuePlaceholder": {
				"title": "Unavailable Value Placeholder",
				"description": "Specify the constant that will be provided by Debezium to indicate that the original value is a toasted value not provided by the database. If starts with 'hex:' prefix it is expected that the rest of the string represents hexadecimal encoded octets.",
				"type": "string",
				"$comment": "group:postgres",
				"default": "__debezium_unavailable_value"
			},
			"xminFetchIntervalMs": {
				"title": "Xmin Fetch Interval Ms",
				"description": "Specify how often (in ms) the xmin will be fetched from the replication slot. This xmin value is exposed by the slot which gives a lower bound of where a new replication slot could start from. The lower the value, the more likely this value is to be the current 'true' value, but the bigger the performance cost. The bigger the value, the less likely this value is to be the current 'true' value, but the lower the performance penalty. The default is set to 0 ms, which disables tracking xmin.",
				"type": "string",
				"$comment": "group:postgres",
				"format": "duration",
				"default": "0ms"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"databasePassword",
			"topicPrefix"
		]
	},
	"debezium-sqlserver": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Unique name for the connector. Attempting to register again with the same name will fail.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"additionalProperties": {
				"title": "Additional Properties",
				"description": "Additional properties for debezium components in case they can't be set directly on the camel configurations (e.g: setting Kafka Connect properties needed by Debezium engine, for example setting KafkaOffsetBackingStore), the properties have to be prefixed with additionalProperties.. E.g: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro",
				"type": "object",
				"$comment": "group:common"
			},
			"internalKeyConverter": {
				"title": "Internal Key Converter",
				"description": "The Converter class that should be used to serialize and deserialize key data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"internalValueConverter": {
				"title": "Internal Value Converter",
				"description": "The Converter class that should be used to serialize and deserialize value data for offsets. The default is JSON converter.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.json.JsonConverter"
			},
			"offsetCommitPolicy": {
				"title": "Offset Commit Policy",
				"description": "The name of the Java class of the commit policy. It defines when offsets commit has to be triggered based on the number of events processed and the time elapsed since the last commit. This class must implement the interface 'OffsetCommitPolicy'. The default is a periodic commit policy based upon time intervals.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetCommitTimeoutMs": {
				"title": "Offset Commit Timeout Ms",
				"description": "Maximum number of milliseconds to wait for records to flush and partition offset data to be committed to offset storage before cancelling the process and restoring the offset data to be committed in a future attempt. The default is 5 seconds.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "5000"
			},
			"offsetFlushIntervalMs": {
				"title": "Offset Flush Interval Ms",
				"description": "Interval at which to try committing offsets. The default is 1 minute.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "60000"
			},
			"offsetStorage": {
				"title": "Offset Storage",
				"description": "The name of the Java class that is responsible for persistence of connector offsets.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.connect.storage.FileOffsetBackingStore"
			},
			"offsetStorageFileName": {
				"title": "Offset Storage File Name",
				"description": "Path to file where offsets are to be stored. Required when offset.storage is set to the FileOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offsetStoragePartitions": {
				"title": "Offset Storage Partitions",
				"description": "The number of partitions used when creating the offset storage topic. Required when offset.storage is set to the 'KafkaOffsetBackingStore'.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageReplicationFactor": {
				"title": "Offset Storage Replication Factor",
				"description": "Replication factor used when creating the offset storage topic. Required when offset.storage is set to the KafkaOffsetBackingStore",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"offsetStorageTopic": {
				"title": "Offset Storage Topic",
				"description": "The name of the Kafka topic where offsets are to be stored. Required when offset.storage is set to the KafkaOffsetBackingStore.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"binaryHandlingMode": {
				"title": "Binary Handling Mode",
				"description": "Specify how binary (blob, binary, etc.) columns should be represented in change events, including: 'bytes' represents binary data as byte array (default); 'base64' represents binary data as base64-encoded string; 'base64-url-safe' represents binary data as base64-url-safe-encoded string; 'hex' represents binary data as hex-encoded (base16) string",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "bytes"
			},
			"columnExcludeList": {
				"title": "Column Exclude List",
				"description": "Regular expressions matching columns to exclude from change events",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"columnIncludeList": {
				"title": "Column Include List",
				"description": "Regular expressions matching columns to include in change events",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"columnPropagateSourceType": {
				"title": "Column Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching fully-qualified names of columns that adds the columns original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"converters": {
				"title": "Converters",
				"description": "Optional list of custom converters that would be used instead of default ones. The converters are defined using '.type' config option and configured using options '.'",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"customMetricTags": {
				"title": "Custom Metric Tags",
				"description": "The custom metric tags will accept key-value pairs to customize the MBean object name which should be appended the end of regular name, each key would represent a tag for the MBean object name, and the corresponding value would be the value of that tag the key is. For example: k1=v1,k2=v2",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"databaseHostname": {
				"title": "Database Hostname",
				"description": "Resolvable hostname or IP address of the database server.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"databaseInstance": {
				"title": "Database Instance",
				"description": "The SQL Server instance name",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"databaseNames": {
				"title": "Database Names",
				"description": "The names of the databases from which the connector should capture changes",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"databasePassword": {
				"title": "Database Password",
				"description": "Password of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"databasePort": {
				"title": "Database Port",
				"description": "Port of the database server.",
				"type": "integer",
				"$comment": "group:sqlserver",
				"default": 1433
			},
			"databaseQueryTimeoutMs": {
				"title": "Database Query Timeout Ms",
				"description": "Time to wait for a query to execute, given in milliseconds. Defaults to 600 seconds (600,000 ms); zero means there is no limit.",
				"type": "string",
				"$comment": "group:sqlserver",
				"format": "duration",
				"default": "10m"
			},
			"databaseUser": {
				"title": "Database User",
				"description": "Name of the database user to be used when connecting to the database.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"dataQueryMode": {
				"title": "Data Query Mode",
				"description": "Controls how the connector queries CDC data. The default is 'function', which means the data is queried by means of calling cdc.fn_cdc_get_all_changes_# function. The value of 'direct' makes the connector to query the change tables directly.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "function"
			},
			"datatypePropagateSourceType": {
				"title": "Datatype Propagate Source Type",
				"description": "A comma-separated list of regular expressions matching the database-specific data type names that adds the data type's original type and original length as parameters to the corresponding field schemas in the emitted change records.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"decimalHandlingMode": {
				"title": "Decimal Handling Mode",
				"description": "Specify how DECIMAL and NUMERIC columns should be represented in change events, including: 'precise' (the default) uses java.math.BigDecimal to represent values, which are encoded in the change events using a binary representation and Kafka Connect's 'org.apache.kafka.connect.data.Decimal' type; 'string' uses string to represent values; 'double' represents values using Java's 'double', which may not offer the precision but will be far easier to use in consumers.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "precise"
			},
			"errorsMaxRetries": {
				"title": "Errors Max Retries",
				"description": "The maximum number of retries on connection errors before failing (-1 = no limit, 0 = disabled, 0 = num of retries).",
				"type": "integer",
				"$comment": "group:sqlserver",
				"default": -1
			},
			"eventProcessingFailureHandlingMode": {
				"title": "Event Processing Failure Handling Mode",
				"description": "Specify how failures during processing of events (i.e. when encountering a corrupted event) should be handled, including: 'fail' (the default) an exception indicating the problematic event and its position is raised, causing the connector to be stopped; 'warn' the problematic event and its position will be logged and the event will be skipped; 'ignore' the problematic event will be skipped.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "fail"
			},
			"heartbeatActionQuery": {
				"title": "Heartbeat Action Query",
				"description": "The query executed with every heartbeat.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"heartbeatIntervalMs": {
				"title": "Heartbeat Interval Ms",
				"description": "Length of an interval in milli-seconds in in which the connector periodically sends heartbeat messages to a heartbeat topic. Use 0 to disable heartbeat messages. Disabled by default.",
				"type": "string",
				"$comment": "group:sqlserver",
				"format": "duration",
				"default": "0ms"
			},
			"heartbeatTopicsPrefix": {
				"title": "Heartbeat Topics Prefix",
				"description": "The prefix that is used to name heartbeat topics.Defaults to __debezium-heartbeat.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "__debezium-heartbeat"
			},
			"includeSchemaChanges": {
				"title": "Include Schema Changes",
				"description": "Whether the connector should publish changes in the database schema to a Kafka topic with the same name as the database server ID. Each schema change will be recorded using a key that contains the database name and whose value include logical description of the new schema and optionally the DDL statement(s). The default is 'true'. This is independent of how the connector internally records database schema history.",
				"type": "boolean",
				"$comment": "group:sqlserver",
				"default": true
			},
			"includeSchemaComments": {
				"title": "Include Schema Comments",
				"description": "Whether the connector parse table and column's comment to metadata object. Note: Enable this option will bring the implications on memory usage. The number and size of ColumnImpl objects is what largely impacts how much memory is consumed by the Debezium connectors, and adding a String to each of them can potentially be quite heavy. The default is 'false'.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"incrementalSnapshotAllowSchemaChanges": {
				"title": "Incremental Snapshot Allow Schema Changes",
				"description": "Detect schema change during an incremental snapshot and re-select a current chunk to avoid locking DDLs. Note that changes to a primary key are not supported and can cause incorrect results if performed during an incremental snapshot. Another limitation is that if a schema change affects only columns' default values, then the change won't be detected until the DDL is processed from the binlog stream. This doesn't affect the snapshot events' values, but the schema of snapshot events may have outdated defaults.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"incrementalSnapshotChunkSize": {
				"title": "Incremental Snapshot Chunk Size",
				"description": "The maximum size of chunk (number of documents/rows) for incremental snapshotting",
				"type": "integer",
				"$comment": "group:sqlserver",
				"default": 1024
			},
			"incrementalSnapshotOptionRecompile": {
				"title": "Incremental Snapshot Option Recompile",
				"description": "Add OPTION(RECOMPILE) on each SELECT statement during the incremental snapshot process. This prevents parameter sniffing but can cause CPU pressure on the source database.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"incrementalSnapshotWatermarkingStrategy": {
				"title": "Incremental Snapshot Watermarking Strategy",
				"description": "Specify the strategy used for watermarking during an incremental snapshot: 'insert_insert' both open and close signal is written into signal data collection (default); 'insert_delete' only open signal is written on signal data collection, the close will delete the relative open signal;",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "INSERT_INSERT"
			},
			"maxBatchSize": {
				"title": "Max Batch Size",
				"description": "Maximum size of each batch of source records. Defaults to 2048.",
				"type": "integer",
				"$comment": "group:sqlserver",
				"default": 2048
			},
			"maxIterationTransactions": {
				"title": "Max Iteration Transactions",
				"description": "This property can be used to reduce the connector memory usage footprint when changes are streamed from multiple tables per database.",
				"type": "integer",
				"$comment": "group:sqlserver",
				"default": 500
			},
			"maxQueueSize": {
				"title": "Max Queue Size",
				"description": "Maximum size of the queue for change events read from the database log but not yet recorded or forwarded. Defaults to 8192, and should always be larger than the maximum batch size.",
				"type": "integer",
				"$comment": "group:sqlserver",
				"default": 8192
			},
			"maxQueueSizeInBytes": {
				"title": "Max Queue Size In Bytes",
				"description": "Maximum size of the queue in bytes for change events read from the database log but not yet recorded or forwarded. Defaults to 0. Mean the feature is not enabled",
				"type": "integer",
				"$comment": "group:sqlserver",
				"default": 0
			},
			"messageKeyColumns": {
				"title": "Message Key Columns",
				"description": "A semicolon-separated list of expressions that match fully-qualified tables and column(s) to be used as message key. Each expression must match the pattern ':', where the table names could be defined as (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connector, and the key columns are a comma-separated list of columns representing the custom key. For any table without an explicit key configuration the table's primary key column(s) will be used as message key. Example: dbserver1.inventory.orderlines:orderId,orderLineId;dbserver1.inventory.orders:id",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"notificationEnabledChannels": {
				"title": "Notification Enabled Channels",
				"description": "List of notification channels names that are enabled.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"notificationSinkTopicName": {
				"title": "Notification Sink Topic Name",
				"description": "The name of the topic for the notifications. This is required in case 'sink' is in the list of enabled channels",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"pollIntervalMs": {
				"title": "Poll Interval Ms",
				"description": "Time to wait for new change events to appear after receiving no events, given in milliseconds. Defaults to 500 ms.",
				"type": "string",
				"$comment": "group:sqlserver",
				"format": "duration",
				"default": "500ms"
			},
			"postProcessors": {
				"title": "Post Processors",
				"description": "Optional list of post processors. The processors are defined using '.type' config option and configured using options ''",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"provideTransactionMetadata": {
				"title": "Provide Transaction Metadata",
				"description": "Enables transaction metadata extraction together with event counting",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"retriableRestartConnectorWaitMs": {
				"title": "Retriable Restart Connector Wait Ms",
				"description": "Time to wait before restarting connector after retriable exception occurs. Defaults to 10000ms.",
				"type": "string",
				"$comment": "group:sqlserver",
				"format": "duration",
				"default": "10s"
			},
			"schemaHistoryInternal": {
				"title": "Schema History Internal",
				"description": "The name of the SchemaHistory class that should be used to store and recover database schema changes. The configuration properties for the history are prefixed with the 'schema.history.internal.' string.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "io.debezium.storage.kafka.history.KafkaSchemaHistory"
			},
			"schemaHistoryInternalFileFilename": {
				"title": "Schema History Internal File Filename",
				"description": "The path to the file that will be used to record the database schema history",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"schemaHistoryInternalSkipUnparseableDdl": {
				"title": "Schema History Internal Skip Unparseable Ddl",
				"description": "Controls the action Debezium will take when it meets a DDL statement in binlog, that it cannot parse.By default the connector will stop operating but by changing the setting it can ignore the statements which it cannot parse. If skipping is enabled then Debezium can miss metadata changes.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"schemaHistoryInternalStoreOnlyCapturedDatabasesDdl": {
				"title": "Schema History Internal Store Only Captured Databases Ddl",
				"description": "Controls what DDL will Debezium store in database schema history. By default (false) Debezium will store all incoming DDL statements. If set to true, then only DDL that manipulates a table from captured schema/database will be stored.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"schemaHistoryInternalStoreOnlyCapturedTablesDdl": {
				"title": "Schema History Internal Store Only Captured Tables Ddl",
				"description": "Controls what DDL will Debezium store in database schema history. By default (false) Debezium will store all incoming DDL statements. If set to true, then only DDL that manipulates a captured table will be stored.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"schemaNameAdjustmentMode": {
				"title": "Schema Name Adjustment Mode",
				"description": "Specify how schema names should be adjusted for compatibility with the message converter used by the connector, including: 'avro' replaces the characters that cannot be used in the Avro type name with underscore; 'avro_unicode' replaces the underscore or characters that cannot be used in the Avro type name with corresponding unicode like _uxxxx. Note: _ is an escape sequence like backslash in Java;'none' does not apply any adjustment (default)",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "none"
			},
			"signalDataCollection": {
				"title": "Signal Data Collection",
				"description": "The name of the data collection that is used to send signals/commands to Debezium. Signaling is disabled when not set.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"signalEnabledChannels": {
				"title": "Signal Enabled Channels",
				"description": "List of channels names that are enabled. Source channel is enabled by default",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "source"
			},
			"signalPollIntervalMs": {
				"title": "Signal Poll Interval Ms",
				"description": "Interval for looking for new signals in registered channels, given in milliseconds. Defaults to 5 seconds.",
				"type": "string",
				"$comment": "group:sqlserver",
				"format": "duration",
				"default": "5s"
			},
			"skippedOperations": {
				"title": "Skipped Operations",
				"description": "The comma-separated list of operations to skip during streaming, defined as: 'c' for inserts/create; 'u' for updates; 'd' for deletes, 't' for truncates, and 'none' to indicate nothing skipped. By default, only truncate operations will be skipped.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "t"
			},
			"snapshotDelayMs": {
				"title": "Snapshot Delay Ms",
				"description": "A delay period before a snapshot will begin, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:sqlserver",
				"format": "duration",
				"default": "0ms"
			},
			"snapshotFetchSize": {
				"title": "Snapshot Fetch Size",
				"description": "The maximum number of records that should be loaded into memory while performing a snapshot.",
				"type": "integer",
				"$comment": "group:sqlserver"
			},
			"snapshotIncludeCollectionList": {
				"title": "Snapshot Include Collection List",
				"description": "This setting must be set to specify a list of tables/collections whose snapshot must be taken on creating or restarting the connector.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"snapshotIsolationMode": {
				"title": "Snapshot Isolation Mode",
				"description": "Controls which transaction isolation level is used and how long the connector locks the captured tables. The default is 'repeatable_read', which means that repeatable read isolation level is used. In addition, type of acquired lock during schema snapshot depends on snapshot.locking.mode property. Using a value of 'exclusive' ensures that the connector holds the type of lock specified with snapshot.locking.mode property (and thus prevents any reads and updates) for all captured tables during the entire snapshot duration. When 'snapshot' is specified, connector runs the initial snapshot in SNAPSHOT isolation level, which guarantees snapshot consistency. In addition, neither table nor row-level locks are held. When 'read_committed' is specified, connector runs the initial snapshot in READ COMMITTED isolation level. No long-running locks are taken, so that initial snapshot does not prevent other transactions from updating table rows. Snapshot consistency is not guaranteed.In 'read_uncommitted' mode neither table nor row-level locks are acquired, but connector does not guarantee snapshot consistency.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "repeatable_read"
			},
			"snapshotLockTimeoutMs": {
				"title": "Snapshot Lock Timeout Ms",
				"description": "The maximum number of millis to wait for table locks at the beginning of a snapshot. If locks cannot be acquired in this time frame, the snapshot will be aborted. Defaults to 10 seconds",
				"type": "string",
				"$comment": "group:sqlserver",
				"format": "duration",
				"default": "10s"
			},
			"snapshotMaxThreads": {
				"title": "Snapshot Max Threads",
				"description": "The maximum number of threads used to perform the snapshot. Defaults to 1.",
				"type": "integer",
				"$comment": "group:sqlserver",
				"default": 1
			},
			"snapshotMode": {
				"title": "Snapshot Mode",
				"description": "The criteria for running a snapshot upon startup of the connector. Select one of the following snapshot options: 'initial' (default): If the connector does not detect any offsets for the logical server name, it runs a snapshot that captures the current full state of the configured tables. After the snapshot completes, the connector begins to stream changes from the transaction log.; 'initial_only': The connector performs a snapshot as it does for the 'initial' option, but after the connector completes the snapshot, it stops, and does not stream changes from the transaction log.; 'schema_only': If the connector does not detect any offsets for the logical server name, it runs a snapshot that captures only the schema (table structures), but not any table data. After the snapshot completes, the connector begins to stream changes from the transaction log.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "initial"
			},
			"snapshotModeConfigurationBasedSnapshotData": {
				"title": "Snapshot Mode Configuration Based Snapshot Data",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"snapshotModeConfigurationBasedSnapshotOnDataError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Data Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the data should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"snapshotModeConfigurationBasedSnapshotOnSchemaError": {
				"title": "Snapshot Mode Configuration Based Snapshot On Schema Error",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not in case of error.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"snapshotModeConfigurationBasedSnapshotSchema": {
				"title": "Snapshot Mode Configuration Based Snapshot Schema",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the schema should be snapshotted or not.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"snapshotModeConfigurationBasedStartStream": {
				"title": "Snapshot Mode Configuration Based Start Stream",
				"description": "When 'snapshot.mode' is set as configuration_based, this setting permits to specify whenever the stream should start or not after snapshot.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"snapshotModeCustomName": {
				"title": "Snapshot Mode Custom Name",
				"description": "When 'snapshot.mode' is set as custom, this setting must be set to specify a the name of the custom implementation provided in the 'name()' method. The implementations must implement the 'Snapshotter' interface and is called on each app boot to determine whether to do a snapshot.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"snapshotSelectStatementOverrides": {
				"title": "Snapshot Select Statement Overrides",
				"description": "This property contains a comma-separated list of fully-qualified tables (DB_NAME.TABLE_NAME) or (SCHEMA_NAME.TABLE_NAME), depending on the specific connectors. Select statements for the individual tables are specified in further configuration properties, one for each table, identified by the id 'snapshot.select.statement.overrides.DB_NAME.TABLE_NAME' or 'snapshot.select.statement.overrides.SCHEMA_NAME.TABLE_NAME', respectively. The value of those properties is the select statement to use when retrieving data from the specific table during snapshotting. A possible use case for large append-only tables is setting a specific point where to start (resume) snapshotting, in case a previous snapshotting was interrupted.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"snapshotTablesOrderByRowCount": {
				"title": "Snapshot Tables Order By Row Count",
				"description": "Controls the order in which tables are processed in the initial snapshot. A descending value will order the tables by row count descending. A ascending value will order the tables by row count ascending. A value of disabled (the default) will disable ordering by row count.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "disabled"
			},
			"sourceinfoStructMaker": {
				"title": "Sourceinfo Struct Maker",
				"description": "The name of the SourceInfoStructMaker class that returns SourceInfo schema and struct.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "io.debezium.connector.sqlserver.SqlServerSourceInfoStructMaker"
			},
			"streamingDelayMs": {
				"title": "Streaming Delay Ms",
				"description": "A delay period after the snapshot is completed and the streaming begins, given in milliseconds. Defaults to 0 ms.",
				"type": "string",
				"$comment": "group:sqlserver",
				"format": "duration",
				"default": "0ms"
			},
			"tableExcludeList": {
				"title": "Table Exclude List",
				"description": "A comma-separated list of regular expressions that match the fully-qualified names of tables to be excluded from monitoring",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"tableIgnoreBuiltin": {
				"title": "Table Ignore Builtin",
				"description": "Flag specifying whether built-in tables should be ignored.",
				"type": "boolean",
				"$comment": "group:sqlserver",
				"default": true
			},
			"tableIncludeList": {
				"title": "Table Include List",
				"description": "The tables for which changes are to be captured",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"timePrecisionMode": {
				"title": "Time Precision Mode",
				"description": "Time, date, and timestamps can be represented with different kinds of precisions, including: 'adaptive' (the default) bases the precision of time, date, and timestamp values on the database column's precision; 'adaptive_time_microseconds' like 'adaptive' mode, but TIME fields always use microseconds precision; 'connect' always represents time, date, and timestamp values using Kafka Connect's built-in representations for Time, Date, and Timestamp, which uses millisecond precision regardless of the database columns' precision.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "adaptive"
			},
			"tombstonesOnDelete": {
				"title": "Tombstones On Delete",
				"description": "Whether delete operations should be represented by a delete event and a subsequent tombstone event (true) or only by a delete event (false). Emitting the tombstone event (the default behavior) allows Kafka to completely delete all events pertaining to the given key once the source record got deleted.",
				"type": "boolean",
				"$comment": "group:sqlserver"
			},
			"topicNamingStrategy": {
				"title": "Topic Naming Strategy",
				"description": "The name of the TopicNamingStrategy class that should be used to determine the topic name for data change, schema change, transaction, heartbeat event etc.",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "io.debezium.schema.SchemaTopicNamingStrategy"
			},
			"topicPrefix": {
				"title": "Topic Prefix",
				"description": "Topic prefix that identifies and provides a namespace for the particular database server/cluster is capturing changes. The topic prefix should be unique across all other connectors, since it is used as a prefix for all Kafka topic names that receive events emitted by this connector. Only alphanumeric characters, hyphens, dots and underscores must be accepted.",
				"type": "string",
				"$comment": "group:sqlserver"
			},
			"transactionMetadataFactory": {
				"title": "Transaction Metadata Factory",
				"description": "Class to make transaction context & transaction struct/schemas",
				"type": "string",
				"$comment": "group:sqlserver",
				"default": "io.debezium.pipeline.txmetadata.DefaultTransactionMetadataFactory"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"databasePassword",
			"topicPrefix"
		]
	},
	"dfdl": {
		"properties": {
			"schemaUri": {
				"title": "Schema Uri",
				"description": "The path to the DFDL schema file.",
				"type": "string",
				"$comment": "group:producer"
			},
			"parseDirection": {
				"title": "Parse Direction",
				"description": "Transform direction. Either PARSE or UNPARSE",
				"type": "string",
				"enum": [
					"PARSE",
					"UNPARSE"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.dfdl.ParseDirection",
				"default": "PARSE"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"rootElement": {
				"title": "Root Element",
				"description": "The root element name of the schema to use. If not specified, the first root element in the schema will be used.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"rootNamespace": {
				"title": "Root Namespace",
				"description": "The root namespace of the schema to use.",
				"type": "string",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"schemaUri"
		]
	},
	"dhis2": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "API operation (e.g., get)",
				"type": "string",
				"enum": [
					"POST",
					"RESOURCE_TABLES",
					"GET",
					"DELETE",
					"PUT"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.dhis2.internal.Dhis2ApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "Subject of the API operation (e.g., resource)",
				"type": "string",
				"$comment": "group:common"
			},
			"baseApiUrl": {
				"title": "Base Api Url",
				"description": "DHIS2 server base API URL (e.g., https://play.dhis2.org/2.39.1.1/api)",
				"type": "string",
				"$comment": "group:common"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"client": {
				"title": "Client",
				"description": "References a user-defined org.hisp.dhis.integration.sdk.api.Dhis2Client. This option is mutually exclusive to the baseApiUrl, username, password, and personalAccessToken options",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.hisp.dhis.integration.sdk.api.Dhis2Client"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password of the DHIS2 username",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"personalAccessToken": {
				"title": "Personal Access Token",
				"description": "Personal access token to authenticate with DHIS2. This option is mutually exclusive to username and password",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username of the DHIS2 user to operate as",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"digitalocean": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "The operation to perform to the given resource.",
				"type": "string",
				"enum": [
					"create",
					"update",
					"delete",
					"list",
					"ownList",
					"get",
					"listBackups",
					"listActions",
					"listNeighbors",
					"listSnapshots",
					"listKernels",
					"listAllNeighbors",
					"enableBackups",
					"disableBackups",
					"reboot",
					"powerCycle",
					"shutdown",
					"powerOn",
					"powerOff",
					"restore",
					"resetPassword",
					"resize",
					"rebuild",
					"rename",
					"changeKernel",
					"enableIpv6",
					"enablePrivateNetworking",
					"takeSnapshot",
					"transfer",
					"convert",
					"attach",
					"detach",
					"assign",
					"unassign",
					"tag",
					"untag"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.digitalocean.constants.DigitalOceanOperations"
			},
			"page": {
				"title": "Page",
				"description": "Use for pagination. Force the page number.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "1"
			},
			"perPage": {
				"title": "Per Page",
				"description": "Use for pagination. Set the number of item per request. The maximum number of results per page is 200.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "25"
			},
			"resource": {
				"title": "Resource",
				"description": "The DigitalOcean resource type on which perform the operation.",
				"type": "string",
				"enum": [
					"account",
					"actions",
					"blockStorages",
					"droplets",
					"mages",
					"snapshots",
					"keys",
					"regions",
					"sizes",
					"floatingIPs",
					"tags"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.digitalocean.constants.DigitalOceanResources"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"digitalOceanClient": {
				"title": "Digital Ocean Client",
				"description": "To use a existing configured DigitalOceanClient as client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.myjeeva.digitalocean.impl.DigitalOceanClient"
			},
			"httpProxyHost": {
				"title": "Http Proxy Host",
				"description": "Set a proxy host if needed",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPassword": {
				"title": "Http Proxy Password",
				"description": "Set a proxy password if needed",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"httpProxyPort": {
				"title": "Http Proxy Port",
				"description": "Set a proxy port if needed",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"httpProxyUser": {
				"title": "Http Proxy User",
				"description": "Set a proxy host if needed",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"oAuthToken": {
				"title": "OAuth Token",
				"description": "DigitalOcean OAuth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resource"
		]
	},
	"direct": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of direct endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"block": {
				"title": "Block",
				"description": "If sending a message to a direct endpoint which has no active consumer, then we can tell the producer to block and wait for the consumer to become active.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"failIfNoConsumers": {
				"title": "Fail If No Consumers",
				"description": "Whether the producer should fail by throwing an exception, when sending to a DIRECT endpoint with no active consumers.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"timeout": {
				"title": "Timeout",
				"description": "The timeout value to use if block is enabled.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Whether synchronous processing is forced. If enabled, then the producer thread will be forced to wait until the message has been completed before the same thread will continue processing. If disabled, the default, then the producer thread may be freed and can do other work while the message is continued processed by other threads (reactive).",
				"type": "boolean",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"disruptor": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of queue",
				"type": "string",
				"$comment": "group:common"
			},
			"size": {
				"title": "Size",
				"description": "The maximum capacity of the Disruptors ringbuffer Will be effectively increased to the nearest power of two. Notice: Mind if you use this option, then it's the first endpoint being created with the queue name that determines the size. To make sure all endpoints use the same size, then configure the size option on all of them, or the first endpoint being created.",
				"type": "integer",
				"$comment": "group:common",
				"default": 1024
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Number of concurrent threads processing exchanges.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"multipleConsumers": {
				"title": "Multiple Consumers",
				"description": "Specifies whether multiple consumers are allowed. If enabled, you can use Disruptor for Publish-Subscribe messaging. That is, you can send a message to the queue and have each consumer receive a copy of the message. When enabled, this option should be specified on every consumer endpoint.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"waitStrategy": {
				"title": "Wait Strategy",
				"description": "Defines the strategy used by consumer threads to wait on new exchanges to be published. The options allowed are:Blocking, Sleeping, BusySpin and Yielding.",
				"type": "string",
				"enum": [
					"Blocking",
					"Sleeping",
					"BusySpin",
					"Yielding"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.disruptor.DisruptorWaitStrategy",
				"default": "Blocking"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"blockWhenFull": {
				"title": "Block When Full",
				"description": "Whether a thread that sends messages to a full Disruptor will block until the ringbuffer's capacity is no longer exhausted. By default, the calling thread will block and wait until the message can be accepted. By disabling this option, an exception will be thrown stating that the queue is full.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"producerType": {
				"title": "Producer Type",
				"description": "Defines the producers allowed on the Disruptor. The options allowed are: Multi to allow multiple producers and Single to enable certain optimizations only allowed when one concurrent producer (on one thread or otherwise synchronized) is active.",
				"type": "string",
				"enum": [
					"Single",
					"Multi"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.disruptor.DisruptorProducerType",
				"default": "Multi"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Timeout (in milliseconds) before a producer will stop waiting for an asynchronous task to complete. You can disable timeout by using 0 or a negative value.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "30000"
			},
			"waitForTaskToComplete": {
				"title": "Wait For Task To Complete",
				"description": "Option to specify whether the caller should wait for the async task to complete or not before continuing. The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory. The last value, IfReplyExpected, will only wait if the message is Request Reply based.",
				"type": "string",
				"enum": [
					"Never",
					"IfReplyExpected",
					"Always"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.WaitForTaskToComplete",
				"default": "IfReplyExpected"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"disruptor-vm": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of queue",
				"type": "string",
				"$comment": "group:common"
			},
			"size": {
				"title": "Size",
				"description": "The maximum capacity of the Disruptors ringbuffer Will be effectively increased to the nearest power of two. Notice: Mind if you use this option, then it's the first endpoint being created with the queue name that determines the size. To make sure all endpoints use the same size, then configure the size option on all of them, or the first endpoint being created.",
				"type": "integer",
				"$comment": "group:common",
				"default": 1024
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Number of concurrent threads processing exchanges.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"multipleConsumers": {
				"title": "Multiple Consumers",
				"description": "Specifies whether multiple consumers are allowed. If enabled, you can use Disruptor for Publish-Subscribe messaging. That is, you can send a message to the queue and have each consumer receive a copy of the message. When enabled, this option should be specified on every consumer endpoint.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"waitStrategy": {
				"title": "Wait Strategy",
				"description": "Defines the strategy used by consumer threads to wait on new exchanges to be published. The options allowed are:Blocking, Sleeping, BusySpin and Yielding.",
				"type": "string",
				"enum": [
					"Blocking",
					"Sleeping",
					"BusySpin",
					"Yielding"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.disruptor.DisruptorWaitStrategy",
				"default": "Blocking"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"blockWhenFull": {
				"title": "Block When Full",
				"description": "Whether a thread that sends messages to a full Disruptor will block until the ringbuffer's capacity is no longer exhausted. By default, the calling thread will block and wait until the message can be accepted. By disabling this option, an exception will be thrown stating that the queue is full.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"producerType": {
				"title": "Producer Type",
				"description": "Defines the producers allowed on the Disruptor. The options allowed are: Multi to allow multiple producers and Single to enable certain optimizations only allowed when one concurrent producer (on one thread or otherwise synchronized) is active.",
				"type": "string",
				"enum": [
					"Single",
					"Multi"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.disruptor.DisruptorProducerType",
				"default": "Multi"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Timeout (in milliseconds) before a producer will stop waiting for an asynchronous task to complete. You can disable timeout by using 0 or a negative value.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "30000"
			},
			"waitForTaskToComplete": {
				"title": "Wait For Task To Complete",
				"description": "Option to specify whether the caller should wait for the async task to complete or not before continuing. The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory. The last value, IfReplyExpected, will only wait if the message is Request Reply based.",
				"type": "string",
				"enum": [
					"Never",
					"IfReplyExpected",
					"Always"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.WaitForTaskToComplete",
				"default": "IfReplyExpected"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"djl": {
		"properties": {
			"application": {
				"title": "Application",
				"description": "Application name",
				"type": "string",
				"$comment": "group:producer"
			},
			"artifactId": {
				"title": "Artifact Id",
				"description": "Model Artifact",
				"type": "string",
				"$comment": "group:producer"
			},
			"model": {
				"title": "Model",
				"description": "Model",
				"type": "string",
				"$comment": "group:producer"
			},
			"showProgress": {
				"title": "Show Progress",
				"description": "Show progress while loading zoo models. This parameter takes effect only with zoo models",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"translator": {
				"title": "Translator",
				"description": "Translator",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"application"
		]
	},
	"dns": {
		"properties": {
			"dnsType": {
				"title": "Dns Type",
				"description": "The type of the lookup.",
				"type": "string",
				"enum": [
					"dig",
					"ip",
					"lookup",
					"wikipedia"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.dns.DnsType"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"dnsType"
		]
	},
	"docker": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "Which operation to use",
				"type": "string",
				"enum": [
					"events",
					"stats",
					"auth",
					"info",
					"ping",
					"version",
					"imagebuild",
					"imagecreate",
					"imageinspect",
					"imagelist",
					"imagepull",
					"imagepush",
					"imageremove",
					"imagesearch",
					"imagetag",
					"containerattach",
					"containercommit",
					"containercopyfile",
					"containercreate",
					"containerdiff",
					"inspectcontainer",
					"containerkill",
					"containerlist",
					"containerlog",
					"containerpause",
					"containerrestart",
					"containerremove",
					"containerstart",
					"containerstop",
					"containertop",
					"containerunpause",
					"containerwait",
					"execcreate",
					"execstart",
					"networkconnect",
					"networkcreate",
					"networkremove"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.docker.DockerOperation"
			},
			"email": {
				"title": "Email",
				"description": "Email address associated with the user",
				"type": "string",
				"$comment": "group:common"
			},
			"host": {
				"title": "Host",
				"description": "Docker host",
				"type": "string",
				"$comment": "group:common",
				"default": "localhost"
			},
			"port": {
				"title": "Port",
				"description": "Docker port",
				"type": "integer",
				"$comment": "group:common",
				"default": "2375"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "Request timeout for response (in seconds)",
				"type": "integer",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"cmdExecFactory": {
				"title": "Cmd Exec Factory",
				"description": "The fully qualified class name of the DockerCmdExecFactory implementation to use",
				"type": "string",
				"$comment": "group:advanced",
				"default": "com.github.dockerjava.netty.NettyDockerCmdExecFactory"
			},
			"followRedirectFilter": {
				"title": "Follow Redirect Filter",
				"description": "Whether to follow redirect filter",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"loggingFilter": {
				"title": "Logging Filter",
				"description": "Whether to use logging filter",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"maxPerRouteConnections": {
				"title": "Max Per Route Connections",
				"description": "Maximum route connections",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "100"
			},
			"maxTotalConnections": {
				"title": "Max Total Connections",
				"description": "Maximum total connections",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "100"
			},
			"parameters": {
				"title": "Parameters",
				"description": "Additional configuration parameters as key/value pairs",
				"type": "object",
				"$comment": "group:advanced"
			},
			"serverAddress": {
				"title": "Server Address",
				"description": "Server address for docker registry.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "https://index.docker.io/v1/"
			},
			"socket": {
				"title": "Socket",
				"description": "Socket connection mode",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"certPath": {
				"title": "Cert Path",
				"description": "Location containing the SSL certificate chain",
				"type": "string",
				"$comment": "group:security"
			},
			"password": {
				"title": "Password",
				"description": "Password to authenticate with",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secure": {
				"title": "Secure",
				"description": "Use HTTPS communication",
				"type": "boolean",
				"$comment": "group:security"
			},
			"tlsVerify": {
				"title": "Tls Verify",
				"description": "Check TLS",
				"type": "boolean",
				"$comment": "group:security"
			},
			"username": {
				"title": "Username",
				"description": "User name to authenticate with",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation",
			"host"
		]
	},
	"drill": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Host name or IP address",
				"type": "string",
				"$comment": "group:producer"
			},
			"clusterId": {
				"title": "Cluster Id",
				"description": "Cluster ID https://drill.apache.org/docs/using-the-jdbc-driver/#determining-the-cluster-id",
				"type": "string",
				"$comment": "group:producer"
			},
			"directory": {
				"title": "Directory",
				"description": "Drill directory",
				"type": "string",
				"$comment": "group:producer"
			},
			"mode": {
				"title": "Mode",
				"description": "Connection mode: zk: Zookeeper drillbit: Drillbit direct connection https://drill.apache.org/docs/using-the-jdbc-driver/",
				"type": "string",
				"enum": [
					"ZK",
					"DRILLBIT"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.drill.DrillConnectionMode",
				"default": "ZK"
			},
			"port": {
				"title": "Port",
				"description": "Port number",
				"type": "integer",
				"$comment": "group:producer",
				"default": "2181"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"dropbox": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "The specific action (typically is a CRUD action) to perform on Dropbox remote folder.",
				"type": "string",
				"enum": [
					"put",
					"del",
					"search",
					"get",
					"move"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.dropbox.util.DropboxOperation"
			},
			"clientIdentifier": {
				"title": "Client Identifier",
				"description": "Name of the app registered to make API requests",
				"type": "string",
				"$comment": "group:common"
			},
			"query": {
				"title": "Query",
				"description": "A space-separated list of sub-strings to search for. A file matches only if it contains all the sub-strings. If this option is not set, all files will be matched.",
				"type": "string",
				"$comment": "group:common"
			},
			"remotePath": {
				"title": "Remote Path",
				"description": "Original file or folder to move",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"localPath": {
				"title": "Local Path",
				"description": "Optional folder or file to upload on Dropbox from the local filesystem. If this option has not been configured then the message body is used as the content to upload.",
				"type": "string",
				"$comment": "group:producer"
			},
			"newRemotePath": {
				"title": "New Remote Path",
				"description": "Destination file or folder",
				"type": "string",
				"$comment": "group:producer"
			},
			"uploadMode": {
				"title": "Upload Mode",
				"description": "Which mode to upload. in case of add the new file will be renamed if a file with the same name already exists on dropbox. in case of force if a file with the same name already exists on dropbox, this will be overwritten.",
				"type": "string",
				"enum": [
					"add",
					"force"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.dropbox.util.DropboxUploadMode"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"client": {
				"title": "Client",
				"description": "To use an existing DbxClient instance as Dropbox client.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.dropbox.core.v2.DbxClientV2"
			},
			"accessToken": {
				"title": "Access Token",
				"description": "The access token to make API requests for a specific Dropbox user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"apiKey": {
				"title": "Api Key",
				"description": "The apiKey to make API requests for a specific Dropbox user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"apiSecret": {
				"title": "Api Secret",
				"description": "The apiSecret to make API requests for a specific Dropbox user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"expireIn": {
				"title": "Expire In",
				"description": "The expire time to access token for a specific Dropbox user",
				"type": "integer",
				"$comment": "group:security",
				"format": "password"
			},
			"refreshToken": {
				"title": "Refresh Token",
				"description": "The refresh token to refresh the access token for a specific Dropbox user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation",
			"accessToken",
			"apiKey",
			"apiSecret",
			"expireIn",
			"refreshToken"
		]
	},
	"dynamic-router": {
		"properties": {
			"channel": {
				"title": "Channel",
				"description": "Channel for the Dynamic Router. For example, if the Dynamic Router URI is dynamic-router://test, then the channel is test. Channels are a way of keeping routing participants, their rules, and exchanges logically separate from the participants, rules, and exchanges on other channels. This can be seen as analogous to VLANs in networking.",
				"type": "string",
				"$comment": "group:producer"
			},
			"aggregationStrategy": {
				"title": "Aggregation Strategy",
				"description": "Refers to an AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast. By default, Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy.",
				"type": "string",
				"$comment": "group:common"
			},
			"aggregationStrategyBean": {
				"title": "Aggregation Strategy Bean",
				"description": "Refers to an AggregationStrategy to be used to assemble the replies from the multicasts, into a single outgoing message from the Multicast. By default, Camel will use the last reply as the outgoing message. You can also use a POJO as the AggregationStrategy.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.AggregationStrategy"
			},
			"aggregationStrategyMethodAllowNull": {
				"title": "Aggregation Strategy Method Allow Null",
				"description": "If this option is false then the aggregate method is not used if there was no data to enrich. If this option is true then null values is used as the oldExchange (when no data to enrich), when using POJOs as the AggregationStrategy",
				"type": "boolean",
				"$comment": "group:common"
			},
			"aggregationStrategyMethodName": {
				"title": "Aggregation Strategy Method Name",
				"description": "You can use a POJO as the AggregationStrategy. This refers to the name of the method that aggregates the exchanges.",
				"type": "string",
				"$comment": "group:common"
			},
			"cacheSize": {
				"title": "Cache Size",
				"description": "When caching producer endpoints, this is the size of the cache. Default is 100.",
				"type": "integer",
				"$comment": "group:common",
				"default": 100
			},
			"executorService": {
				"title": "Executor Service",
				"description": "Refers to a custom Thread Pool to be used for parallel processing. Notice that, if you set this option, then parallel processing is automatically implied, and you do not have to enable that option in addition to this one.",
				"type": "string",
				"$comment": "group:common"
			},
			"executorServiceBean": {
				"title": "Executor Service Bean",
				"description": "Refers to a custom Thread Pool to be used for parallel processing. Notice that, if you set this option, then parallel processing is automatically implied, and you do not have to enable that option in addition to this one.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.util.concurrent.ExecutorService"
			},
			"ignoreInvalidEndpoints": {
				"title": "Ignore Invalid Endpoints",
				"description": "Ignore the invalid endpoint exception when attempting to create a producer with an invalid endpoint.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"onPrepare": {
				"title": "On Prepare",
				"description": "Uses the Processor when preparing the org.apache.camel.Exchange to be sent. This can be used to deep-clone messages that should be sent, or to provide any custom logic that is needed before the exchange is sent. This is the name of a bean in the registry.",
				"type": "string",
				"$comment": "group:common"
			},
			"onPrepareProcessor": {
				"title": "On Prepare Processor",
				"description": "Uses the Processor when preparing the org.apache.camel.Exchange to be sent. This can be used to deep-clone messages that should be sent, or to provide any custom logic that is needed before the exchange is sent. This is a Processor instance.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.Processor"
			},
			"parallelAggregate": {
				"title": "Parallel Aggregate",
				"description": "If enabled then the aggregate method on AggregationStrategy can be called concurrently. Notice that this would require the implementation of AggregationStrategy to be implemented as thread-safe. By default, this is false, meaning that Camel synchronizes the call to the aggregate method. Though, in some use-cases, this can be used to archive higher performance when the AggregationStrategy is implemented as thread-safe.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"parallelProcessing": {
				"title": "Parallel Processing",
				"description": "If enabled, then sending via multicast occurs concurrently. Note that the caller thread will still wait until all messages have been fully processed before it continues. It is only the sending and processing of the replies from the multicast recipients that happens concurrently. When parallel processing is enabled, then the Camel routing engine will continue processing using the last used thread from the parallel thread pool. However, if you want to use the original thread that called the multicast, then make sure to enable the synchronous option as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"recipientMode": {
				"title": "Recipient Mode",
				"description": "Recipient mode: firstMatch or allMatch",
				"type": "string",
				"enum": [
					"firstMatch",
					"allMatch"
				],
				"$comment": "group:common",
				"default": "firstMatch"
			},
			"shareUnitOfWork": {
				"title": "Share Unit Of Work",
				"description": "Shares the org.apache.camel.spi.UnitOfWork with the parent and each of the sub messages. Multicast will, by default, not share a unit of work between the parent exchange and each multicasted exchange. This means each sub exchange has its own individual unit of work.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"stopOnException": {
				"title": "Stop On Exception",
				"description": "Will stop further processing if an exception or failure occurred during processing of an org.apache.camel.Exchange and the caused exception will be thrown. Will also stop if processing the exchange failed (has a fault message), or an exception was thrown and handled by the error handler (such as using onException). In all situations, the multicast will stop further processing. This is the same behavior as in the pipeline that is used by the routing engine. The default behavior is to not stop, but to continue processing until the end.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"streaming": {
				"title": "Streaming",
				"description": "If enabled, then Camel will process replies out-of-order (e.g., in the order they come back). If disabled, Camel will process replies in the same order as defined by the multicast.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used. When enabled then the same thread is used to continue routing after the multicast is complete, even if parallel processing is enabled.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets a total timeout specified in milliseconds, when using parallel processing. If the Multicast has not been able to send and process all replies within the given timeframe, then the timeout triggers and the Multicast breaks out and continues. Notice that, if you provide a TimeoutAwareAggregationStrategy, then the timeout method is invoked before breaking out. If the timeout is reached with running tasks still remaining, certain tasks (for which it is difficult for Camel to shut down in a graceful manner) may continue to run. So use this option with a bit of care.",
				"type": "integer",
				"$comment": "group:common",
				"default": -1
			},
			"warnDroppedMessage": {
				"title": "Warn Dropped Message",
				"description": "Flag to log a warning if no predicates match for an exchange.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"dynamic-router-control": {
		"properties": {
			"controlAction": {
				"title": "Control Action",
				"description": "Control action",
				"type": "string",
				"enum": [
					"subscribe",
					"unsubscribe",
					"update",
					"list",
					"statistics"
				],
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"destinationUri": {
				"title": "Destination Uri",
				"description": "The destination URI for exchanges that match.",
				"type": "string",
				"$comment": "group:control"
			},
			"expressionLanguage": {
				"title": "Expression Language",
				"description": "The subscription predicate language.",
				"type": "string",
				"$comment": "group:control",
				"default": "simple"
			},
			"predicate": {
				"title": "Predicate",
				"description": "The subscription predicate.",
				"type": "string",
				"$comment": "group:control"
			},
			"predicateBean": {
				"title": "Predicate Bean",
				"description": "A Predicate instance in the registry.",
				"type": "string",
				"$comment": "group:control",
				"format": "bean:org.apache.camel.Predicate"
			},
			"priority": {
				"title": "Priority",
				"description": "The subscription priority.",
				"type": "integer",
				"$comment": "group:control"
			},
			"subscribeChannel": {
				"title": "Subscribe Channel",
				"description": "The channel to subscribe to",
				"type": "string",
				"$comment": "group:control"
			},
			"subscriptionId": {
				"title": "Subscription Id",
				"description": "The subscription ID; if unspecified, one will be assigned and returned.",
				"type": "string",
				"$comment": "group:control"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"controlAction"
		]
	},
	"ehcache": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "the cache name",
				"type": "string",
				"$comment": "group:common"
			},
			"cacheManager": {
				"title": "Cache Manager",
				"description": "The cache manager",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.ehcache.CacheManager"
			},
			"cacheManagerConfiguration": {
				"title": "Cache Manager Configuration",
				"description": "The cache manager configuration",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.ehcache.config.Configuration"
			},
			"configurationUri": {
				"title": "Configuration Uri",
				"description": "URI pointing to the Ehcache XML configuration file's location",
				"type": "string",
				"$comment": "group:common"
			},
			"createCacheIfNotExist": {
				"title": "Create Cache If Not Exist",
				"description": "Configure if a cache need to be created if it does exist or can't be pre-configured.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"eventFiring": {
				"title": "Event Firing",
				"description": "Set the delivery mode (synchronous, asynchronous)",
				"type": "string",
				"enum": [
					"ASYNCHRONOUS",
					"SYNCHRONOUS"
				],
				"$comment": "group:consumer",
				"format": "bean:org.ehcache.event.EventFiring",
				"default": "ASYNCHRONOUS"
			},
			"eventOrdering": {
				"title": "Event Ordering",
				"description": "Set the delivery mode (ordered, unordered)",
				"type": "string",
				"enum": [
					"UNORDERED",
					"ORDERED"
				],
				"$comment": "group:consumer",
				"format": "bean:org.ehcache.event.EventOrdering",
				"default": "ORDERED"
			},
			"eventTypes": {
				"title": "Event Types",
				"description": "Set the type of events to listen for (EVICTED,EXPIRED,REMOVED,CREATED,UPDATED). You can specify multiple entries separated by comma.",
				"type": "string",
				"enum": [
					"EVICTED",
					"EXPIRED",
					"REMOVED",
					"CREATED",
					"UPDATED"
				],
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"action": {
				"title": "Action",
				"description": "To configure the default cache action. If an action is set in the message header, then the operation from the header takes precedence.",
				"type": "string",
				"$comment": "group:producer"
			},
			"key": {
				"title": "Key",
				"description": "To configure the default action key. If a key is set in the message header, then the key from the header takes precedence.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"configuration": {
				"title": "Configuration",
				"description": "The default cache configuration to be used to create caches.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.ehcache.config.CacheConfiguration"
			},
			"configurations": {
				"title": "Configurations",
				"description": "A map of cache configuration to be used to create caches.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"keyType": {
				"title": "Key Type",
				"description": "The cache key type, default java.lang.Object",
				"type": "string",
				"$comment": "group:advanced"
			},
			"valueType": {
				"title": "Value Type",
				"description": "The cache value type, default java.lang.Object",
				"type": "string",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"elasticsearch": {
		"properties": {
			"clusterName": {
				"title": "Cluster Name",
				"description": "Name of the cluster",
				"type": "string",
				"$comment": "group:producer"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "The time in ms to wait before connection will time out.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Disconnect after it finish calling the producer",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"enableDocumentOnlyMode": {
				"title": "Enable Document Only Mode",
				"description": "Indicates whether the body of the message contains only documents. By default, it is set to false to be able to do the same requests as what the Document API supports (see https://www.elastic.co/guide/en/elasticsearch/reference/current/docs.html for more details). To ease the migration of routes based on the legacy component camel-elasticsearch-rest, you should consider enabling the mode, especially if your routes do update operations.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"from": {
				"title": "From",
				"description": "Starting index of the response.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"hostAddresses": {
				"title": "Host Addresses",
				"description": "Comma separated list with ip:port formatted remote transport addresses to use.",
				"type": "string",
				"$comment": "group:producer"
			},
			"indexName": {
				"title": "Index Name",
				"description": "The name of the index to act against",
				"type": "string",
				"$comment": "group:producer"
			},
			"maxRetryTimeout": {
				"title": "Max Retry Timeout",
				"description": "The time in ms before retry",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"operation": {
				"title": "Operation",
				"description": "What operation to perform",
				"type": "string",
				"enum": [
					"Index",
					"Update",
					"Bulk",
					"GetById",
					"MultiGet",
					"MultiSearch",
					"Delete",
					"DeleteIndex",
					"Search",
					"Exists",
					"Ping"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.es.ElasticsearchOperation"
			},
			"scrollKeepAliveMs": {
				"title": "Scroll Keep Alive Ms",
				"description": "Time in ms during which elasticsearch will keep search context alive",
				"type": "integer",
				"$comment": "group:producer",
				"default": 60000
			},
			"size": {
				"title": "Size",
				"description": "Size of the response.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"socketTimeout": {
				"title": "Socket Timeout",
				"description": "The timeout in ms to wait before the socket will time out.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"useScroll": {
				"title": "Use Scroll",
				"description": "Enable scroll usage",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"waitForActiveShards": {
				"title": "Wait For Active Shards",
				"description": "Index creation waits for the write consistency number of shards to be available",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"documentClass": {
				"title": "Document Class",
				"description": "The class to use when deserializing the documents.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "ObjectNode"
			},
			"enableSniffer": {
				"title": "Enable Sniffer",
				"description": "Enable automatically discover nodes from a running Elasticsearch cluster. If this option is used in conjunction with Spring Boot, then it's managed by the Spring Boot configuration (see: Disable Sniffer in Spring Boot).",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"sniffAfterFailureDelay": {
				"title": "Sniff After Failure Delay",
				"description": "The delay of a sniff execution scheduled after a failure (in milliseconds)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 60000
			},
			"snifferInterval": {
				"title": "Sniffer Interval",
				"description": "The interval between consecutive ordinary sniff executions in milliseconds. Will be honoured when sniffOnFailure is disabled or when there are no failures between consecutive sniff executions",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 300000
			},
			"certificatePath": {
				"title": "Certificate Path",
				"description": "The certificate that can be used to access the ES Cluster. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:security"
			},
			"enableSSL": {
				"title": "Enable SSL",
				"description": "Enable SSL",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"clusterName"
		]
	},
	"elasticsearch-rest-client": {
		"properties": {
			"clusterName": {
				"title": "Cluster Name",
				"description": "Cluster Name",
				"type": "string",
				"$comment": "group:producer"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"hostAddressesList": {
				"title": "Host Addresses List",
				"description": "List of host Addresses, multiple hosts can be separated by comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"indexName": {
				"title": "Index Name",
				"description": "Index Name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Operation",
				"type": "string",
				"enum": [
					"INDEX_OR_UPDATE",
					"GET_BY_ID",
					"DELETE",
					"CREATE_INDEX",
					"DELETE_INDEX",
					"SEARCH"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.elasticsearch.rest.client.ElasticsearchRestClientOperation"
			},
			"socketTimeout": {
				"title": "Socket Timeout",
				"description": "Socket timeout",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"enableSniffer": {
				"title": "Enable Sniffer",
				"description": "Enabling Sniffer",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"restClient": {
				"title": "Rest Client",
				"description": "Rest Client of type org.elasticsearch.client.RestClient. This is only for advanced usage",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.elasticsearch.client.RestClient"
			},
			"sniffAfterFailureDelay": {
				"title": "Sniff After Failure Delay",
				"description": "Sniffer after failure delay (in millis)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 60000
			},
			"snifferInterval": {
				"title": "Sniffer Interval",
				"description": "Sniffer interval (in millis)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 60000
			},
			"certificatePath": {
				"title": "Certificate Path",
				"description": "Certificate Path",
				"type": "string",
				"$comment": "group:security"
			},
			"password": {
				"title": "Password",
				"description": "Password",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"user": {
				"title": "User",
				"description": "Username",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"clusterName"
		]
	},
	"exec": {
		"properties": {
			"executable": {
				"title": "Executable",
				"description": "Sets the executable to be executed. The executable must not be empty or null.",
				"type": "string",
				"$comment": "group:producer"
			},
			"args": {
				"title": "Args",
				"description": "The arguments may be one or many whitespace-separated tokens.",
				"type": "string",
				"$comment": "group:producer"
			},
			"binding": {
				"title": "Binding",
				"description": "A reference to a org.apache.commons.exec.ExecBinding in the Registry.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.exec.ExecBinding"
			},
			"commandExecutor": {
				"title": "Command Executor",
				"description": "A reference to a org.apache.commons.exec.ExecCommandExecutor in the Registry that customizes the command execution. The default command executor utilizes the commons-exec library, which adds a shutdown hook for every executed command.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.exec.ExecCommandExecutor"
			},
			"commandLogLevel": {
				"title": "Command Log Level",
				"description": "Logging level to be used for commands during execution. The default value is DEBUG. Possible values are TRACE, DEBUG, INFO, WARN, ERROR or OFF. (Values of ExecCommandLogLevelType enum)",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"exitValues": {
				"title": "Exit Values",
				"description": "The exit values of successful executions. If the process exits with another value, an exception is raised. Comma-separated list of exit values. And empty list (the default) sets no expected exit values and disables the check.",
				"type": "string",
				"$comment": "group:producer"
			},
			"outFile": {
				"title": "Out File",
				"description": "The name of a file, created by the executable, that should be considered as its output. If no outFile is set, the standard output (stdout) of the executable will be used instead.",
				"type": "string",
				"$comment": "group:producer"
			},
			"timeout": {
				"title": "Timeout",
				"description": "The timeout, in milliseconds, after which the executable should be terminated. If execution has not completed within the timeout, the component will send a termination request.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"useStderrOnEmptyStdout": {
				"title": "Use Stderr On Empty Stdout",
				"description": "A boolean indicating that when stdout is empty, this component will populate the Camel Message Body with stderr. This behavior is disabled (false) by default.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"workingDir": {
				"title": "Working Dir",
				"description": "The directory in which the command should be executed. If null, the working directory of the current process will be used.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"executable"
		]
	},
	"fhir": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"CAPABILITIES",
					"CREATE",
					"DELETE",
					"HISTORY",
					"LOAD_PAGE",
					"META",
					"OPERATION",
					"PATCH",
					"READ",
					"SEARCH",
					"TRANSACTION",
					"UPDATE",
					"VALIDATE"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.fhir.internal.FhirApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"$comment": "group:common"
			},
			"encoding": {
				"title": "Encoding",
				"description": "Encoding to use for all request",
				"type": "string",
				"enum": [
					"JSON",
					"XML"
				],
				"$comment": "group:common"
			},
			"fhirVersion": {
				"title": "Fhir Version",
				"description": "The FHIR Version to use",
				"type": "string",
				"enum": [
					"DSTU2",
					"DSTU2_HL7ORG",
					"DSTU2_1",
					"DSTU3",
					"R4",
					"R4B",
					"R5"
				],
				"$comment": "group:common",
				"default": "R4"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"log": {
				"title": "Log",
				"description": "Will log every requests and responses",
				"type": "boolean",
				"$comment": "group:common"
			},
			"prettyPrint": {
				"title": "Pretty Print",
				"description": "Pretty print all request",
				"type": "boolean",
				"$comment": "group:common"
			},
			"serverUrl": {
				"title": "Server Url",
				"description": "The FHIR server base URL",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"client": {
				"title": "Client",
				"description": "To use the custom client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:ca.uhn.fhir.rest.client.api.IGenericClient"
			},
			"clientFactory": {
				"title": "Client Factory",
				"description": "To use the custom client factory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:ca.uhn.fhir.rest.client.api.IRestfulClientFactory"
			},
			"compress": {
				"title": "Compress",
				"description": "Compresses outgoing (POST/PUT) contents to the GZIP format",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "How long to try and establish the initial TCP connection (in ms)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "10000"
			},
			"deferModelScanning": {
				"title": "Defer Model Scanning",
				"description": "When this option is set, model classes will not be scanned for children until the child list for the given type is actually accessed.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"fhirContext": {
				"title": "Fhir Context",
				"description": "FhirContext is an expensive object to create. To avoid creating multiple instances, it can be set directly.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:ca.uhn.fhir.context.FhirContext"
			},
			"forceConformanceCheck": {
				"title": "Force Conformance Check",
				"description": "Force conformance check",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"sessionCookie": {
				"title": "Session Cookie",
				"description": "HTTP session cookie to add to every request",
				"type": "string",
				"$comment": "group:advanced"
			},
			"socketTimeout": {
				"title": "Socket Timeout",
				"description": "How long to block for individual read/write operations (in ms)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "10000"
			},
			"summary": {
				"title": "Summary",
				"description": "Request that the server modify the response using the _summary param",
				"type": "string",
				"enum": [
					"COUNT",
					"TEXT",
					"DATA",
					"TRUE",
					"FALSE"
				],
				"$comment": "group:advanced"
			},
			"validationMode": {
				"title": "Validation Mode",
				"description": "When should Camel validate the FHIR Server's conformance statement",
				"type": "string",
				"enum": [
					"NEVER",
					"ONCE"
				],
				"$comment": "group:advanced",
				"default": "ONCE"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "The proxy host",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPassword": {
				"title": "Proxy Password",
				"description": "The proxy password",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "The proxy port",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyUser": {
				"title": "Proxy User",
				"description": "The proxy username",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "OAuth access token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to use for basic authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to use for basic authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"file": {
		"properties": {
			"directoryName": {
				"title": "Directory Name",
				"description": "The starting directory",
				"type": "string",
				"$comment": "group:common"
			},
			"charset": {
				"title": "Charset",
				"description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
				"type": "string",
				"$comment": "group:common"
			},
			"doneFileName": {
				"title": "Done File Name",
				"description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
				"type": "string",
				"$comment": "group:common"
			},
			"fileName": {
				"title": "File Name",
				"description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
				"type": "string",
				"$comment": "group:common"
			},
			"delete": {
				"title": "Delete",
				"description": "If true, the file will be deleted after it is processed successfully.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveFailed": {
				"title": "Move Failed",
				"description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"noop": {
				"title": "Noop",
				"description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"preMove": {
				"title": "Pre Move",
				"description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"preSort": {
				"title": "Pre Sort",
				"description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"recursive": {
				"title": "Recursive",
				"description": "If a directory, will look for files in all the sub-directories as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"directoryMustExist": {
				"title": "Directory Must Exist",
				"description": "Similar to the startingDirectoryMustExist option, but this applies during polling (after starting the consumer).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"extendedAttributes": {
				"title": "Extended Attributes",
				"description": "To define which file attributes of interest. Like posix:permissions,posix:owner,basic:lastAccessTime, it supports basic wildcard like posix:, basic:lastAccessTime",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"includeHiddenDirs": {
				"title": "Include Hidden Dirs",
				"description": "Whether to accept hidden directories. Directories which names starts with dot are regarded as a hidden directory, and by default are not included. Set this option to true to include hidden directories in the file consumer.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"includeHiddenFiles": {
				"title": "Include Hidden Files",
				"description": "Whether to accept hidden files. Files which names starts with dot is regarded as a hidden file, and by default not included. Set this option to true to include hidden files in the file consumer.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"inProgressRepository": {
				"title": "In Progress Repository",
				"description": "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"localWorkDirectory": {
				"title": "Local Work Directory",
				"description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"onCompletionExceptionHandler": {
				"title": "On Completion Exception Handler",
				"description": "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"probeContentType": {
				"title": "Probe Content Type",
				"description": "Whether to enable probing of the content type. If enable then the consumer uses Files#probeContentType(java.nio.file.Path) to determine the content-type of the file, and store that as a header with key Exchange#FILE_CONTENT_TYPE on the Message.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"processStrategy": {
				"title": "Process Strategy",
				"description": "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.file.GenericFileProcessStrategy<java.io.File>"
			},
			"startingDirectoryMustExist": {
				"title": "Starting Directory Must Exist",
				"description": "Whether the starting directory must exist. Mind that the autoCreate option is default enabled, which means the starting directory is normally auto created if it doesn't exist. You can disable autoCreate and enable this to ensure the starting directory must exist. Will throw an exception if the directory doesn't exist.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"startingDirectoryMustHaveAccess": {
				"title": "Starting Directory Must Have Access",
				"description": "Whether the starting directory has access permissions. Mind that the startingDirectoryMustExist parameter must be set to true to verify that the directory exists. Will throw an exception if the directory doesn't have read and write permissions.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"appendChars": {
				"title": "Append Chars",
				"description": "Used to append characters (text) after writing files. This can for example be used to add new lines or other separators when writing and appending new files or existing files. To specify new-line (slash-n or slash-r) or tab (slash-t) characters then escape with an extra slash, eg slash-slash-n.",
				"type": "string",
				"$comment": "group:producer"
			},
			"checksumFileAlgorithm": {
				"title": "Checksum File Algorithm",
				"description": "If provided, then Camel will write a checksum file when the original file has been written. The checksum file will contain the checksum created with the provided algorithm for the original file. The checksum file will always be written in the same folder as the original file.",
				"type": "string",
				"enum": [
					"MD2",
					"MD5",
					"SHA_1",
					"SHA_224",
					"SHA_256",
					"SHA_384",
					"SHA_512",
					"SHA_512_224",
					"SHA_512_256",
					"SHA3_224",
					"SHA3_256",
					"SHA3_384",
					"SHA3_512"
				],
				"$comment": "group:producer"
			},
			"fileExist": {
				"title": "File Exist",
				"description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
				"type": "string",
				"enum": [
					"Override",
					"Append",
					"Fail",
					"Ignore",
					"Move",
					"TryRename"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.file.GenericFileExist",
				"default": "Override"
			},
			"flatten": {
				"title": "Flatten",
				"description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"jailStartingDirectory": {
				"title": "Jail Starting Directory",
				"description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"moveExisting": {
				"title": "Move Existing",
				"description": "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempFileName": {
				"title": "Temp File Name",
				"description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempPrefix": {
				"title": "Temp Prefix",
				"description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"chmod": {
				"title": "Chmod",
				"description": "Specify the file permissions that are sent by the producer, the chmod value must be between 000 and 777; If there is a leading digit like in 0755, we will ignore it.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"chmodDirectory": {
				"title": "Chmod Directory",
				"description": "Specify the directory permissions used when the producer creates missing directories, the chmod value must be between 000 and 777; If there is a leading digit like in 0755, we will ignore it.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"eagerDeleteTargetFile": {
				"title": "Eager Delete Target File",
				"description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"forceWrites": {
				"title": "Force Writes",
				"description": "Whether to force syncing, writes to the file system. You can turn this off if you do not want this level of guarantee, for example, if writing to logs / audit logs etc.; this would yield better performance.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"keepLastModified": {
				"title": "Keep Last Modified",
				"description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"moveExistingFileStrategy": {
				"title": "Move Existing File Strategy",
				"description": "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.file.strategy.FileMoveExistingStrategy"
			},
			"autoCreate": {
				"title": "Auto Create",
				"description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"autoCreateStepwise": {
				"title": "Auto Create Stepwise",
				"description": "When auto-creating directories should each subdirectory be created one at a time. This may be needed due to security issues on some file-shares.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"bufferSize": {
				"title": "Buffer Size",
				"description": "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 131072
			},
			"copyAndDeleteOnRenameFail": {
				"title": "Copy And Delete On Rename Fail",
				"description": "Whether to fall back and do a copy and delete file, in case the file could not be renamed directly. This option is not available for the FTP component.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"renameUsingCopy": {
				"title": "Rename Using Copy",
				"description": "Perform rename operations using a copy and delete strategy. This is primarily used in environments where the regular rename operation is unreliable (e.g., across different file systems or networks). This option takes precedence over the copyAndDeleteOnRenameFail parameter that will automatically fall back to the copy and delete strategy, but only after additional delays.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"antExclude": {
				"title": "Ant Exclude",
				"description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"antFilterCaseSensitive": {
				"title": "Ant Filter Case Sensitive",
				"description": "Sets case sensitive flag on ant filter.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"antInclude": {
				"title": "Ant Include",
				"description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"eagerMaxMessagesPerPoll": {
				"title": "Eager Max Messages Per Poll",
				"description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"exclude": {
				"title": "Exclude",
				"description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"excludeExt": {
				"title": "Exclude Ext",
				"description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"filter": {
				"title": "Filter",
				"description": "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.component.file.GenericFileFilter<java.io.File>"
			},
			"filterDirectory": {
				"title": "Filter Directory",
				"description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
				"type": "string",
				"$comment": "group:filter"
			},
			"filterFile": {
				"title": "Filter File",
				"description": "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotent": {
				"title": "Idempotent",
				"description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:filter"
			},
			"idempotentEager": {
				"title": "Idempotent Eager",
				"description": "Sets whether to eagerly add the filename to the idempotent repository or wait until the exchange is complete.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"idempotentKey": {
				"title": "Idempotent Key",
				"description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryIdempotentRepository if none is specified and idempotent is true.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"include": {
				"title": "Include",
				"description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"includeExt": {
				"title": "Include Ext",
				"description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"maxDepth": {
				"title": "Max Depth",
				"description": "The maximum depth to traverse when recursively processing a directory.",
				"type": "integer",
				"$comment": "group:filter",
				"default": 2147483647
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"minDepth": {
				"title": "Min Depth",
				"description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"move": {
				"title": "Move",
				"description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
				"type": "string",
				"$comment": "group:filter"
			},
			"exclusiveReadLockStrategy": {
				"title": "Exclusive Read Lock Strategy",
				"description": "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
				"type": "string",
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy<java.io.File>"
			},
			"readLock": {
				"title": "Read Lock",
				"description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
				"type": "string",
				"enum": [
					"none",
					"markerFile",
					"fileLock",
					"rename",
					"changed",
					"idempotent",
					"idempotent-changed",
					"idempotent-rename"
				],
				"$comment": "group:lock",
				"default": "none"
			},
			"readLockCheckInterval": {
				"title": "Read Lock Check Interval",
				"description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1000
			},
			"readLockDeleteOrphanLockFiles": {
				"title": "Read Lock Delete Orphan Lock Files",
				"description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockIdempotentReleaseAsync": {
				"title": "Read Lock Idempotent Release Async",
				"description": "Whether the delayed release task should be synchronous or asynchronous. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "boolean",
				"$comment": "group:lock"
			},
			"readLockIdempotentReleaseAsyncPoolSize": {
				"title": "Read Lock Idempotent Release Async Pool Size",
				"description": "The number of threads in the scheduled thread pool when using asynchronous release tasks. Using a default of 1 core threads should be sufficient in almost all use-cases, only set this to a higher value if either updating the idempotent repository is slow, or there are a lot of files to process. This option is not in-use if you use a shared thread pool by configuring the readLockIdempotentReleaseExecutorService option. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "integer",
				"$comment": "group:lock"
			},
			"readLockIdempotentReleaseDelay": {
				"title": "Read Lock Idempotent Release Delay",
				"description": "Whether to delay the release task for a period of millis. This can be used to delay the release tasks to expand the window when a file is regarded as read-locked, in an active/active cluster scenario with a shared idempotent repository, to ensure other nodes cannot potentially scan and acquire the same file, due to race-conditions. By expanding the time-window of the release tasks helps prevents these situations. Note delaying is only needed if you have configured readLockRemoveOnCommit to true.",
				"type": "integer",
				"$comment": "group:lock"
			},
			"readLockIdempotentReleaseExecutorService": {
				"title": "Read Lock Idempotent Release Executor Service",
				"description": "To use a custom and shared thread pool for asynchronous release tasks. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "string",
				"$comment": "group:lock",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"readLockLoggingLevel": {
				"title": "Read Lock Logging Level",
				"description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"readLockMarkerFile": {
				"title": "Read Lock Marker File",
				"description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockMinAge": {
				"title": "Read Lock Min Age",
				"description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 0
			},
			"readLockMinLength": {
				"title": "Read Lock Min Length",
				"description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1
			},
			"readLockRemoveOnCommit": {
				"title": "Read Lock Remove On Commit",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "boolean",
				"$comment": "group:lock"
			},
			"readLockRemoveOnRollback": {
				"title": "Read Lock Remove On Rollback",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockTimeout": {
				"title": "Read Lock Timeout",
				"description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 10000
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"shuffle": {
				"title": "Shuffle",
				"description": "To shuffle the list of files (sort in random order)",
				"type": "boolean",
				"$comment": "group:sort"
			},
			"sortBy": {
				"title": "Sort By",
				"description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
				"type": "string",
				"$comment": "group:sort"
			},
			"sorter": {
				"title": "Sorter",
				"description": "Pluggable sorter as a java.util.Comparator class.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:java.util.Comparator<org.apache.camel.component.file.GenericFile<java.io.File>>"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"directoryName"
		]
	},
	"file-watch": {
		"properties": {
			"path": {
				"title": "Path",
				"description": "Path of directory to consume events from.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"antInclude": {
				"title": "Ant Include",
				"description": "ANT style pattern to match files. The file is matched against path relative to endpoint path. Pattern must be also relative (not starting with slash)",
				"type": "string",
				"$comment": "group:consumer",
				"default": "**"
			},
			"autoCreate": {
				"title": "Auto Create",
				"description": "Auto create directory if does not exist.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"events": {
				"title": "Events",
				"description": "Comma separated list of events to watch. Possible values: CREATE,MODIFY,DELETE",
				"type": "string",
				"$comment": "group:consumer",
				"default": "CREATE,MODIFY,DELETE"
			},
			"recursive": {
				"title": "Recursive",
				"description": "Watch recursive in current and child directories (including newly created directories).",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"useFileHashing": {
				"title": "Use File Hashing",
				"description": "Enables or disables file hashing to detect duplicate events. If you disable this, you can get some events multiple times on some platforms and JDKs. Check java.nio.file.WatchService limitations for your target platform.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "The number of concurrent consumers. Increase this value, if your route is slow to prevent buffering in queue.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"fileHasher": {
				"title": "File Hasher",
				"description": "Reference to io.methvin.watcher.hashing.FileHasher. This prevents emitting duplicate events on some platforms. For working with large files and if you dont need detect multiple modifications per second per file, use #lastModifiedTimeFileHasher. You can also provide custom implementation in registry.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.methvin.watcher.hashing.FileHasher",
				"default": "#murmur3FFileHasher"
			},
			"pollThreads": {
				"title": "Poll Threads",
				"description": "The number of threads polling WatchService. Increase this value, if you see OVERFLOW messages in log.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"queueSize": {
				"title": "Queue Size",
				"description": "Maximum size of queue between WatchService and consumer. Unbounded by default.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 2147483647
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"path"
		]
	},
	"flatpack": {
		"properties": {
			"type": {
				"title": "Type",
				"description": "Whether to use fixed or delimiter",
				"type": "string",
				"enum": [
					"fixed",
					"delim"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.flatpack.FlatpackType",
				"default": "delim"
			},
			"resourceUri": {
				"title": "Resource Uri",
				"description": "URL for loading the flatpack mapping file from classpath or file system",
				"type": "string",
				"$comment": "group:common"
			},
			"allowShortLines": {
				"title": "Allow Short Lines",
				"description": "Allows for lines to be shorter than expected and ignores the extra characters",
				"type": "boolean",
				"$comment": "group:common"
			},
			"delimiter": {
				"title": "Delimiter",
				"description": "The default character delimiter for delimited files.",
				"type": "string",
				"$comment": "group:common",
				"default": ","
			},
			"ignoreExtraColumns": {
				"title": "Ignore Extra Columns",
				"description": "Allows for lines to be longer than expected and ignores the extra characters",
				"type": "boolean",
				"$comment": "group:common"
			},
			"ignoreFirstRecord": {
				"title": "Ignore First Record",
				"description": "Whether the first line is ignored for delimited files (for the column headers).",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"splitRows": {
				"title": "Split Rows",
				"description": "Sets the Component to send each row as a separate exchange once parsed",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"textQualifier": {
				"title": "Text Qualifier",
				"description": "The text qualifier for delimited files.",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"flink": {
		"properties": {
			"endpointType": {
				"title": "Endpoint Type",
				"description": "Type of the endpoint (dataset, datastream).",
				"type": "string",
				"enum": [
					"dataset",
					"datastream"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.flink.EndpointType"
			},
			"collect": {
				"title": "Collect",
				"description": "Indicates if results should be collected or counted.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"dataSet": {
				"title": "Data Set",
				"description": "DataSet to compute against.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.flink.api.java.DataSet"
			},
			"dataSetCallback": {
				"title": "Data Set Callback",
				"description": "Function performing action against a DataSet.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.flink.DataSetCallback"
			},
			"dataStream": {
				"title": "Data Stream",
				"description": "DataStream to compute against.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.flink.streaming.api.datastream.DataStream"
			},
			"dataStreamCallback": {
				"title": "Data Stream Callback",
				"description": "Function performing action against a DataStream.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.flink.DataStreamCallback"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"endpointType"
		]
	},
	"flowable": {
		"properties": {
			"channelKey": {
				"title": "Channel Key",
				"description": "The channel key",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"channelKey"
		]
	},
	"fop": {
		"properties": {
			"outputType": {
				"title": "Output Type",
				"description": "The primary output format is PDF but other output formats are also supported.",
				"type": "string",
				"enum": [
					"pdf",
					"ps",
					"pcl",
					"png",
					"jpeg",
					"svg",
					"xml",
					"mif",
					"rtf",
					"txt"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.fop.FopOutputType"
			},
			"fopFactory": {
				"title": "Fop Factory",
				"description": "Allows to use a custom configured or implementation of org.apache.fop.apps.FopFactory.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.fop.apps.FopFactory"
			},
			"userConfigURL": {
				"title": "User Config URL",
				"description": "The location of a configuration file which can be loaded from classpath or file system.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"outputType"
		]
	},
	"freemarker": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"configuration": {
				"title": "Configuration",
				"description": "Sets the Freemarker configuration to use",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:freemarker.template.Configuration"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"encoding": {
				"title": "Encoding",
				"description": "Sets the encoding to be used for loading the template file.",
				"type": "string",
				"$comment": "group:producer"
			},
			"templateUpdateDelay": {
				"title": "Template Update Delay",
				"description": "Number of seconds the loaded template resource will remain in the cache.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"ftp": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname of the FTP server",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port of the FTP server",
				"type": "integer",
				"$comment": "group:common"
			},
			"directoryName": {
				"title": "Directory Name",
				"description": "The starting directory",
				"type": "string",
				"$comment": "group:common"
			},
			"binary": {
				"title": "Binary",
				"description": "Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).",
				"type": "boolean",
				"$comment": "group:common"
			},
			"charset": {
				"title": "Charset",
				"description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
				"type": "string",
				"$comment": "group:common"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"doneFileName": {
				"title": "Done File Name",
				"description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
				"type": "string",
				"$comment": "group:common"
			},
			"fileName": {
				"title": "File Name",
				"description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
				"type": "string",
				"$comment": "group:common"
			},
			"passiveMode": {
				"title": "Passive Mode",
				"description": "Sets passive mode connections. Default is active mode connections.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"separator": {
				"title": "Separator",
				"description": "Sets the path separator to be used. UNIX = Uses unix style path separator Windows = Uses windows style path separator Auto = (is default) Use existing path separator in file name",
				"type": "string",
				"enum": [
					"UNIX",
					"Windows",
					"Auto"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.file.remote.RemoteFileConfiguration.PathSeparator",
				"default": "UNIX"
			},
			"transferLoggingIntervalSeconds": {
				"title": "Transfer Logging Interval Seconds",
				"description": "Configures the interval in seconds to use when logging the progress of upload and download operations that are in-flight. This is used for logging progress when operations take a longer time.",
				"type": "integer",
				"$comment": "group:common",
				"default": 5
			},
			"transferLoggingLevel": {
				"title": "Transfer Logging Level",
				"description": "Configure the logging level to use when logging the progress of upload and download operations.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"transferLoggingVerbose": {
				"title": "Transfer Logging Verbose",
				"description": "Configures whether perform verbose (fine-grained) logging of the progress of upload and download operations.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"fastExistsCheck": {
				"title": "Fast Exists Check",
				"description": "If set this option to be true, camel-ftp will use the list file directly to check if the file exists. Since some FTP server may not support to list the file directly, if the option is false, camel-ftp will use the old way to list the directory and check if the file exists. This option also influences readLock=changed to control whether it performs a fast check to update file information or not. This can be used to speed up the process if the FTP server has a lot of files.",
				"type": "boolean",
				"$comment": "group:common (advanced)"
			},
			"delete": {
				"title": "Delete",
				"description": "If true, the file will be deleted after it is processed successfully.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveFailed": {
				"title": "Move Failed",
				"description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"noop": {
				"title": "Noop",
				"description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"preMove": {
				"title": "Pre Move",
				"description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"preSort": {
				"title": "Pre Sort",
				"description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"recursive": {
				"title": "Recursive",
				"description": "If a directory, will look for files in all the sub-directories as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"resumeDownload": {
				"title": "Resume Download",
				"description": "Configures whether resume download is enabled. This must be supported by the FTP server (almost all FTP servers support it). In addition, the options localWorkDirectory must be configured so downloaded files are stored in a local directory, and the option binary must be enabled, which is required to support resuming of downloads.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"streamDownload": {
				"title": "Stream Download",
				"description": "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"download": {
				"title": "Download",
				"description": "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"handleDirectoryParserAbsoluteResult": {
				"title": "Handle Directory Parser Absolute Result",
				"description": "Allows you to set how the consumer will handle subfolders and files in the path if the directory parser results in with absolute paths. The reason for this is that some FTP servers may return file names with absolute paths, and if so, then the FTP component needs to handle this by converting the returned path into a relative path.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"ignoreFileNotFoundOrPermissionError": {
				"title": "Ignore File Not Found Or Permission Error",
				"description": "Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error. By default when a directory or file does not exist or insufficient permission, then an exception is thrown. Setting this option to true allows to ignore that instead.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"inProgressRepository": {
				"title": "In Progress Repository",
				"description": "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"localWorkDirectory": {
				"title": "Local Work Directory",
				"description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"onCompletionExceptionHandler": {
				"title": "On Completion Exception Handler",
				"description": "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"processStrategy": {
				"title": "Process Strategy",
				"description": "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.file.GenericFileProcessStrategy<org.apache.commons.net.ftp.FTPFile>"
			},
			"throwExceptionOnConnectFailed": {
				"title": "Throw Exception On Connect Failed",
				"description": "Should an exception be thrown if connection failed (exhausted)By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"useList": {
				"title": "Use List",
				"description": "Whether to allow using LIST command when downloading a file. Default is true. In some use cases you may want to download a specific file and are not allowed to use the LIST command, and therefore you can set this option to false. Notice when using this option, then the specific file to download does not include meta-data information such as file size, timestamp, permissions etc, because those information is only possible to retrieve when LIST command is in use.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"checksumFileAlgorithm": {
				"title": "Checksum File Algorithm",
				"description": "If provided, then Camel will write a checksum file when the original file has been written. The checksum file will contain the checksum created with the provided algorithm for the original file. The checksum file will always be written in the same folder as the original file.",
				"type": "string",
				"enum": [
					"MD2",
					"MD5",
					"SHA_1",
					"SHA_224",
					"SHA_256",
					"SHA_384",
					"SHA_512",
					"SHA_512_224",
					"SHA_512_256",
					"SHA3_224",
					"SHA3_256",
					"SHA3_384",
					"SHA3_512"
				],
				"$comment": "group:producer"
			},
			"fileExist": {
				"title": "File Exist",
				"description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
				"type": "string",
				"enum": [
					"Override",
					"Append",
					"Fail",
					"Ignore",
					"Move",
					"TryRename"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.file.GenericFileExist",
				"default": "Override"
			},
			"flatten": {
				"title": "Flatten",
				"description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"jailStartingDirectory": {
				"title": "Jail Starting Directory",
				"description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"moveExisting": {
				"title": "Move Existing",
				"description": "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempFileName": {
				"title": "Temp File Name",
				"description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempPrefix": {
				"title": "Temp Prefix",
				"description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"chmod": {
				"title": "Chmod",
				"description": "Allows you to set chmod on the stored file. For example, chmod=640.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"disconnectOnBatchComplete": {
				"title": "Disconnect On Batch Complete",
				"description": "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"eagerDeleteTargetFile": {
				"title": "Eager Delete Target File",
				"description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"keepLastModified": {
				"title": "Keep Last Modified",
				"description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"moveExistingFileStrategy": {
				"title": "Move Existing File Strategy",
				"description": "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.file.strategy.FileMoveExistingStrategy"
			},
			"sendNoop": {
				"title": "Send Noop",
				"description": "Whether to send a noop command as a pre-write check before uploading files to the FTP server. This is enabled by default as a validation of the connection is still valid, which allows to silently re-connect to be able to upload the file. However if this causes problems, you can turn this option off.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"activePortRange": {
				"title": "Active Port Range",
				"description": "Set the client side port range in active mode. The syntax is: minPort-maxPort Both port numbers are inclusive, e.g., 10000-19999 to include all 1xxxx ports.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"autoCreate": {
				"title": "Auto Create",
				"description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"bufferSize": {
				"title": "Buffer Size",
				"description": "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 131072
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "10000"
			},
			"ftpClient": {
				"title": "Ftp Client",
				"description": "To use a custom instance of FTPClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.commons.net.ftp.FTPClient"
			},
			"ftpClientConfig": {
				"title": "Ftp Client Config",
				"description": "To use a custom instance of FTPClientConfig to configure the FTP client the endpoint should use.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.commons.net.ftp.FTPClientConfig"
			},
			"ftpClientConfigParameters": {
				"title": "Ftp Client Config Parameters",
				"description": "Used by FtpComponent to provide additional parameters for the FTPClientConfig",
				"type": "object",
				"$comment": "group:advanced"
			},
			"ftpClientParameters": {
				"title": "Ftp Client Parameters",
				"description": "Used by FtpComponent to provide additional parameters for the FTPClient",
				"type": "object",
				"$comment": "group:advanced"
			},
			"maximumReconnectAttempts": {
				"title": "Maximum Reconnect Attempts",
				"description": "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"reconnectDelay": {
				"title": "Reconnect Delay",
				"description": "Delay in millis Camel will wait before performing a reconnect attempt.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"siteCommand": {
				"title": "Site Command",
				"description": "Sets optional site command(s) to be executed after successful login. Multiple site commands can be separated using a new line character.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"soTimeout": {
				"title": "So Timeout",
				"description": "Sets the so timeout FTP and FTPS Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "300000"
			},
			"stepwise": {
				"title": "Stepwise",
				"description": "Sets whether we should stepwise change directories while traversing file structures when downloading files, or as well when uploading a file to a directory. You can disable this if you for example are in a situation where you cannot change directory on the FTP server due security reasons. Stepwise cannot be used together with streamDownload.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets the data timeout for waiting for reply Used only by FTPClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "30000"
			},
			"antExclude": {
				"title": "Ant Exclude",
				"description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"antFilterCaseSensitive": {
				"title": "Ant Filter Case Sensitive",
				"description": "Sets case sensitive flag on ant filter.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"antInclude": {
				"title": "Ant Include",
				"description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"eagerMaxMessagesPerPoll": {
				"title": "Eager Max Messages Per Poll",
				"description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"exclude": {
				"title": "Exclude",
				"description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"excludeExt": {
				"title": "Exclude Ext",
				"description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"filter": {
				"title": "Filter",
				"description": "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.component.file.GenericFileFilter<org.apache.commons.net.ftp.FTPFile>"
			},
			"filterDirectory": {
				"title": "Filter Directory",
				"description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
				"type": "string",
				"$comment": "group:filter"
			},
			"filterFile": {
				"title": "Filter File",
				"description": "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotent": {
				"title": "Idempotent",
				"description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:filter"
			},
			"idempotentEager": {
				"title": "Idempotent Eager",
				"description": "Sets whether to eagerly add the filename to the idempotent repository or wait until the exchange is complete.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"idempotentKey": {
				"title": "Idempotent Key",
				"description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryIdempotentRepository if none is specified and idempotent is true.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"include": {
				"title": "Include",
				"description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"includeExt": {
				"title": "Include Ext",
				"description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"maxDepth": {
				"title": "Max Depth",
				"description": "The maximum depth to traverse when recursively processing a directory.",
				"type": "integer",
				"$comment": "group:filter",
				"default": 2147483647
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"minDepth": {
				"title": "Min Depth",
				"description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"move": {
				"title": "Move",
				"description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
				"type": "string",
				"$comment": "group:filter"
			},
			"exclusiveReadLockStrategy": {
				"title": "Exclusive Read Lock Strategy",
				"description": "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
				"type": "string",
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy<org.apache.commons.net.ftp.FTPFile>"
			},
			"readLock": {
				"title": "Read Lock",
				"description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
				"type": "string",
				"enum": [
					"none",
					"markerFile",
					"fileLock",
					"rename",
					"changed",
					"idempotent",
					"idempotent-changed",
					"idempotent-rename"
				],
				"$comment": "group:lock",
				"default": "none"
			},
			"readLockCheckInterval": {
				"title": "Read Lock Check Interval",
				"description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1000
			},
			"readLockDeleteOrphanLockFiles": {
				"title": "Read Lock Delete Orphan Lock Files",
				"description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockLoggingLevel": {
				"title": "Read Lock Logging Level",
				"description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"readLockMarkerFile": {
				"title": "Read Lock Marker File",
				"description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockMinAge": {
				"title": "Read Lock Min Age",
				"description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 0
			},
			"readLockMinLength": {
				"title": "Read Lock Min Length",
				"description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1
			},
			"readLockRemoveOnCommit": {
				"title": "Read Lock Remove On Commit",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "boolean",
				"$comment": "group:lock"
			},
			"readLockRemoveOnRollback": {
				"title": "Read Lock Remove On Rollback",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockTimeout": {
				"title": "Read Lock Timeout",
				"description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 10000
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"account": {
				"title": "Account",
				"description": "Account to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"shuffle": {
				"title": "Shuffle",
				"description": "To shuffle the list of files (sort in random order)",
				"type": "boolean",
				"$comment": "group:sort"
			},
			"sortBy": {
				"title": "Sort By",
				"description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
				"type": "string",
				"$comment": "group:sort"
			},
			"sorter": {
				"title": "Sorter",
				"description": "Pluggable sorter as a java.util.Comparator class.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:java.util.Comparator<org.apache.camel.component.file.GenericFile<org.apache.commons.net.ftp.FTPFile>>"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"ftps": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname of the FTP server",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port of the FTP server",
				"type": "integer",
				"$comment": "group:common"
			},
			"directoryName": {
				"title": "Directory Name",
				"description": "The starting directory",
				"type": "string",
				"$comment": "group:common"
			},
			"binary": {
				"title": "Binary",
				"description": "Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).",
				"type": "boolean",
				"$comment": "group:common"
			},
			"charset": {
				"title": "Charset",
				"description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
				"type": "string",
				"$comment": "group:common"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"doneFileName": {
				"title": "Done File Name",
				"description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
				"type": "string",
				"$comment": "group:common"
			},
			"fileName": {
				"title": "File Name",
				"description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
				"type": "string",
				"$comment": "group:common"
			},
			"passiveMode": {
				"title": "Passive Mode",
				"description": "Sets passive mode connections. Default is active mode connections.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"separator": {
				"title": "Separator",
				"description": "Sets the path separator to be used. UNIX = Uses unix style path separator Windows = Uses windows style path separator Auto = (is default) Use existing path separator in file name",
				"type": "string",
				"enum": [
					"UNIX",
					"Windows",
					"Auto"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.file.remote.RemoteFileConfiguration.PathSeparator",
				"default": "UNIX"
			},
			"transferLoggingIntervalSeconds": {
				"title": "Transfer Logging Interval Seconds",
				"description": "Configures the interval in seconds to use when logging the progress of upload and download operations that are in-flight. This is used for logging progress when operations take a longer time.",
				"type": "integer",
				"$comment": "group:common",
				"default": 5
			},
			"transferLoggingLevel": {
				"title": "Transfer Logging Level",
				"description": "Configure the logging level to use when logging the progress of upload and download operations.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"transferLoggingVerbose": {
				"title": "Transfer Logging Verbose",
				"description": "Configures whether perform verbose (fine-grained) logging of the progress of upload and download operations.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"fastExistsCheck": {
				"title": "Fast Exists Check",
				"description": "If set this option to be true, camel-ftp will use the list file directly to check if the file exists. Since some FTP server may not support to list the file directly, if the option is false, camel-ftp will use the old way to list the directory and check if the file exists. This option also influences readLock=changed to control whether it performs a fast check to update file information or not. This can be used to speed up the process if the FTP server has a lot of files.",
				"type": "boolean",
				"$comment": "group:common (advanced)"
			},
			"delete": {
				"title": "Delete",
				"description": "If true, the file will be deleted after it is processed successfully.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveFailed": {
				"title": "Move Failed",
				"description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"noop": {
				"title": "Noop",
				"description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"preMove": {
				"title": "Pre Move",
				"description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"preSort": {
				"title": "Pre Sort",
				"description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"recursive": {
				"title": "Recursive",
				"description": "If a directory, will look for files in all the sub-directories as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"resumeDownload": {
				"title": "Resume Download",
				"description": "Configures whether resume download is enabled. This must be supported by the FTP server (almost all FTP servers support it). In addition, the options localWorkDirectory must be configured so downloaded files are stored in a local directory, and the option binary must be enabled, which is required to support resuming of downloads.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"streamDownload": {
				"title": "Stream Download",
				"description": "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"download": {
				"title": "Download",
				"description": "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"handleDirectoryParserAbsoluteResult": {
				"title": "Handle Directory Parser Absolute Result",
				"description": "Allows you to set how the consumer will handle subfolders and files in the path if the directory parser results in with absolute paths. The reason for this is that some FTP servers may return file names with absolute paths, and if so, then the FTP component needs to handle this by converting the returned path into a relative path.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"ignoreFileNotFoundOrPermissionError": {
				"title": "Ignore File Not Found Or Permission Error",
				"description": "Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error. By default when a directory or file does not exist or insufficient permission, then an exception is thrown. Setting this option to true allows to ignore that instead.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"inProgressRepository": {
				"title": "In Progress Repository",
				"description": "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"localWorkDirectory": {
				"title": "Local Work Directory",
				"description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"onCompletionExceptionHandler": {
				"title": "On Completion Exception Handler",
				"description": "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"processStrategy": {
				"title": "Process Strategy",
				"description": "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.file.GenericFileProcessStrategy<org.apache.commons.net.ftp.FTPFile>"
			},
			"throwExceptionOnConnectFailed": {
				"title": "Throw Exception On Connect Failed",
				"description": "Should an exception be thrown if connection failed (exhausted)By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"useList": {
				"title": "Use List",
				"description": "Whether to allow using LIST command when downloading a file. Default is true. In some use cases you may want to download a specific file and are not allowed to use the LIST command, and therefore you can set this option to false. Notice when using this option, then the specific file to download does not include meta-data information such as file size, timestamp, permissions etc, because those information is only possible to retrieve when LIST command is in use.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"checksumFileAlgorithm": {
				"title": "Checksum File Algorithm",
				"description": "If provided, then Camel will write a checksum file when the original file has been written. The checksum file will contain the checksum created with the provided algorithm for the original file. The checksum file will always be written in the same folder as the original file.",
				"type": "string",
				"enum": [
					"MD2",
					"MD5",
					"SHA_1",
					"SHA_224",
					"SHA_256",
					"SHA_384",
					"SHA_512",
					"SHA_512_224",
					"SHA_512_256",
					"SHA3_224",
					"SHA3_256",
					"SHA3_384",
					"SHA3_512"
				],
				"$comment": "group:producer"
			},
			"fileExist": {
				"title": "File Exist",
				"description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
				"type": "string",
				"enum": [
					"Override",
					"Append",
					"Fail",
					"Ignore",
					"Move",
					"TryRename"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.file.GenericFileExist",
				"default": "Override"
			},
			"flatten": {
				"title": "Flatten",
				"description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"jailStartingDirectory": {
				"title": "Jail Starting Directory",
				"description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"moveExisting": {
				"title": "Move Existing",
				"description": "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempFileName": {
				"title": "Temp File Name",
				"description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempPrefix": {
				"title": "Temp Prefix",
				"description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"chmod": {
				"title": "Chmod",
				"description": "Allows you to set chmod on the stored file. For example, chmod=640.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"disconnectOnBatchComplete": {
				"title": "Disconnect On Batch Complete",
				"description": "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"eagerDeleteTargetFile": {
				"title": "Eager Delete Target File",
				"description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"keepLastModified": {
				"title": "Keep Last Modified",
				"description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"moveExistingFileStrategy": {
				"title": "Move Existing File Strategy",
				"description": "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.file.strategy.FileMoveExistingStrategy"
			},
			"sendNoop": {
				"title": "Send Noop",
				"description": "Whether to send a noop command as a pre-write check before uploading files to the FTP server. This is enabled by default as a validation of the connection is still valid, which allows to silently re-connect to be able to upload the file. However if this causes problems, you can turn this option off.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"activePortRange": {
				"title": "Active Port Range",
				"description": "Set the client side port range in active mode. The syntax is: minPort-maxPort Both port numbers are inclusive, e.g., 10000-19999 to include all 1xxxx ports.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"autoCreate": {
				"title": "Auto Create",
				"description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"bufferSize": {
				"title": "Buffer Size",
				"description": "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 131072
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "10000"
			},
			"ftpClient": {
				"title": "Ftp Client",
				"description": "To use a custom instance of FTPClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.commons.net.ftp.FTPClient"
			},
			"ftpClientConfig": {
				"title": "Ftp Client Config",
				"description": "To use a custom instance of FTPClientConfig to configure the FTP client the endpoint should use.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.commons.net.ftp.FTPClientConfig"
			},
			"ftpClientConfigParameters": {
				"title": "Ftp Client Config Parameters",
				"description": "Used by FtpComponent to provide additional parameters for the FTPClientConfig",
				"type": "object",
				"$comment": "group:advanced"
			},
			"ftpClientParameters": {
				"title": "Ftp Client Parameters",
				"description": "Used by FtpComponent to provide additional parameters for the FTPClient",
				"type": "object",
				"$comment": "group:advanced"
			},
			"maximumReconnectAttempts": {
				"title": "Maximum Reconnect Attempts",
				"description": "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"reconnectDelay": {
				"title": "Reconnect Delay",
				"description": "Delay in millis Camel will wait before performing a reconnect attempt.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"siteCommand": {
				"title": "Site Command",
				"description": "Sets optional site command(s) to be executed after successful login. Multiple site commands can be separated using a new line character.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"soTimeout": {
				"title": "So Timeout",
				"description": "Sets the so timeout FTP and FTPS Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "300000"
			},
			"stepwise": {
				"title": "Stepwise",
				"description": "Sets whether we should stepwise change directories while traversing file structures when downloading files, or as well when uploading a file to a directory. You can disable this if you for example are in a situation where you cannot change directory on the FTP server due security reasons. Stepwise cannot be used together with streamDownload.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets the data timeout for waiting for reply Used only by FTPClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "30000"
			},
			"antExclude": {
				"title": "Ant Exclude",
				"description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"antFilterCaseSensitive": {
				"title": "Ant Filter Case Sensitive",
				"description": "Sets case sensitive flag on ant filter.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"antInclude": {
				"title": "Ant Include",
				"description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"eagerMaxMessagesPerPoll": {
				"title": "Eager Max Messages Per Poll",
				"description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"exclude": {
				"title": "Exclude",
				"description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"excludeExt": {
				"title": "Exclude Ext",
				"description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"filter": {
				"title": "Filter",
				"description": "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.component.file.GenericFileFilter<org.apache.commons.net.ftp.FTPFile>"
			},
			"filterDirectory": {
				"title": "Filter Directory",
				"description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
				"type": "string",
				"$comment": "group:filter"
			},
			"filterFile": {
				"title": "Filter File",
				"description": "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotent": {
				"title": "Idempotent",
				"description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:filter"
			},
			"idempotentEager": {
				"title": "Idempotent Eager",
				"description": "Sets whether to eagerly add the filename to the idempotent repository or wait until the exchange is complete.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"idempotentKey": {
				"title": "Idempotent Key",
				"description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryIdempotentRepository if none is specified and idempotent is true.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"include": {
				"title": "Include",
				"description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"includeExt": {
				"title": "Include Ext",
				"description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"maxDepth": {
				"title": "Max Depth",
				"description": "The maximum depth to traverse when recursively processing a directory.",
				"type": "integer",
				"$comment": "group:filter",
				"default": 2147483647
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"minDepth": {
				"title": "Min Depth",
				"description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"move": {
				"title": "Move",
				"description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
				"type": "string",
				"$comment": "group:filter"
			},
			"exclusiveReadLockStrategy": {
				"title": "Exclusive Read Lock Strategy",
				"description": "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
				"type": "string",
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy<org.apache.commons.net.ftp.FTPFile>"
			},
			"readLock": {
				"title": "Read Lock",
				"description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
				"type": "string",
				"enum": [
					"none",
					"markerFile",
					"fileLock",
					"rename",
					"changed",
					"idempotent",
					"idempotent-changed",
					"idempotent-rename"
				],
				"$comment": "group:lock",
				"default": "none"
			},
			"readLockCheckInterval": {
				"title": "Read Lock Check Interval",
				"description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1000
			},
			"readLockDeleteOrphanLockFiles": {
				"title": "Read Lock Delete Orphan Lock Files",
				"description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockLoggingLevel": {
				"title": "Read Lock Logging Level",
				"description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"readLockMarkerFile": {
				"title": "Read Lock Marker File",
				"description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockMinAge": {
				"title": "Read Lock Min Age",
				"description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 0
			},
			"readLockMinLength": {
				"title": "Read Lock Min Length",
				"description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1
			},
			"readLockRemoveOnCommit": {
				"title": "Read Lock Remove On Commit",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "boolean",
				"$comment": "group:lock"
			},
			"readLockRemoveOnRollback": {
				"title": "Read Lock Remove On Rollback",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockTimeout": {
				"title": "Read Lock Timeout",
				"description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 10000
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"account": {
				"title": "Account",
				"description": "Account to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"disableSecureDataChannelDefaults": {
				"title": "Disable Secure Data Channel Defaults",
				"description": "Use this option to disable default options when using secure data channel. This allows you to be in full control what the execPbsz and execProt setting should be used. Default is false",
				"type": "boolean",
				"$comment": "group:security"
			},
			"execPbsz": {
				"title": "Exec Pbsz",
				"description": "When using secure data channel you can set the exec protection buffer size",
				"type": "integer",
				"$comment": "group:security"
			},
			"execProt": {
				"title": "Exec Prot",
				"description": "The exec protection level PROT command. C - Clear S - Safe(SSL protocol only) E - Confidential(SSL protocol only) P - Private",
				"type": "string",
				"$comment": "group:security"
			},
			"ftpClientKeyStoreParameters": {
				"title": "Ftp Client Key Store Parameters",
				"description": "Set the key store parameters",
				"type": "object",
				"$comment": "group:security"
			},
			"ftpClientTrustStoreParameters": {
				"title": "Ftp Client Trust Store Parameters",
				"description": "Set the trust store parameters",
				"type": "object",
				"$comment": "group:security"
			},
			"implicit": {
				"title": "Implicit",
				"description": "Set the security mode (Implicit/Explicit). true - Implicit Mode / False - Explicit Mode",
				"type": "boolean",
				"$comment": "group:security"
			},
			"password": {
				"title": "Password",
				"description": "Password to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"securityProtocol": {
				"title": "Security Protocol",
				"description": "Set the underlying security protocol.",
				"type": "string",
				"$comment": "group:security",
				"default": "TLSv1.3"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "Gets the JSSE configuration that overrides any settings in FtpsEndpoint#ftpClientKeyStoreParameters, ftpClientTrustStoreParameters, and FtpsConfiguration#getSecurityProtocol().",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"username": {
				"title": "Username",
				"description": "Username to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"shuffle": {
				"title": "Shuffle",
				"description": "To shuffle the list of files (sort in random order)",
				"type": "boolean",
				"$comment": "group:sort"
			},
			"sortBy": {
				"title": "Sort By",
				"description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
				"type": "string",
				"$comment": "group:sort"
			},
			"sorter": {
				"title": "Sorter",
				"description": "Pluggable sorter as a java.util.Comparator class.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:java.util.Comparator<org.apache.camel.component.file.GenericFile<org.apache.commons.net.ftp.FTPFile>>"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"geocoder": {
		"properties": {
			"address": {
				"title": "Address",
				"description": "The geo address which should be prefixed with address:",
				"type": "string",
				"$comment": "group:producer"
			},
			"latlng": {
				"title": "Latlng",
				"description": "The geo latitude and longitude which should be prefixed with latlng:",
				"type": "string",
				"$comment": "group:producer"
			},
			"headersOnly": {
				"title": "Headers Only",
				"description": "Whether to only enrich the Exchange with headers, and leave the body as-is.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"language": {
				"title": "Language",
				"description": "The language to use.",
				"type": "string",
				"$comment": "group:producer",
				"default": "en"
			},
			"serverUrl": {
				"title": "Server URL",
				"description": "URL to the geocoder server. Mandatory for Nominatim server.",
				"type": "string",
				"$comment": "group:producer"
			},
			"type": {
				"title": "GeoCoding Type",
				"description": "Type of GeoCoding server. Supported Nominatim and Google.",
				"type": "string",
				"enum": [
					"NOMINATIM",
					"GOOGLE"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.geocoder.GeoCoderType"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"proxyAuthDomain": {
				"title": "Proxy Auth Domain",
				"description": "Proxy Authentication Domain to access Google GeoCoding server.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthHost": {
				"title": "Proxy Auth Host",
				"description": "Proxy Authentication Host to access Google GeoCoding server.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthMethod": {
				"title": "Proxy Auth Method",
				"description": "Authentication Method to Google GeoCoding server.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthPassword": {
				"title": "Proxy Auth Password",
				"description": "Proxy Password to access GeoCoding server.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthUsername": {
				"title": "Proxy Auth Username",
				"description": "Proxy Username to access GeoCoding server.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "Proxy Host to access GeoCoding server.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "Proxy Port to access GeoCoding server.",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"apiKey": {
				"title": "Api Key",
				"description": "API Key to access Google. Mandatory for Google GeoCoding server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Client ID to access Google GeoCoding server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKey": {
				"title": "Client Key",
				"description": "Client Key to access Google GeoCoding server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"git": {
		"properties": {
			"localPath": {
				"title": "Local Path",
				"description": "Local repository path",
				"type": "string",
				"$comment": "group:common"
			},
			"branchName": {
				"title": "Branch Name",
				"description": "The branch name to work on",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"type": {
				"title": "Type",
				"description": "The consumer type",
				"type": "string",
				"enum": [
					"commit",
					"tag",
					"branch"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.git.consumer.GitType"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"allowEmpty": {
				"title": "Allow Empty",
				"description": "The flag to manage empty git commits",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do on the repository",
				"type": "string",
				"enum": [
					"add",
					"cherryPick",
					"clean",
					"clone",
					"commit",
					"commitAll",
					"createBranch",
					"createTag",
					"deleteBranch",
					"deleteTag",
					"gc",
					"init",
					"log",
					"pull",
					"push",
					"remoteAdd",
					"remoteList",
					"remove",
					"showBranches",
					"showTags",
					"status"
				],
				"$comment": "group:producer"
			},
			"remoteName": {
				"title": "Remote Name",
				"description": "The remote repository name to use in particular operation like pull",
				"type": "string",
				"$comment": "group:producer"
			},
			"remotePath": {
				"title": "Remote Path",
				"description": "The remote repository path",
				"type": "string",
				"$comment": "group:producer"
			},
			"tagName": {
				"title": "Tag Name",
				"description": "The tag name to work on",
				"type": "string",
				"$comment": "group:producer"
			},
			"targetBranchName": {
				"title": "Target Branch Name",
				"description": "Name of target branch in merge operation. If not supplied will try to use init.defaultBranch git configs. If not configured will use default value",
				"type": "string",
				"$comment": "group:producer",
				"default": "master"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"gitConfigFile": {
				"title": "Git Config File",
				"description": "A String with path to a .gitconfig file",
				"type": "string",
				"$comment": "group:advanced"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Remote repository password",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Remote repository username",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"localPath"
		]
	},
	"github": {
		"properties": {
			"type": {
				"title": "Type",
				"description": "What git operation to execute",
				"type": "string",
				"enum": [
					"CLOSEPULLREQUEST",
					"PULLREQUESTCOMMENT",
					"COMMIT",
					"PULLREQUEST",
					"TAG",
					"PULLREQUESTSTATE",
					"PULLREQUESTFILES",
					"GETCOMMITFILE",
					"CREATEISSUE",
					"EVENT"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.github.GitHubType"
			},
			"branchName": {
				"title": "Branch Name",
				"description": "Name of branch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"repoName": {
				"title": "Repo Name",
				"description": "GitHub repository name",
				"type": "string",
				"$comment": "group:common"
			},
			"repoOwner": {
				"title": "Repo Owner",
				"description": "GitHub repository owner (organization)",
				"type": "string",
				"$comment": "group:common"
			},
			"commitMessageAsBody": {
				"title": "Commit Message As Body",
				"description": "Whether the commit consumer should store the commit message or the raw org.eclipse.egit.github.core.RepositoryCommit object as the message body.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"startingSha": {
				"title": "Starting Sha",
				"description": "The starting sha to use for polling commits with the commit consumer. The value can either be a sha for the sha to start from, or use beginning to start from the beginning, or last to start from the last commit.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "last"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eventFetchStrategy": {
				"title": "Event Fetch Strategy",
				"description": "To specify a custom strategy that configures how the EventsConsumer fetches events.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.github.event.GitHubEventFetchStrategy"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"encoding": {
				"title": "Encoding",
				"description": "To use the given encoding when getting a git commit file",
				"type": "string",
				"$comment": "group:producer"
			},
			"state": {
				"title": "State",
				"description": "To set git commit status state",
				"type": "string",
				"enum": [
					"error",
					"failure",
					"pending",
					"success"
				],
				"$comment": "group:producer"
			},
			"targetUrl": {
				"title": "Target Url",
				"description": "To set git commit status target url",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "GitHub OAuth token. Must be configured on either component or endpoint.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"type",
			"repoName",
			"repoOwner"
		]
	},
	"google-bigquery": {
		"properties": {
			"projectId": {
				"title": "Project Id",
				"description": "Google Cloud Project Id",
				"type": "string",
				"$comment": "group:common"
			},
			"datasetId": {
				"title": "Dataset Id",
				"description": "BigQuery Dataset Id",
				"type": "string",
				"$comment": "group:common"
			},
			"tableId": {
				"title": "Table Id",
				"description": "BigQuery table id",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "ConnectionFactory to obtain connection to Bigquery Service. If not provided the default one will be used",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.google.bigquery.GoogleBigQueryConnectionFactory"
			},
			"useAsInsertId": {
				"title": "Use As Insert Id",
				"description": "Field name to use as insert id",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Service account key in json format to authenticate an application as a service account to google cloud platform",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"projectId",
			"datasetId"
		]
	},
	"google-bigquery-sql": {
		"properties": {
			"projectId": {
				"title": "Project Id",
				"description": "Google Cloud Project Id",
				"type": "string",
				"$comment": "group:common"
			},
			"queryString": {
				"title": "Query String",
				"description": "BigQuery standard SQL query",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "ConnectionFactory to obtain connection to Bigquery Service. If not provided the default one will be used",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.google.bigquery.GoogleBigQueryConnectionFactory"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Service account key in json format to authenticate an application as a service account to google cloud platform",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"projectId",
			"queryString"
		]
	},
	"google-calendar": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"ACL",
					"LIST",
					"CALENDARS",
					"CHANNELS",
					"COLORS",
					"FREEBUSY",
					"EVENTS",
					"SETTINGS"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.google.calendar.internal.GoogleCalendarApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"enum": [
					"calendarImport",
					"clear",
					"delete",
					"get",
					"insert",
					"instances",
					"list",
					"move",
					"patch",
					"query",
					"quickAdd",
					"stop",
					"update",
					"watch"
				],
				"$comment": "group:common"
			},
			"applicationName": {
				"title": "Application Name",
				"description": "Google calendar application name. Example would be camel-google-calendar/1.0",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Client ID of the calendar application",
				"type": "string",
				"$comment": "group:common"
			},
			"delegate": {
				"title": "Delegate",
				"description": "Delegate for wide-domain service account",
				"type": "string",
				"$comment": "group:common"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"scopes": {
				"title": "Scopes",
				"description": "Specifies the level of permissions you want a calendar application to have to a user account. You can separate multiple scopes by comma. See https://developers.google.com/google-apps/calendar/auth for more info.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:common",
				"default": "https://www.googleapis.com/auth/calendar"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Client secret of the calendar application",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"emailAddress": {
				"title": "Email Address",
				"description": "The emailAddress of the Google Service Account.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"p12FileName": {
				"title": "P12 File Name",
				"description": "The name of the p12 file which has the private key to use with the Google Service Account.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"refreshToken": {
				"title": "Refresh Token",
				"description": "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Service account key in json format to authenticate an application as a service account. Accept base64 adding the prefix base64:",
				"type": "string",
				"$comment": "group:security"
			},
			"user": {
				"title": "User",
				"description": "The email address of the user the application is trying to impersonate in the service account flow",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"google-calendar-stream": {
		"properties": {
			"index": {
				"title": "Index",
				"description": "Specifies an index for the endpoint",
				"type": "string",
				"$comment": "group:consumer"
			},
			"applicationName": {
				"title": "Application Name",
				"description": "Google Calendar application name. Example would be camel-google-calendar/1.0",
				"type": "string",
				"$comment": "group:consumer"
			},
			"calendarId": {
				"title": "Calendar Id",
				"description": "The calendarId to be used",
				"type": "string",
				"$comment": "group:consumer",
				"default": "primary"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Client ID of the calendar application",
				"type": "string",
				"$comment": "group:consumer"
			},
			"considerLastUpdate": {
				"title": "Consider Last Update",
				"description": "Take into account the lastUpdate of the last event polled as start date for the next poll",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"consumeFromNow": {
				"title": "Consume From Now",
				"description": "Consume events in the selected calendar from now on",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"delegate": {
				"title": "Delegate",
				"description": "Delegate for wide-domain service account",
				"type": "string",
				"$comment": "group:consumer"
			},
			"maxResults": {
				"title": "Max Results",
				"description": "Max results to be returned",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"query": {
				"title": "Query",
				"description": "The query to execute on calendar",
				"type": "string",
				"$comment": "group:consumer"
			},
			"scopes": {
				"title": "Scopes",
				"description": "Specifies the level of permissions you want a calendar application to have to a user account. See https://developers.google.com/calendar/auth for more info.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"syncFlow": {
				"title": "Sync Flow",
				"description": "Sync events, see https://developers.google.com/calendar/v3/sync Note: not compatible with: 'query' and 'considerLastUpdate' parameters",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Client secret of the calendar application",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"emailAddress": {
				"title": "Email Address",
				"description": "The emailAddress of the Google Service Account.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"p12FileName": {
				"title": "P12 File Name",
				"description": "The name of the p12 file which has the private key to use with the Google Service Account.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"refreshToken": {
				"title": "Refresh Token",
				"description": "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Service account key in json format to authenticate an application as a service account. Accept base64 adding the prefix base64:",
				"type": "string",
				"$comment": "group:security"
			},
			"user": {
				"title": "User",
				"description": "The email address of the user the application is trying to impersonate in the service account flow.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"index"
		]
	},
	"google-drive": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"DRIVE_ABOUT",
					"DRIVE_CHANGES",
					"DRIVE_CHANNELS",
					"DRIVE_COMMENTS",
					"DRIVE_DRIVES",
					"DRIVE_FILES",
					"DRIVE_PERMISSIONS",
					"DRIVE_REPLIES",
					"DRIVE_REVISIONS",
					"DRIVE_TEAMDRIVES"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.google.drive.internal.GoogleDriveApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"enum": [
					"copy",
					"delete",
					"get",
					"getIdForEmail",
					"insert",
					"list",
					"patch",
					"stop",
					"touch",
					"trash",
					"untrash",
					"update",
					"watch"
				],
				"$comment": "group:common"
			},
			"applicationName": {
				"title": "Application Name",
				"description": "Google drive application name. Example would be camel-google-drive/1.0",
				"type": "string",
				"$comment": "group:common"
			},
			"clientFactory": {
				"title": "Client Factory",
				"description": "To use the GoogleCalendarClientFactory as factory for creating the client. Will by default use BatchGoogleDriveClientFactory",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.google.drive.GoogleDriveClientFactory"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Client ID of the drive application",
				"type": "string",
				"$comment": "group:common"
			},
			"delegate": {
				"title": "Delegate",
				"description": "Delegate for wide-domain service account",
				"type": "string",
				"$comment": "group:common"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"scopes": {
				"title": "Scopes",
				"description": "Specifies the level of permissions you want a drive application to have to a user account. See https://developers.google.com/drive/web/scopes for more info.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Client secret of the drive application",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"refreshToken": {
				"title": "Refresh Token",
				"description": "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Service account key in json format to authenticate an application as a service account. Accept base64 adding the prefix base64:",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"google-functions": {
		"properties": {
			"functionName": {
				"title": "Function Name",
				"description": "The user-defined name of the function",
				"type": "string",
				"$comment": "group:common"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Service account key to authenticate an application as a service account",
				"type": "string",
				"$comment": "group:common"
			},
			"location": {
				"title": "Location",
				"description": "The Google Cloud Location (Region) where the Function is located",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform on the producer.",
				"type": "string",
				"enum": [
					"listFunctions",
					"getFunction",
					"callFunction",
					"generateDownloadUrl",
					"generateUploadUrl",
					"createFunction",
					"updateFunction",
					"deleteFunction"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.google.functions.GoogleCloudFunctionsOperations"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "Specifies if the request is a pojo request",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"project": {
				"title": "Project",
				"description": "The Google Cloud Project name where the Function is located",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"client": {
				"title": "Client",
				"description": "The client to use during service invocation.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.google.cloud.functions.v1.CloudFunctionsServiceClient"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"functionName"
		]
	},
	"google-mail": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"THREADS",
					"MESSAGES",
					"ATTACHMENTS",
					"LABELS",
					"HISTORY",
					"DRAFTS",
					"USERS"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.google.mail.internal.GoogleMailApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"enum": [
					"attachments",
					"create",
					"delete",
					"get",
					"getProfile",
					"gmailImport",
					"insert",
					"list",
					"modify",
					"patch",
					"send",
					"stop",
					"trash",
					"untrash",
					"update",
					"watch"
				],
				"$comment": "group:common"
			},
			"applicationName": {
				"title": "Application Name",
				"description": "Google mail application name. Example would be camel-google-mail/1.0",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Client ID of the mail application",
				"type": "string",
				"$comment": "group:common"
			},
			"delegate": {
				"title": "Delegate",
				"description": "Delegate for wide-domain service account",
				"type": "string",
				"$comment": "group:common"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"scopes": {
				"title": "Scopes",
				"description": "GMail scopes",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Client secret of the mail application",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"refreshToken": {
				"title": "Refresh Token",
				"description": "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Service account key in json format to authenticate an application as a service account. Accept base64 adding the prefix base64:",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"google-mail-stream": {
		"properties": {
			"index": {
				"title": "Index",
				"description": "Currently not in use",
				"type": "string",
				"$comment": "group:consumer"
			},
			"applicationName": {
				"title": "Application Name",
				"description": "Google mail application name. Example would be camel-google-mail/1.0",
				"type": "string",
				"$comment": "group:consumer"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Client ID of the mail application",
				"type": "string",
				"$comment": "group:consumer"
			},
			"delegate": {
				"title": "Delegate",
				"description": "Delegate for wide-domain service account",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labels": {
				"title": "Labels",
				"description": "Comma separated list of labels to take into account",
				"type": "string",
				"$comment": "group:consumer"
			},
			"markAsRead": {
				"title": "Mark As Read",
				"description": "Mark the message as read once it has been consumed",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"maxResults": {
				"title": "Max Results",
				"description": "Max results to be returned",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"query": {
				"title": "Query",
				"description": "The query to execute on gmail box",
				"type": "string",
				"$comment": "group:consumer",
				"default": "is:unread"
			},
			"raw": {
				"title": "Raw",
				"description": "Whether to store the entire email message in an RFC 2822 formatted and base64url encoded string (in JSon format), in the Camel message body.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"scopes": {
				"title": "Scopes",
				"description": "GMail scopes",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Client secret of the mail application",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"refreshToken": {
				"title": "Refresh Token",
				"description": "OAuth 2 refresh token. Using this, the Google Calendar component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Sets .json file with credentials for Service account",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"index"
		]
	},
	"google-pubsub": {
		"properties": {
			"projectId": {
				"title": "Project Id",
				"description": "The Google Cloud PubSub Project Id",
				"type": "string",
				"$comment": "group:common"
			},
			"destinationName": {
				"title": "Destination Name",
				"description": "The Destination Name. For the consumer this will be the subscription name, while for the producer this will be the topic name.",
				"type": "string",
				"$comment": "group:common"
			},
			"authenticate": {
				"title": "Authenticate",
				"description": "Use Credentials when interacting with PubSub service (no authentication is required when using emulator).",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"loggerId": {
				"title": "Logger Id",
				"description": "Logger ID to use when a match to the parent route required",
				"type": "string",
				"$comment": "group:common"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "The Service account key that can be used as credentials for the PubSub publisher/subscriber. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:common"
			},
			"ackMode": {
				"title": "Ack Mode",
				"description": "AUTO = exchange gets ack'ed/nack'ed on completion. NONE = downstream process has to ack/nack explicitly",
				"type": "string",
				"enum": [
					"AUTO",
					"NONE"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.google.pubsub.GooglePubsubConstants.AckMode",
				"default": "AUTO"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "The number of parallel streams consuming from the subscription",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "1"
			},
			"maxAckExtensionPeriod": {
				"title": "Max Ack Extension Period",
				"description": "Set the maximum period a message ack deadline will be extended. Value in seconds",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 3600
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "The max number of messages to receive from the server in a single API call",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "1"
			},
			"synchronousPull": {
				"title": "Synchronous Pull",
				"description": "Synchronously pull batches of messages",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"messageOrderingEnabled": {
				"title": "Message Ordering Enabled",
				"description": "Should message ordering be enabled",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"pubsubEndpoint": {
				"title": "Pubsub Endpoint",
				"description": "Pub/Sub endpoint to use. Required when using message ordering, and ensures that messages are received in order even when multiple publishers are used",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"retry": {
				"title": "Retry",
				"description": "A custom RetrySettings to control how the publisher handles retry-able failures",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:com.google.api.gax.retrying.RetrySettings"
			},
			"serializer": {
				"title": "Serializer",
				"description": "A custom GooglePubsubSerializer to use for serializing message payloads in the producer",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.google.pubsub.serializer.GooglePubsubSerializer"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"projectId",
			"destinationName"
		]
	},
	"google-pubsub-lite": {
		"properties": {
			"projectId": {
				"title": "Project Id",
				"description": "The Google Cloud PubSub Lite Project Id",
				"type": "integer",
				"$comment": "group:common"
			},
			"location": {
				"title": "Location",
				"description": "The Google Cloud PubSub Lite location",
				"type": "string",
				"$comment": "group:common"
			},
			"destinationName": {
				"title": "Destination Name",
				"description": "The Destination Name. For the consumer this will be the subscription name, while for the producer this will be the topic name.",
				"type": "string",
				"$comment": "group:common"
			},
			"loggerId": {
				"title": "Logger Id",
				"description": "Logger ID to use when a match to the parent route required",
				"type": "string",
				"$comment": "group:common"
			},
			"ackMode": {
				"title": "Ack Mode",
				"description": "AUTO = exchange gets ack'ed/nack'ed on completion. NONE = downstream process has to ack/nack explicitly",
				"type": "string",
				"enum": [
					"AUTO",
					"NONE"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.google.pubsublite.GooglePubsubLiteConstants.AckMode",
				"default": "AUTO"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "The number of parallel streams consuming from the subscription",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "1"
			},
			"maxAckExtensionPeriod": {
				"title": "Max Ack Extension Period",
				"description": "Set the maximum period a message ack deadline will be extended. Value in seconds",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 3600
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "The max number of messages to receive from the server in a single API call",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "1"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"pubsubEndpoint": {
				"title": "Pubsub Endpoint",
				"description": "Pub/Sub endpoint to use. Required when using message ordering, and ensures that messages are received in order even when multiple publishers are used",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"serializer": {
				"title": "Serializer",
				"description": "A custom GooglePubsubLiteSerializer to use for serializing message payloads in the producer",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.google.pubsublite.serializer.GooglePubsubSerializer"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "The Service account key that can be used as credentials for the PubSub publisher/subscriber. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"projectId",
			"location",
			"destinationName"
		]
	},
	"google-secret-manager": {
		"properties": {
			"project": {
				"title": "Project",
				"description": "The Google Cloud Project Id name related to the Secret Manager",
				"type": "string",
				"$comment": "group:common"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Service account key to authenticate an application as a service account",
				"type": "string",
				"$comment": "group:common"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform on the producer.",
				"type": "string",
				"enum": [
					"createSecret"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.google.secret.manager.GoogleSecretManagerOperations"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "Specifies if the request is a pojo request",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"client": {
				"title": "Client",
				"description": "The client to use during service invocation.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.google.cloud.secretmanager.v1.SecretManagerServiceClient"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"project"
		]
	},
	"google-sheets": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"SPREADSHEETS",
					"DATA"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.google.sheets.internal.GoogleSheetsApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"enum": [
					"create",
					"get",
					"update",
					"append",
					"batchUpdate",
					"clear"
				],
				"$comment": "group:common"
			},
			"applicationName": {
				"title": "Application Name",
				"description": "Google Sheets application name. Example would be camel-google-sheets/1.0",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Client ID of the sheets application",
				"type": "string",
				"$comment": "group:common"
			},
			"delegate": {
				"title": "Delegate",
				"description": "Delegate for wide-domain service account",
				"type": "string",
				"$comment": "group:common"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"scopes": {
				"title": "Scopes",
				"description": "Specifies the level of permissions you want a sheets application to have to a user account. See https://developers.google.com/identity/protocols/googlescopes for more info. Multiple scopes can be separated by comma.",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"splitResult": {
				"title": "Split Result",
				"description": "When consumer return an array or collection this will generate one exchange per element, and their routes will be executed once for each exchange. Set this value to false to use a single exchange for the entire list or array.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Client secret of the sheets application",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"refreshToken": {
				"title": "Refresh Token",
				"description": "OAuth 2 refresh token. Using this, the Google Sheets component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Sets .json file with credentials for Service account",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"google-sheets-stream": {
		"properties": {
			"spreadsheetId": {
				"title": "Spreadsheet Id",
				"description": "Specifies the spreadsheet identifier that is used to identify the target to obtain.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"applicationName": {
				"title": "Application Name",
				"description": "Google Sheets application name. Example would be camel-google-sheets/1.0",
				"type": "string",
				"$comment": "group:consumer"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Client ID of the sheets application",
				"type": "string",
				"$comment": "group:consumer"
			},
			"delegate": {
				"title": "Delegate",
				"description": "Delegate for wide-domain service account",
				"type": "string",
				"$comment": "group:consumer"
			},
			"includeGridData": {
				"title": "Include Grid Data",
				"description": "True if grid data should be returned.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"majorDimension": {
				"title": "Major Dimension",
				"description": "Specifies the major dimension that results should use..",
				"type": "string",
				"enum": [
					"ROWS",
					"COLUMNS",
					"DIMENSION_UNSPECIFIED"
				],
				"$comment": "group:consumer",
				"default": "ROWS"
			},
			"maxResults": {
				"title": "Max Results",
				"description": "Specify the maximum number of returned results. This will limit the number of rows in a returned value range data set or the number of returned value ranges in a batch request.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"range": {
				"title": "Range",
				"description": "Specifies the range of rows and columns in a sheet to get data from.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"scopes": {
				"title": "Scopes",
				"description": "Specifies the level of permissions you want a sheets application to have to a user account. See https://developers.google.com/identity/protocols/googlescopes for more info.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"splitResults": {
				"title": "Split Results",
				"description": "True if value range result should be split into rows or columns to process each of them individually. When true each row or column is represented with a separate exchange in batch processing. Otherwise value range object is used as exchange junk size.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"valueRenderOption": {
				"title": "Value Render Option",
				"description": "Determines how values should be rendered in the output.",
				"type": "string",
				"enum": [
					"FORMATTED_VALUE",
					"UNFORMATTED_VALUE",
					"FORMULA"
				],
				"$comment": "group:consumer",
				"default": "FORMATTED_VALUE"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "OAuth 2 access token. This typically expires after an hour so refreshToken is recommended for long term usage.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Client secret of the sheets application",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"refreshToken": {
				"title": "Refresh Token",
				"description": "OAuth 2 refresh token. Using this, the Google Sheets component can obtain a new accessToken whenever the current one expires - a necessity if the application is long-lived.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "Sets .json file with credentials for Service account",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"spreadsheetId"
		]
	},
	"google-storage": {
		"properties": {
			"bucketName": {
				"title": "Bucket Name",
				"description": "Bucket name or ARN",
				"type": "string",
				"$comment": "group:common"
			},
			"autoCreateBucket": {
				"title": "Auto Create Bucket",
				"description": "Setting the autocreation of the bucket bucketName.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"serviceAccountKey": {
				"title": "Service Account Key",
				"description": "The Service account key that can be used as credentials for the Storage client. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:common"
			},
			"storageClass": {
				"title": "Storage Class",
				"description": "The Cloud Storage class to use when creating the new buckets",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.google.cloud.storage.StorageClass",
				"default": "STANDARD"
			},
			"storageClient": {
				"title": "Storage Client",
				"description": "The storage client",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.google.cloud.storage.Storage"
			},
			"storageLocation": {
				"title": "Storage Location",
				"description": "The Cloud Storage location to use when creating the new buckets",
				"type": "string",
				"$comment": "group:common",
				"default": "US-EAST1"
			},
			"deleteAfterRead": {
				"title": "Delete After Read",
				"description": "Delete objects from the bucket after they have been retrieved. The delete is only performed if the Exchange is committed. If a rollback occurs, the object is not deleted. If this option is false, then the same objects will be retrieve over and over again on the polls.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"destinationBucket": {
				"title": "Destination Bucket",
				"description": "Define the destination bucket where an object must be moved when moveAfterRead is set to true.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"downloadFileName": {
				"title": "Download File Name",
				"description": "The folder or filename to use when downloading the blob. By default, this specifies the folder name, and the name of the file is the blob name. For example, setting this to mydownload will be the same as setting mydownload/${file:name}. You can use dynamic expressions for fine-grained control. For example, you can specify ${date:now:yyyyMMdd}/${file:name} to store the blob in sub folders based on today's day. Only ${file:name} and ${file:name.noext} is supported as dynamic tokens for the blob name.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"filter": {
				"title": "Filter",
				"description": "A regular expression to include only blobs with name matching it.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"includeBody": {
				"title": "Include Body",
				"description": "If it is true, the Object exchange will be consumed and put into the body. If false the Object stream will be put raw into the body and the headers will be set with the object metadata.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"includeFolders": {
				"title": "Include Folders",
				"description": "If it is true, the folders/directories will be consumed. If it is false, they will be ignored, and Exchanges will not be created for those",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"moveAfterRead": {
				"title": "Move After Read",
				"description": "Move objects from the origin bucket to a different bucket after they have been retrieved. To accomplish the operation the destinationBucket option must be set. The copy bucket operation is only performed if the Exchange is committed. If a rollback occurs, the object is not moved.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"prefix": {
				"title": "Prefix",
				"description": "The prefix which is used in the BlobListOptions to only consume objects we are interested in",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"objectName": {
				"title": "Object Name",
				"description": "The Object name inside the bucket",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Set the operation for the producer",
				"type": "string",
				"enum": [
					"copyObject",
					"listObjects",
					"deleteObject",
					"deleteBucket",
					"listBuckets",
					"getObject",
					"createDownloadLink"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.google.storage.GoogleCloudStorageOperations"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"bucketName"
		]
	},
	"grape": {
		"properties": {
			"defaultCoordinates": {
				"title": "Default Coordinates",
				"description": "Maven coordinates to use as default to grab if the message body is empty.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"defaultCoordinates"
		]
	},
	"graphql": {
		"properties": {
			"httpUri": {
				"title": "Http Uri",
				"description": "The GraphQL server URI.",
				"type": "string",
				"$comment": "group:producer"
			},
			"operationName": {
				"title": "Operation Name",
				"description": "The query or mutation name.",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "The proxy host in the format hostname:port.",
				"type": "string",
				"$comment": "group:producer"
			},
			"query": {
				"title": "Query",
				"description": "The query text.",
				"type": "string",
				"$comment": "group:producer"
			},
			"queryFile": {
				"title": "Query File",
				"description": "The query file name located in the classpath.",
				"type": "string",
				"$comment": "group:producer"
			},
			"queryHeader": {
				"title": "Query Header",
				"description": "The name of a header containing the GraphQL query.",
				"type": "string",
				"$comment": "group:producer"
			},
			"variables": {
				"title": "Variables",
				"description": "The JsonObject instance containing the operation variables.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.util.json.JsonObject"
			},
			"variablesHeader": {
				"title": "Variables Header",
				"description": "The name of a header containing a JsonObject instance containing the operation variables.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"accessToken": {
				"title": "Access Token",
				"description": "The access token sent in the Authorization header.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"jwtAuthorizationType": {
				"title": "Jwt Authorization Type",
				"description": "The JWT Authorization type. Default is Bearer.",
				"type": "string",
				"$comment": "group:security",
				"default": "Bearer"
			},
			"password": {
				"title": "Password",
				"description": "The password for Basic authentication.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "The username for Basic authentication.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"httpUri"
		]
	},
	"grpc": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The gRPC server host name. This is localhost or 0.0.0.0 when being a consumer or remote server host name when using producer.",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The gRPC local or remote server port",
				"type": "integer",
				"$comment": "group:common"
			},
			"service": {
				"title": "Service",
				"description": "Fully qualified service name from the protocol buffer descriptor file (package dot service definition name)",
				"type": "string",
				"$comment": "group:common"
			},
			"flowControlWindow": {
				"title": "Flow Control Window",
				"description": "The HTTP/2 flow control window size (MiB)",
				"type": "integer",
				"$comment": "group:common",
				"default": 1048576
			},
			"maxMessageSize": {
				"title": "Max Message Size",
				"description": "The maximum message size allowed to be received/sent (MiB)",
				"type": "integer",
				"$comment": "group:common",
				"default": 4194304
			},
			"autoDiscoverServerInterceptors": {
				"title": "Auto Discover Server Interceptors",
				"description": "Setting the autoDiscoverServerInterceptors mechanism, if true, the component will look for a ServerInterceptor instance in the registry automatically otherwise it will skip that checking.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"consumerStrategy": {
				"title": "Consumer Strategy",
				"description": "This option specifies the top-level strategy for processing service requests and responses in streaming mode. If an aggregation strategy is selected, all requests will be accumulated in the list, then transferred to the flow, and the accumulated responses will be sent to the sender. If a propagation strategy is selected, request is sent to the stream, and the response will be immediately sent back to the sender. If a delegation strategy is selected, request is sent to the stream, but no response generated under the assumption that all necessary responses will be sent at another part of route. Delegation strategy always comes with routeControlledStreamObserver=true to be able to achieve the assumption.",
				"type": "string",
				"enum": [
					"AGGREGATION",
					"PROPAGATION",
					"DELEGATION"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.grpc.GrpcConsumerStrategy",
				"default": "PROPAGATION"
			},
			"forwardOnCompleted": {
				"title": "Forward On Completed",
				"description": "Determines if onCompleted events should be pushed to the Camel route.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"forwardOnError": {
				"title": "Forward On Error",
				"description": "Determines if onError events should be pushed to the Camel route. Exceptions will be set as message body.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"initialFlowControlWindow": {
				"title": "Initial Flow Control Window",
				"description": "Sets the initial flow control window in bytes.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1048576
			},
			"keepAliveTime": {
				"title": "Keep Alive Time",
				"description": "Sets a custom keepalive time in milliseconds, the delay time for sending next keepalive ping. A value of Long.MAX_VALUE or a value greater or equal to NettyServerBuilder.AS_LARGE_AS_INFINITE will disable keepalive.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 7200000
			},
			"keepAliveTimeout": {
				"title": "Keep Alive Timeout",
				"description": "Sets a custom keepalive timeout in milliseconds, the timeout for keepalive ping requests.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 20000
			},
			"maxConcurrentCallsPerConnection": {
				"title": "Max Concurrent Calls Per Connection",
				"description": "The maximum number of concurrent calls permitted for each incoming server connection. Defaults to no limit.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 2147483647
			},
			"maxConnectionAge": {
				"title": "Max Connection Age",
				"description": "Sets a custom max connection age in milliseconds. Connections lasting longer than which will be gracefully terminated. A random jitter of /-10% will be added to the value. A value of Long.MAX_VALUE (the default) or a value greater or equal to NettyServerBuilder.AS_LARGE_AS_INFINITE will disable max connection age.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": -1
			},
			"maxConnectionAgeGrace": {
				"title": "Max Connection Age Grace",
				"description": "Sets a custom grace time in milliseconds for the graceful connection termination. A value of Long.MAX_VALUE (the default) or a value greater or equal to NettyServerBuilder.AS_LARGE_AS_INFINITE is considered infinite.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": -1
			},
			"maxConnectionIdle": {
				"title": "Max Connection Idle",
				"description": "Sets a custom max connection idle time in milliseconds. Connection being idle for longer than which will be gracefully terminated. A value of Long.MAX_VALUE (the default) or a value greater or equal to NettyServerBuilder.AS_LARGE_AS_INFINITE will disable max connection idle",
				"type": "integer",
				"$comment": "group:consumer",
				"default": -1
			},
			"maxInboundMetadataSize": {
				"title": "Max Inbound Metadata Size",
				"description": "Sets the maximum size of metadata allowed to be received. The default is 8 KiB.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 8192
			},
			"maxRstFramesPerWindow": {
				"title": "Max Rst Frames Per Window",
				"description": "Limits the rate of incoming RST_STREAM frames per connection to maxRstFramesPerWindow per maxRstPeriodSeconds. This option MUST be used in conjunction with maxRstPeriodSeconds for it to be effective.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 0
			},
			"maxRstPeriodSeconds": {
				"title": "Max Rst Period Seconds",
				"description": "Limits the rate of incoming RST_STREAM frames per maxRstPeriodSeconds. This option MUST be used in conjunction with maxRstFramesPerWindow for it to be effective.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 0
			},
			"permitKeepAliveTime": {
				"title": "Permit Keep Alive Time",
				"description": "Sets the most aggressive keep-alive time in milliseconds that clients are permitted to configure. The server will try to detect clients exceeding this rate and will forcefully close the connection.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 300000
			},
			"permitKeepAliveWithoutCalls": {
				"title": "Permit Keep Alive Without Calls",
				"description": "Sets whether to allow clients to send keep-alive HTTP/ 2 PINGs even if there are no outstanding RPCs on the connection.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"routeControlledStreamObserver": {
				"title": "Route Controlled Stream Observer",
				"description": "Lets the route to take control over stream observer. If this value is set to true, then the response observer of gRPC call will be set with the name GrpcConstants.GRPC_RESPONSE_OBSERVER in the Exchange object. Please note that the stream observer's onNext(), onError(), onCompleted() methods should be called in the route.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"autoDiscoverClientInterceptors": {
				"title": "Auto Discover Client Interceptors",
				"description": "Setting the autoDiscoverClientInterceptors mechanism, if true, the component will look for a ClientInterceptor instance in the registry automatically otherwise it will skip that checking.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"inheritExchangePropertiesForReplies": {
				"title": "Inherit Exchange Properties For Replies",
				"description": "Copies exchange properties from original exchange to all exchanges created for route defined by streamRepliesTo.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"method": {
				"title": "Method",
				"description": "gRPC method name",
				"type": "string",
				"$comment": "group:producer"
			},
			"producerStrategy": {
				"title": "Producer Strategy",
				"description": "The mode used to communicate with a remote gRPC server. In SIMPLE mode a single exchange is translated into a remote procedure call. In STREAMING mode all exchanges will be sent within the same request (input and output of the recipient gRPC service must be of type 'stream').",
				"type": "string",
				"enum": [
					"SIMPLE",
					"STREAMING"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.grpc.GrpcProducerStrategy",
				"default": "SIMPLE"
			},
			"streamRepliesTo": {
				"title": "Stream Replies To",
				"description": "When using STREAMING client mode, it indicates the endpoint where responses should be forwarded.",
				"type": "string",
				"$comment": "group:producer"
			},
			"toRouteControlledStreamObserver": {
				"title": "To Route Controlled Stream Observer",
				"description": "Expects that exchange property GrpcConstants.GRPC_RESPONSE_OBSERVER is set. Takes its value and calls onNext, onError and onComplete on that StreamObserver. All other gRPC parameters are ignored.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"userAgent": {
				"title": "User Agent",
				"description": "The user agent header passed to the server",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"authenticationType": {
				"title": "Authentication Type",
				"description": "Authentication method type in advance to the SSL/TLS negotiation",
				"type": "string",
				"enum": [
					"NONE",
					"GOOGLE",
					"JWT"
				],
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.grpc.GrpcAuthType",
				"default": "NONE"
			},
			"jwtAlgorithm": {
				"title": "Jwt Algorithm",
				"description": "JSON Web Token sign algorithm",
				"type": "string",
				"enum": [
					"HMAC256",
					"HMAC384",
					"HMAC512"
				],
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.grpc.auth.jwt.JwtAlgorithm",
				"default": "HMAC256"
			},
			"jwtIssuer": {
				"title": "Jwt Issuer",
				"description": "JSON Web Token issuer",
				"type": "string",
				"$comment": "group:security"
			},
			"jwtSecret": {
				"title": "Jwt Secret",
				"description": "JSON Web Token secret",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"jwtSubject": {
				"title": "Jwt Subject",
				"description": "JSON Web Token subject",
				"type": "string",
				"$comment": "group:security"
			},
			"keyCertChainResource": {
				"title": "Key Cert Chain Resource",
				"description": "The X.509 certificate chain file resource in PEM format link",
				"type": "string",
				"$comment": "group:security"
			},
			"keyPassword": {
				"title": "Key Password",
				"description": "The PKCS#8 private key file password",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"keyResource": {
				"title": "Key Resource",
				"description": "The PKCS#8 private key file resource in PEM format link",
				"type": "string",
				"$comment": "group:security"
			},
			"negotiationType": {
				"title": "Negotiation Type",
				"description": "Identifies the security negotiation type used for HTTP/2 communication",
				"type": "string",
				"enum": [
					"TLS",
					"PLAINTEXT_UPGRADE",
					"PLAINTEXT"
				],
				"$comment": "group:security",
				"format": "bean:io.grpc.netty.NegotiationType",
				"default": "PLAINTEXT"
			},
			"serviceAccountResource": {
				"title": "Service Account Resource",
				"description": "Service Account key file in JSON format resource link supported by the Google Cloud SDK",
				"type": "string",
				"$comment": "group:security"
			},
			"trustCertCollectionResource": {
				"title": "Trust Cert Collection Resource",
				"description": "The trusted certificates collection file resource in PEM format for verifying the remote endpoint's certificate",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"port",
			"service"
		]
	},
	"guava-eventbus": {
		"properties": {
			"eventBusRef": {
				"title": "Event Bus Ref",
				"description": "To lookup the Guava EventBus from the registry with the given name",
				"type": "string",
				"$comment": "group:common"
			},
			"eventClass": {
				"title": "Event Class",
				"description": "If used on the consumer side of the route, will filter events received from the EventBus to the instances of the class and superclasses of eventClass. Null value of this option is equal to setting it to the java.lang.Object i.e. the consumer will capture all messages incoming to the event bus. This option cannot be used together with listenerInterface option.",
				"type": "string",
				"$comment": "group:common"
			},
			"listenerInterface": {
				"title": "Listener Interface",
				"description": "The interface with method(s) marked with the Subscribe annotation. Dynamic proxy will be created over the interface so it could be registered as the EventBus listener. Particularly useful when creating multi-event listeners and for handling DeadEvent properly. This option cannot be used together with eventClass option.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"hashicorp-vault": {
		"properties": {
			"secretsEngine": {
				"title": "Secrets Engine",
				"description": "Vault Name to be used",
				"type": "string",
				"$comment": "group:producer"
			},
			"cloud": {
				"title": "Cloud",
				"description": "Determine if the Hashicorp Vault is deployed on Hashicorp Cloud or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"host": {
				"title": "Host",
				"description": "Hashicorp Vault instance host to be used",
				"type": "string",
				"$comment": "group:producer"
			},
			"namespace": {
				"title": "Namespace",
				"description": "If the Hashicorp Vault instance is deployed on Hashicorp Cloud, this field will determine the namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Operation to be performed",
				"type": "string",
				"enum": [
					"createSecret",
					"getSecret",
					"deleteSecret",
					"listSecrets"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.hashicorp.vault.HashicorpVaultOperation"
			},
			"port": {
				"title": "Port",
				"description": "Hashicorp Vault instance port to be used",
				"type": "string",
				"$comment": "group:producer",
				"default": "8200"
			},
			"scheme": {
				"title": "Scheme",
				"description": "Hashicorp Vault instance scheme to be used",
				"type": "string",
				"$comment": "group:producer",
				"default": "https"
			},
			"secretPath": {
				"title": "Secret Path",
				"description": "Hashicorp Vault instance secret Path to be used",
				"type": "string",
				"$comment": "group:producer"
			},
			"vaultTemplate": {
				"title": "Vault Template",
				"description": "Instance of Vault template",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.springframework.vault.core.VaultTemplate"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"token": {
				"title": "Token",
				"description": "Token to be used",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"hazelcast-atomicvalue": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:producer"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:producer"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-instance": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:consumer"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-list": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:common"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:common"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-map": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:common"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:common"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-multimap": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:common"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:common"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-queue": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:common"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:common"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:common"
			},
			"pollingTimeout": {
				"title": "Polling Timeout",
				"description": "Define the polling timeout of the Queue consumer in Poll mode",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10000
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "Define the Pool size for Queue Consumer Executor",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"queueConsumerMode": {
				"title": "Queue Consumer Mode",
				"description": "Define the Queue Consumer mode: Listen or Poll",
				"type": "string",
				"enum": [
					"listen",
					"poll"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.hazelcast.queue.HazelcastQueueConsumerMode",
				"default": "Listen"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-replicatedmap": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:common"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:common"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-ringbuffer": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:producer"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:producer"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-seda": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:common"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:common"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "To use concurrent consumers polling from the SEDA queue.",
				"type": "integer",
				"$comment": "group:seda",
				"default": 1
			},
			"onErrorDelay": {
				"title": "On Error Delay",
				"description": "Milliseconds before consumer continues polling after an error has occurred.",
				"type": "integer",
				"$comment": "group:seda",
				"default": 1000
			},
			"pollTimeout": {
				"title": "Poll Timeout",
				"description": "The timeout used when consuming from the SEDA queue. When a timeout occurs, the consumer can check whether it is allowed to continue running. Setting a lower value allows the consumer to react more quickly upon shutdown.",
				"type": "integer",
				"$comment": "group:seda",
				"default": 1000
			},
			"transacted": {
				"title": "Transacted",
				"description": "If set to true then the consumer runs in transaction mode, where the messages in the seda queue will only be removed if the transaction commits, which happens when the processing is complete.",
				"type": "boolean",
				"$comment": "group:seda"
			},
			"transferExchange": {
				"title": "Transfer Exchange",
				"description": "If set to true the whole Exchange will be transfered. If header or body contains not serializable objects, they will be skipped.",
				"type": "boolean",
				"$comment": "group:seda"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-set": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:common"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:common"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"hazelcast-topic": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:common"
			},
			"defaultOperation": {
				"title": "Default Operation",
				"description": "To specify a default operation to use, if no operation header has been provided.",
				"type": "string",
				"enum": [
					"put",
					"delete",
					"get",
					"update",
					"query",
					"getAll",
					"clear",
					"putIfAbsent",
					"addAll",
					"removeAll",
					"retainAll",
					"evict",
					"evictAll",
					"valueCount",
					"containsKey",
					"containsValue",
					"getKeys",
					"removeValue",
					"increment",
					"decrement",
					"setValue",
					"destroy",
					"compareAndSet",
					"getAndAdd",
					"add",
					"offer",
					"peek",
					"poll",
					"remainingCapacity",
					"drainTo",
					"removeIf",
					"take",
					"publish",
					"readOnceHead",
					"readOnceTail",
					"capacity"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.hazelcast.HazelcastOperation"
			},
			"hazelcastConfigUri": {
				"title": "Hazelcast Config Uri",
				"description": "Hazelcast configuration file.",
				"type": "string",
				"$comment": "group:common"
			},
			"hazelcastInstance": {
				"title": "Hazelcast Instance",
				"description": "The hazelcast instance reference which can be used for hazelcast endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.hazelcast.core.HazelcastInstance"
			},
			"hazelcastInstanceName": {
				"title": "Hazelcast Instance Name",
				"description": "The hazelcast instance reference name which can be used for hazelcast endpoint. If you don't specify the instance reference, camel use the default hazelcast instance from the camel-hazelcast instance.",
				"type": "string",
				"$comment": "group:common"
			},
			"reliable": {
				"title": "Reliable",
				"description": "Define if the endpoint will use a reliable Topic struct or not.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"http": {
		"properties": {
			"httpUri": {
				"title": "Http Uri",
				"description": "The url of the HTTP endpoint to call.",
				"type": "string",
				"$comment": "group:common"
			},
			"disableStreamCache": {
				"title": "Disable Stream Cache",
				"description": "Determines whether or not the raw input stream is cached or not. The Camel consumer (camel-servlet, camel-jetty etc.) will by default cache the input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The producer (camel-http) will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is (the stream can only be read once) as the message body.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:common (advanced)",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"bridgeEndpoint": {
				"title": "Bridge Endpoint",
				"description": "If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"connectionClose": {
				"title": "Connection Close",
				"description": "Specifies whether a Connection Close header must be added to HTTP Request. By default connectionClose is false.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"httpMethod": {
				"title": "Http Method",
				"description": "Configure the HTTP method to use. The HttpMethod header cannot override this option if set.",
				"type": "string",
				"enum": [
					"GET",
					"POST",
					"PUT",
					"DELETE",
					"HEAD",
					"OPTIONS",
					"TRACE",
					"PATCH"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.http.common.HttpMethods"
			},
			"logHttpActivity": {
				"title": "Log Http Activity",
				"description": "To enable logging HTTP request and response. You can use a custom LoggingHttpActivityListener as httpActivityListener to control logging options.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"skipRequestHeaders": {
				"title": "Skip Request Headers",
				"description": "Whether to skip mapping all the Camel headers as HTTP request headers. If there are no data from Camel headers needed to be included in the HTTP request then this can avoid parsing overhead with many object allocations for the JVM garbage collector.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"skipResponseHeaders": {
				"title": "Skip Response Headers",
				"description": "Whether to skip mapping all the HTTP response headers to Camel headers. If there are no data needed from HTTP headers then this can avoid parsing overhead with many object allocations for the JVM garbage collector.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"throwExceptionOnFailure": {
				"title": "Throw Exception On Failure",
				"description": "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"clearExpiredCookies": {
				"title": "Clear Expired Cookies",
				"description": "Whether to clear expired cookies before sending the HTTP request. This ensures the cookies store does not keep growing by adding new cookies which is newer removed when they are expired. If the component has disabled cookie management then this option is disabled too.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"cookieHandler": {
				"title": "Cookie Handler",
				"description": "Configure a cookie handler to maintain a HTTP session",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.http.base.cookie.CookieHandler"
			},
			"cookieStore": {
				"title": "Cookie Store",
				"description": "To use a custom CookieStore. By default the BasicCookieStore is used which is an in-memory only cookie store. Notice if bridgeEndpoint=true then the cookie store is forced to be a noop cookie store as cookie shouldn't be stored as we are just bridging (eg acting as a proxy). If a cookieHandler is set then the cookie store is also forced to be a noop cookie store as cookie handling is then performed by the cookieHandler.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.hc.client5.http.cookie.CookieStore"
			},
			"copyHeaders": {
				"title": "Copy Headers",
				"description": "If this option is true then IN exchange headers will be copied to OUT exchange headers according to copy strategy. Setting this to false, allows to only include the headers from the HTTP response (not propagating IN headers).",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"customHostHeader": {
				"title": "Custom Host Header",
				"description": "To use custom host header for producer. When not set in query will be ignored. When set will override host header derived from url.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"deleteWithBody": {
				"title": "Delete With Body",
				"description": "Whether the HTTP DELETE should include the message body or not. By default HTTP DELETE do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"followRedirects": {
				"title": "Follow Redirects",
				"description": "Whether to the HTTP request should follow redirects. By default the HTTP request does not follow redirects",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"getWithBody": {
				"title": "Get With Body",
				"description": "Whether the HTTP GET should include the message body or not. By default HTTP GET do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"httpActivityListener": {
				"title": "Http Activity Listener",
				"description": "To use a custom activity listener",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.http.HttpActivityListener"
			},
			"ignoreResponseBody": {
				"title": "Ignore Response Body",
				"description": "If this option is true, The http producer won't read response body and cache the input stream",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"okStatusCodeRange": {
				"title": "Ok Status Code Range",
				"description": "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"default": "200-299"
			},
			"preserveHostHeader": {
				"title": "Preserve Host Header",
				"description": "If the option is true, HttpProducer will set the Host header to the value contained in the current exchange Host header, useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client, this allows applications which use the Host header to generate accurate URL's for a proxied service",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"userAgent": {
				"title": "User Agent",
				"description": "To set a custom HTTP User-Agent request header",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"clientBuilder": {
				"title": "Client Builder",
				"description": "Provide access to the http client request parameters used on new RequestConfig instances used by producers or consumers of this endpoint.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.client5.http.impl.classic.HttpClientBuilder"
			},
			"clientConnectionManager": {
				"title": "Client Connection Manager",
				"description": "To use a custom HttpClientConnectionManager to manage connections",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.client5.http.io.HttpClientConnectionManager"
			},
			"connectionsPerRoute": {
				"title": "Connections Per Route",
				"description": "The maximum number of connections per route.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 20
			},
			"httpClient": {
				"title": "Http Client",
				"description": "Sets a custom HttpClient to be used by the producer",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.client5.http.classic.HttpClient"
			},
			"httpClientConfigurer": {
				"title": "Http Client Configurer",
				"description": "Register a custom configuration strategy for new HttpClient instances created by producers or consumers such as to configure authentication mechanisms etc.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.http.HttpClientConfigurer"
			},
			"httpClientOptions": {
				"title": "Http Client Options",
				"description": "To configure the HttpClient using the key/values from the Map.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"httpConnectionOptions": {
				"title": "Http Connection Options",
				"description": "To configure the connection and the socket using the key/values from the Map.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"httpContext": {
				"title": "Http Context",
				"description": "To use a custom HttpContext instance",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.core5.http.protocol.HttpContext"
			},
			"maxTotalConnections": {
				"title": "Max Total Connections",
				"description": "The maximum number of connections.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 200
			},
			"useSystemProperties": {
				"title": "Use System Properties",
				"description": "To use System Properties as fallback for configuration for configuring HTTP Client",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"proxyAuthDomain": {
				"title": "Proxy Auth Domain",
				"description": "Proxy authentication domain to use with NTML",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthHost": {
				"title": "Proxy Auth Host",
				"description": "Proxy authentication host",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthMethod": {
				"title": "Proxy Auth Method",
				"description": "Proxy authentication method to use",
				"type": "string",
				"enum": [
					"Basic",
					"Digest",
					"NTLM"
				],
				"$comment": "group:proxy"
			},
			"proxyAuthNtHost": {
				"title": "Proxy Auth Nt Host",
				"description": "Proxy authentication domain (workstation name) to use with NTML",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthPassword": {
				"title": "Proxy Auth Password",
				"description": "Proxy authentication password",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"proxyAuthPort": {
				"title": "Proxy Auth Port",
				"description": "Proxy authentication port",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyAuthScheme": {
				"title": "Proxy Auth Scheme",
				"description": "Proxy authentication scheme to use",
				"type": "string",
				"enum": [
					"http",
					"https"
				],
				"$comment": "group:proxy"
			},
			"proxyAuthUsername": {
				"title": "Proxy Auth Username",
				"description": "Proxy authentication username",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "Proxy hostname to use",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "Proxy port to use",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"authDomain": {
				"title": "Auth Domain",
				"description": "Authentication domain to use with NTML",
				"type": "string",
				"$comment": "group:security"
			},
			"authenticationPreemptive": {
				"title": "Authentication Preemptive",
				"description": "If this option is true, camel-http sends preemptive basic authentication to the server.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"authHost": {
				"title": "Auth Host",
				"description": "Authentication host to use with NTML",
				"type": "string",
				"$comment": "group:security"
			},
			"authMethod": {
				"title": "Auth Method",
				"description": "Authentication methods allowed to use as a comma separated list of values Basic, Digest or NTLM.",
				"type": "string",
				"$comment": "group:security"
			},
			"authMethodPriority": {
				"title": "Auth Method Priority",
				"description": "Which authentication method to prioritize to use, either as Basic, Digest or NTLM.",
				"type": "string",
				"enum": [
					"Basic",
					"Digest",
					"NTLM"
				],
				"$comment": "group:security"
			},
			"authPassword": {
				"title": "Auth Password",
				"description": "Authentication password",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"authUsername": {
				"title": "Auth Username",
				"description": "Authentication username",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauth2CachedTokensDefaultExpirySeconds": {
				"title": "Oauth2 Cached Tokens Default Expiry Seconds",
				"description": "Default expiration time for cached OAuth2 tokens, in seconds. Used if token response does not contain 'expires_in' field.",
				"type": "integer",
				"$comment": "group:security",
				"default": 3600
			},
			"oauth2CachedTokensExpirationMarginSeconds": {
				"title": "Oauth2 Cached Tokens Expiration Margin Seconds",
				"description": "Amount of time which is deducted from OAuth2 tokens expiry time to compensate for the time it takes OAuth2 Token Endpoint to send the token over http, in seconds. Set this parameter to high value if you OAuth2 Token Endpoint answers slowly or you tokens expire quickly. If you set this parameter to too small value, you can get 4xx http errors because camel will think that the received token is still valid, while in reality the token is expired for the Authentication server.",
				"type": "integer",
				"$comment": "group:security",
				"default": 5
			},
			"oauth2CacheTokens": {
				"title": "Oauth2 Cache Tokens",
				"description": "Whether to cache OAuth2 client tokens.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"oauth2ClientId": {
				"title": "Oauth2 Client Id",
				"description": "OAuth2 client id",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauth2ClientSecret": {
				"title": "Oauth2 Client Secret",
				"description": "OAuth2 client secret",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauth2Scope": {
				"title": "Oauth2 Scope",
				"description": "OAuth2 scope",
				"type": "string",
				"$comment": "group:security"
			},
			"oauth2TokenEndpoint": {
				"title": "Oauth2 Token Endpoint",
				"description": "OAuth2 Token endpoint",
				"type": "string",
				"$comment": "group:security"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters. Important: Only one instance of org.apache.camel.util.jsse.SSLContextParameters is supported per HttpComponent. If you need to use 2 or more different instances, you need to define a new HttpComponent per instance you need.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"x509HostnameVerifier": {
				"title": "X509 Hostname Verifier",
				"description": "To use a custom X509HostnameVerifier such as DefaultHostnameVerifier or NoopHostnameVerifier",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:javax.net.ssl.HostnameVerifier"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"httpUri"
		]
	},
	"https": {
		"properties": {
			"httpUri": {
				"title": "Http Uri",
				"description": "The url of the HTTP endpoint to call.",
				"type": "string",
				"$comment": "group:common"
			},
			"disableStreamCache": {
				"title": "Disable Stream Cache",
				"description": "Determines whether or not the raw input stream is cached or not. The Camel consumer (camel-servlet, camel-jetty etc.) will by default cache the input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The producer (camel-http) will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is (the stream can only be read once) as the message body.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:common (advanced)",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"bridgeEndpoint": {
				"title": "Bridge Endpoint",
				"description": "If the option is true, HttpProducer will ignore the Exchange.HTTP_URI header, and use the endpoint's URI for request. You may also set the option throwExceptionOnFailure to be false to let the HttpProducer send all the fault response back.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"connectionClose": {
				"title": "Connection Close",
				"description": "Specifies whether a Connection Close header must be added to HTTP Request. By default connectionClose is false.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"httpMethod": {
				"title": "Http Method",
				"description": "Configure the HTTP method to use. The HttpMethod header cannot override this option if set.",
				"type": "string",
				"enum": [
					"GET",
					"POST",
					"PUT",
					"DELETE",
					"HEAD",
					"OPTIONS",
					"TRACE",
					"PATCH"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.http.common.HttpMethods"
			},
			"logHttpActivity": {
				"title": "Log Http Activity",
				"description": "To enable logging HTTP request and response. You can use a custom LoggingHttpActivityListener as httpActivityListener to control logging options.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"skipRequestHeaders": {
				"title": "Skip Request Headers",
				"description": "Whether to skip mapping all the Camel headers as HTTP request headers. If there are no data from Camel headers needed to be included in the HTTP request then this can avoid parsing overhead with many object allocations for the JVM garbage collector.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"skipResponseHeaders": {
				"title": "Skip Response Headers",
				"description": "Whether to skip mapping all the HTTP response headers to Camel headers. If there are no data needed from HTTP headers then this can avoid parsing overhead with many object allocations for the JVM garbage collector.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"throwExceptionOnFailure": {
				"title": "Throw Exception On Failure",
				"description": "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"clearExpiredCookies": {
				"title": "Clear Expired Cookies",
				"description": "Whether to clear expired cookies before sending the HTTP request. This ensures the cookies store does not keep growing by adding new cookies which is newer removed when they are expired. If the component has disabled cookie management then this option is disabled too.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"cookieHandler": {
				"title": "Cookie Handler",
				"description": "Configure a cookie handler to maintain a HTTP session",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.http.base.cookie.CookieHandler"
			},
			"cookieStore": {
				"title": "Cookie Store",
				"description": "To use a custom CookieStore. By default the BasicCookieStore is used which is an in-memory only cookie store. Notice if bridgeEndpoint=true then the cookie store is forced to be a noop cookie store as cookie shouldn't be stored as we are just bridging (eg acting as a proxy). If a cookieHandler is set then the cookie store is also forced to be a noop cookie store as cookie handling is then performed by the cookieHandler.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.hc.client5.http.cookie.CookieStore"
			},
			"copyHeaders": {
				"title": "Copy Headers",
				"description": "If this option is true then IN exchange headers will be copied to OUT exchange headers according to copy strategy. Setting this to false, allows to only include the headers from the HTTP response (not propagating IN headers).",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"customHostHeader": {
				"title": "Custom Host Header",
				"description": "To use custom host header for producer. When not set in query will be ignored. When set will override host header derived from url.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"deleteWithBody": {
				"title": "Delete With Body",
				"description": "Whether the HTTP DELETE should include the message body or not. By default HTTP DELETE do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"followRedirects": {
				"title": "Follow Redirects",
				"description": "Whether to the HTTP request should follow redirects. By default the HTTP request does not follow redirects",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"getWithBody": {
				"title": "Get With Body",
				"description": "Whether the HTTP GET should include the message body or not. By default HTTP GET do not include any HTTP body. However in some rare cases users may need to be able to include the message body.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"httpActivityListener": {
				"title": "Http Activity Listener",
				"description": "To use a custom activity listener",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.http.HttpActivityListener"
			},
			"ignoreResponseBody": {
				"title": "Ignore Response Body",
				"description": "If this option is true, The http producer won't read response body and cache the input stream",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"okStatusCodeRange": {
				"title": "Ok Status Code Range",
				"description": "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"default": "200-299"
			},
			"preserveHostHeader": {
				"title": "Preserve Host Header",
				"description": "If the option is true, HttpProducer will set the Host header to the value contained in the current exchange Host header, useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client, this allows applications which use the Host header to generate accurate URL's for a proxied service",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"userAgent": {
				"title": "User Agent",
				"description": "To set a custom HTTP User-Agent request header",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"clientBuilder": {
				"title": "Client Builder",
				"description": "Provide access to the http client request parameters used on new RequestConfig instances used by producers or consumers of this endpoint.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.client5.http.impl.classic.HttpClientBuilder"
			},
			"clientConnectionManager": {
				"title": "Client Connection Manager",
				"description": "To use a custom HttpClientConnectionManager to manage connections",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.client5.http.io.HttpClientConnectionManager"
			},
			"connectionsPerRoute": {
				"title": "Connections Per Route",
				"description": "The maximum number of connections per route.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 20
			},
			"httpClient": {
				"title": "Http Client",
				"description": "Sets a custom HttpClient to be used by the producer",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.client5.http.classic.HttpClient"
			},
			"httpClientConfigurer": {
				"title": "Http Client Configurer",
				"description": "Register a custom configuration strategy for new HttpClient instances created by producers or consumers such as to configure authentication mechanisms etc.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.http.HttpClientConfigurer"
			},
			"httpClientOptions": {
				"title": "Http Client Options",
				"description": "To configure the HttpClient using the key/values from the Map.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"httpConnectionOptions": {
				"title": "Http Connection Options",
				"description": "To configure the connection and the socket using the key/values from the Map.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"httpContext": {
				"title": "Http Context",
				"description": "To use a custom HttpContext instance",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.core5.http.protocol.HttpContext"
			},
			"maxTotalConnections": {
				"title": "Max Total Connections",
				"description": "The maximum number of connections.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 200
			},
			"useSystemProperties": {
				"title": "Use System Properties",
				"description": "To use System Properties as fallback for configuration for configuring HTTP Client",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"proxyAuthDomain": {
				"title": "Proxy Auth Domain",
				"description": "Proxy authentication domain to use with NTML",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthHost": {
				"title": "Proxy Auth Host",
				"description": "Proxy authentication host",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthMethod": {
				"title": "Proxy Auth Method",
				"description": "Proxy authentication method to use",
				"type": "string",
				"enum": [
					"Basic",
					"Digest",
					"NTLM"
				],
				"$comment": "group:proxy"
			},
			"proxyAuthNtHost": {
				"title": "Proxy Auth Nt Host",
				"description": "Proxy authentication domain (workstation name) to use with NTML",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyAuthPassword": {
				"title": "Proxy Auth Password",
				"description": "Proxy authentication password",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"proxyAuthPort": {
				"title": "Proxy Auth Port",
				"description": "Proxy authentication port",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyAuthScheme": {
				"title": "Proxy Auth Scheme",
				"description": "Proxy authentication scheme to use",
				"type": "string",
				"enum": [
					"http",
					"https"
				],
				"$comment": "group:proxy"
			},
			"proxyAuthUsername": {
				"title": "Proxy Auth Username",
				"description": "Proxy authentication username",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "Proxy hostname to use",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "Proxy port to use",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"authDomain": {
				"title": "Auth Domain",
				"description": "Authentication domain to use with NTML",
				"type": "string",
				"$comment": "group:security"
			},
			"authenticationPreemptive": {
				"title": "Authentication Preemptive",
				"description": "If this option is true, camel-http sends preemptive basic authentication to the server.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"authHost": {
				"title": "Auth Host",
				"description": "Authentication host to use with NTML",
				"type": "string",
				"$comment": "group:security"
			},
			"authMethod": {
				"title": "Auth Method",
				"description": "Authentication methods allowed to use as a comma separated list of values Basic, Digest or NTLM.",
				"type": "string",
				"$comment": "group:security"
			},
			"authMethodPriority": {
				"title": "Auth Method Priority",
				"description": "Which authentication method to prioritize to use, either as Basic, Digest or NTLM.",
				"type": "string",
				"enum": [
					"Basic",
					"Digest",
					"NTLM"
				],
				"$comment": "group:security"
			},
			"authPassword": {
				"title": "Auth Password",
				"description": "Authentication password",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"authUsername": {
				"title": "Auth Username",
				"description": "Authentication username",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauth2CachedTokensDefaultExpirySeconds": {
				"title": "Oauth2 Cached Tokens Default Expiry Seconds",
				"description": "Default expiration time for cached OAuth2 tokens, in seconds. Used if token response does not contain 'expires_in' field.",
				"type": "integer",
				"$comment": "group:security",
				"default": 3600
			},
			"oauth2CachedTokensExpirationMarginSeconds": {
				"title": "Oauth2 Cached Tokens Expiration Margin Seconds",
				"description": "Amount of time which is deducted from OAuth2 tokens expiry time to compensate for the time it takes OAuth2 Token Endpoint to send the token over http, in seconds. Set this parameter to high value if you OAuth2 Token Endpoint answers slowly or you tokens expire quickly. If you set this parameter to too small value, you can get 4xx http errors because camel will think that the received token is still valid, while in reality the token is expired for the Authentication server.",
				"type": "integer",
				"$comment": "group:security",
				"default": 5
			},
			"oauth2CacheTokens": {
				"title": "Oauth2 Cache Tokens",
				"description": "Whether to cache OAuth2 client tokens.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"oauth2ClientId": {
				"title": "Oauth2 Client Id",
				"description": "OAuth2 client id",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauth2ClientSecret": {
				"title": "Oauth2 Client Secret",
				"description": "OAuth2 client secret",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauth2Scope": {
				"title": "Oauth2 Scope",
				"description": "OAuth2 scope",
				"type": "string",
				"$comment": "group:security"
			},
			"oauth2TokenEndpoint": {
				"title": "Oauth2 Token Endpoint",
				"description": "OAuth2 Token endpoint",
				"type": "string",
				"$comment": "group:security"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters. Important: Only one instance of org.apache.camel.util.jsse.SSLContextParameters is supported per HttpComponent. If you need to use 2 or more different instances, you need to define a new HttpComponent per instance you need.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"x509HostnameVerifier": {
				"title": "X509 Hostname Verifier",
				"description": "To use a custom X509HostnameVerifier such as DefaultHostnameVerifier or NoopHostnameVerifier",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:javax.net.ssl.HostnameVerifier"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"httpUri"
		]
	},
	"hwcloud-dms": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "Operation to be performed",
				"type": "string",
				"$comment": "group:producer"
			},
			"accessKey": {
				"title": "API access key (AK)",
				"description": "Access key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"accessUser": {
				"title": "Access user",
				"description": "The username of a RabbitMQ instance. This option is mandatory when creating a RabbitMQ instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"availableZones": {
				"title": "Available zones",
				"description": "The ID of an available zone. This option is mandatory when creating an instance and it cannot be an empty array.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:producer"
			},
			"endpoint": {
				"title": "Service endpoint",
				"description": "DMS url. Carries higher precedence than region parameter based client initialization",
				"type": "string",
				"$comment": "group:producer"
			},
			"engine": {
				"title": "Engine type",
				"description": "The message engine. Either kafka or rabbitmq. If the parameter is not specified, all instances will be queried",
				"type": "string",
				"enum": [
					"kafka",
					"rabbitmq"
				],
				"$comment": "group:producer"
			},
			"engineVersion": {
				"title": "Engine version",
				"description": "The version of the message engine. This option is mandatory when creating an instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"ignoreSslVerification": {
				"title": "SSL Verification Ignored",
				"description": "Ignore SSL verification",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"instanceId": {
				"title": "Instance id",
				"description": "The id of the instance. This option is mandatory when deleting or querying an instance",
				"type": "string",
				"$comment": "group:producer"
			},
			"kafkaManagerPassword": {
				"title": "Kafka manager password",
				"description": "The password for logging in to the Kafka Manager. This option is mandatory when creating a Kafka instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"kafkaManagerUser": {
				"title": "Kafka manager username",
				"description": "The username for logging in to the Kafka Manager. This option is mandatory when creating a Kafka instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"name": {
				"title": "Name",
				"description": "The name of the instance for creating and updating an instance. This option is mandatory when creating an instance",
				"type": "string",
				"$comment": "group:producer"
			},
			"partitionNum": {
				"title": "Partition Number",
				"description": "The maximum number of partitions in a Kafka instance. This option is mandatory when creating a Kafka instance.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"password": {
				"title": "Password",
				"description": "The password of a RabbitMQ instance. This option is mandatory when creating a RabbitMQ instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"productId": {
				"title": "Product ID",
				"description": "The product ID. This option is mandatory when creating an instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"projectId": {
				"title": "Project ID",
				"description": "Cloud project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyHost": {
				"title": "Proxy server host",
				"description": "Proxy server ip/hostname",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyPassword": {
				"title": "Proxy password",
				"description": "Proxy authentication password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"proxyPort": {
				"title": "Proxy server port",
				"description": "Proxy server port",
				"type": "integer",
				"$comment": "group:producer"
			},
			"proxyUser": {
				"title": "Proxy user",
				"description": "Proxy authentication user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"region": {
				"title": "Service region",
				"description": "DMS service region",
				"type": "string",
				"$comment": "group:producer"
			},
			"secretKey": {
				"title": "API secret key (SK)",
				"description": "Secret key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"securityGroupId": {
				"title": "Security group ID",
				"description": "The security group which the instance belongs to. This option is mandatory when creating an instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"serviceKeys": {
				"title": "Service Configuration",
				"description": "Configuration object for cloud service authentication",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.huaweicloud.common.models.ServiceKeys|password"
			},
			"specification": {
				"title": "Engine version",
				"description": "The baseline bandwidth of a Kafka instance. This option is mandatory when creating a Kafka instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"storageSpace": {
				"title": "Storage space",
				"description": "The message storage space. This option is mandatory when creating an instance.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"storageSpecCode": {
				"title": "Storage specification code",
				"description": "The storage I/O specification. This option is mandatory when creating an instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"subnetId": {
				"title": "Subnet ID",
				"description": "The subnet ID. This option is mandatory when creating an instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"vpcId": {
				"title": "VPC ID",
				"description": "The VPC ID. This option is mandatory when creating an instance.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation",
			"accessKey",
			"projectId",
			"region",
			"secretKey"
		]
	},
	"hwcloud-frs": {
		"properties": {
			"operation": {
				"title": "Operation name",
				"description": "Name of Face Recognition operation to perform, including faceDetection, faceVerification and faceLiveDetection",
				"type": "string",
				"$comment": "group:producer"
			},
			"accessKey": {
				"title": "Account access key (AK)",
				"description": "Access key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"actions": {
				"title": "Actions",
				"description": "This param is mandatory when the operation is faceLiveDetection, indicating the action code sequence list. Actions are separated by commas (,). Currently, the following actions are supported: 1: Shake the head to the left. 2: Shake the head to the right. 3: Nod the head. 4: Mouth movement.",
				"type": "string",
				"$comment": "group:producer"
			},
			"actionTimes": {
				"title": "Action Time",
				"description": "This param can be used when the operation is faceLiveDetection, indicating the action time array. The length of the array is the same as the number of actions. Each item contains the start time and end time of the action in the corresponding sequence. The unit is the milliseconds from the video start time.",
				"type": "string",
				"$comment": "group:producer"
			},
			"anotherImageBase64": {
				"title": "Another Image in Base64",
				"description": "This param can be used when operation is faceVerification, indicating the Base64 character string converted from the other image. It needs to be configured if imageBase64 is set. The image size cannot exceed 10 MB. The image resolution of the narrow sides must be greater than 15 pixels, and that of the wide sides cannot exceed 4096 pixels. The supported image formats include JPG, PNG, and BMP.",
				"type": "string",
				"$comment": "group:producer"
			},
			"anotherImageFilePath": {
				"title": "Another Image File Path",
				"description": "This param can be used when operation is faceVerification, indicating the local file path of the other image. It needs to be configured if imageFilePath is set. Image size cannot exceed 8 MB, and it is recommended that the image size be less than 1 MB.",
				"type": "string",
				"$comment": "group:producer"
			},
			"anotherImageUrl": {
				"title": "Another Image Url",
				"description": "This param can be used when operation is faceVerification, indicating the URL of the other image. It needs to be configured if imageUrl is set. The options are as follows: 1.HTTP/HTTPS URLs on the public network 2.OBS URLs. To use OBS data, authorization is required, including service authorization, temporary authorization, and anonymous public authorization. For details, see Configuring the Access Permission of OBS.",
				"type": "string",
				"$comment": "group:producer"
			},
			"endpoint": {
				"title": "Service endpoint",
				"description": "Fully qualified Face Recognition service url. Carries higher precedence than region based configuration.",
				"type": "string",
				"$comment": "group:producer"
			},
			"imageBase64": {
				"title": "Image in Base64",
				"description": "This param can be used when operation is faceDetection or faceVerification, indicating the Base64 character string converted from an image. Any one of imageBase64, imageUrl and imageFilePath needs to be set, and the priority is imageBase64 imageUrl imageFilePath. The Image size cannot exceed 10 MB. The image resolution of the narrow sides must be greater than 15 pixels, and that of the wide sides cannot exceed 4096 pixels. The supported image formats include JPG, PNG, and BMP.",
				"type": "string",
				"$comment": "group:producer"
			},
			"imageFilePath": {
				"title": "Image File Path",
				"description": "This param can be used when operation is faceDetection or faceVerification, indicating the local image file path. Any one of imageBase64, imageUrl and imageFilePath needs to be set, and the priority is imageBase64 imageUrl imageFilePath. Image size cannot exceed 8 MB, and it is recommended that the image size be less than 1 MB.",
				"type": "string",
				"$comment": "group:producer"
			},
			"imageUrl": {
				"title": "Image Url",
				"description": "This param can be used when operation is faceDetection or faceVerification, indicating the URL of an image. Any one of imageBase64, imageUrl and imageFilePath needs to be set, and the priority is imageBase64 imageUrl imageFilePath. The options are as follows: 1.HTTP/HTTPS URLs on the public network 2.OBS URLs. To use OBS data, authorization is required, including service authorization, temporary authorization, and anonymous public authorization. For details, see Configuring the Access Permission of OBS.",
				"type": "string",
				"$comment": "group:producer"
			},
			"projectId": {
				"title": "Project ID",
				"description": "Cloud project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyHost": {
				"title": "Proxy server host",
				"description": "Proxy server ip/hostname",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyPassword": {
				"title": "Proxy password",
				"description": "Proxy authentication password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"proxyPort": {
				"title": "Proxy server port",
				"description": "Proxy server port",
				"type": "integer",
				"$comment": "group:producer"
			},
			"proxyUser": {
				"title": "Proxy user",
				"description": "Proxy authentication user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"region": {
				"title": "Service region",
				"description": "Face Recognition service region. Currently only cn-north-1 and cn-north-4 are supported. This is lower precedence than endpoint based configuration.",
				"type": "string",
				"$comment": "group:producer"
			},
			"secretKey": {
				"title": "Account secret key (SK)",
				"description": "Secret key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"serviceKeys": {
				"title": "Service Configuration",
				"description": "Configuration object for cloud service authentication",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.huaweicloud.common.models.ServiceKeys|password"
			},
			"videoBase64": {
				"title": "Video in Base64",
				"description": "This param can be used when operation is faceLiveDetection, indicating the Base64 character string converted from a video. Any one of videoBase64, videoUrl and videoFilePath needs to be set, and the priority is videoBase64 videoUrl videoFilePath. Requirements are as follows: 1.The video size after Base64 encoding cannot exceed 8 MB. It is recommended that the video file be compressed to 200 KB to 2 MB on the client. 2.The video duration must be 1 to 15 seconds. 3.The recommended frame rate is 10 fps to 30 fps. 4.The encapsulation format can be MP4, AVI, FLV, WEBM, ASF, or MOV. 5.The video encoding format can be H.261, H.263, H.264, HEVC, VC-1, VP8, VP9, or WMV3.",
				"type": "string",
				"$comment": "group:producer"
			},
			"videoFilePath": {
				"title": "Video File Path",
				"description": "This param can be used when operation is faceLiveDetection, indicating the local video file path. Any one of videoBase64, videoUrl and videoFilePath needs to be set, and the priority is videoBase64 videoUrl videoFilePath. The video requirements are as follows: 1.The size of a video file cannot exceed 8 MB. It is recommended that the video file be compressed to 200 KB to 2 MB on the client. 2.The video duration must be 1 to 15 seconds. 3.The recommended frame rate is 10 fps to 30 fps. 4.The encapsulation format can be MP4, AVI, FLV, WEBM, ASF, or MOV. 5.The video encoding format can be H.261, H.263, H.264, HEVC, VC-1, VP8, VP9, or WMV3.",
				"type": "string",
				"$comment": "group:producer"
			},
			"videoUrl": {
				"title": "Video Url",
				"description": "This param can be used when operation is faceLiveDetection, indicating the URL of a video. Any one of videoBase64, videoUrl and videoFilePath needs to be set, and the priority is videoBase64 videoUrl videoFilePath. Currently, only the URL of an OBS bucket on HUAWEI CLOUD is supported and FRS must have the permission to read data in the OBS bucket. For details about how to enable the read permission, see Service Authorization. The video requirements are as follows: 1.The video size after Base64 encoding cannot exceed 8 MB. 2.The video duration must be 1 to 15 seconds. 3.The recommended frame rate is 10 fps to 30 fps. 4.The encapsulation format can be MP4, AVI, FLV, WEBM, ASF, or MOV. 5.The video encoding format can be H.261, H.263, H.264, HEVC, VC-1, VP8, VP9, or WMV3.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"ignoreSslVerification": {
				"title": "SSL Verification Ignored",
				"description": "Ignore SSL verification",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation",
			"accessKey",
			"projectId",
			"region",
			"secretKey"
		]
	},
	"hwcloud-functiongraph": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "Operation to be performed",
				"type": "string",
				"$comment": "group:producer"
			},
			"endpoint": {
				"title": "Service endpoint",
				"description": "FunctionGraph url. Carries higher precedence than region parameter based client initialization",
				"type": "string",
				"$comment": "group:producer"
			},
			"functionName": {
				"title": "Function name",
				"description": "Name of the function to invoke",
				"type": "string",
				"$comment": "group:producer"
			},
			"functionPackage": {
				"title": "Function package",
				"description": "Functions that can be logically grouped together",
				"type": "string",
				"$comment": "group:producer",
				"default": "default"
			},
			"projectId": {
				"title": "Project ID",
				"description": "Cloud project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Service region",
				"description": "FunctionGraph service region. This is lower precedence than endpoint based configuration",
				"type": "string",
				"$comment": "group:producer"
			},
			"serviceKeys": {
				"title": "Service Configuration",
				"description": "Configuration object for cloud service authentication",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.huaweicloud.common.models.ServiceKeys|password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"proxyHost": {
				"title": "Proxy server host",
				"description": "Proxy server ip/hostname",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPassword": {
				"title": "Proxy password",
				"description": "Proxy authentication password",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"proxyPort": {
				"title": "Proxy server port",
				"description": "Proxy server port",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyUser": {
				"title": "Proxy user",
				"description": "Proxy authentication user",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"accessKey": {
				"title": "API access key (AK)",
				"description": "Access key for the cloud user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"ignoreSslVerification": {
				"title": "SSL Verification Ignored",
				"description": "Ignore SSL verification",
				"type": "boolean",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "API secret key (SK)",
				"description": "Secret key for the cloud user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation",
			"projectId",
			"region",
			"accessKey",
			"secretKey"
		]
	},
	"hwcloud-iam": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "Operation to be performed",
				"type": "string",
				"$comment": "group:producer"
			},
			"accessKey": {
				"title": "API access key (AK)",
				"description": "Access key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"groupId": {
				"title": "Group ID",
				"description": "Group ID to perform operation with",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"ignoreSslVerification": {
				"title": "SSL Verification Ignored",
				"description": "Ignore SSL verification",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"proxyHost": {
				"title": "Proxy server host",
				"description": "Proxy server ip/hostname",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyPassword": {
				"title": "Proxy password",
				"description": "Proxy authentication password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"proxyPort": {
				"title": "Proxy server port",
				"description": "Proxy server port",
				"type": "integer",
				"$comment": "group:producer"
			},
			"proxyUser": {
				"title": "Proxy user",
				"description": "Proxy authentication user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"region": {
				"title": "Service region",
				"description": "IAM service region",
				"type": "string",
				"$comment": "group:producer"
			},
			"secretKey": {
				"title": "API secret key (SK)",
				"description": "Secret key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"serviceKeys": {
				"title": "Service Configuration",
				"description": "Configuration object for cloud service authentication",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.huaweicloud.common.models.ServiceKeys|password"
			},
			"userId": {
				"title": "User ID",
				"description": "User ID to perform operation with",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation",
			"accessKey",
			"region",
			"secretKey"
		]
	},
	"hwcloud-imagerecognition": {
		"properties": {
			"operation": {
				"title": "Operation name",
				"description": "Name of Image Recognition operation to perform, including celebrityRecognition and tagRecognition",
				"type": "string",
				"$comment": "group:producer"
			},
			"accessKey": {
				"title": "Account access key (AK)",
				"description": "Access key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"endpoint": {
				"title": "Service endpoint",
				"description": "Fully qualified Image Recognition service url. Carries higher precedence than region based configuration.",
				"type": "string",
				"$comment": "group:producer"
			},
			"imageContent": {
				"title": "Image in Base64",
				"description": "Indicates the Base64 character string converted from the image. The size cannot exceed 10 MB. The image resolution of the narrow sides must be greater than 15 pixels, and that of the wide sides cannot exceed 4096 pixels.The supported image formats include JPG, PNG, and BMP. Configure either this parameter or imageUrl, and this one carries higher precedence than imageUrl.",
				"type": "string",
				"$comment": "group:producer"
			},
			"imageUrl": {
				"title": "Image Url",
				"description": "Indicates the URL of an image. The options are as follows: HTTP/HTTPS URLs on the public network OBS URLs. To use OBS data, authorization is required, including service authorization, temporary authorization, and anonymous public authorization. For details, see Configuring the Access Permission of OBS. Configure either this parameter or imageContent, and this one carries lower precedence than imageContent.",
				"type": "string",
				"$comment": "group:producer"
			},
			"projectId": {
				"title": "Project ID",
				"description": "Cloud project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyHost": {
				"title": "Proxy server host",
				"description": "Proxy server ip/hostname",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyPassword": {
				"title": "Proxy password",
				"description": "Proxy authentication password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"proxyPort": {
				"title": "Proxy server port",
				"description": "Proxy server port",
				"type": "integer",
				"$comment": "group:producer"
			},
			"proxyUser": {
				"title": "Proxy user",
				"description": "Proxy authentication user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"region": {
				"title": "Service region",
				"description": "Image Recognition service region. Currently only cn-north-1 and cn-north-4 are supported. This is lower precedence than endpoint based configuration.",
				"type": "string",
				"$comment": "group:producer"
			},
			"secretKey": {
				"title": "Account secret key (SK)",
				"description": "Secret key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"serviceKeys": {
				"title": "Service Configuration",
				"description": "Configuration object for cloud service authentication",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.huaweicloud.common.models.ServiceKeys|password"
			},
			"tagLanguage": {
				"title": "Tag Language",
				"description": "Indicates the language of the returned tags when the operation is tagRecognition, including zh and en.",
				"type": "string",
				"$comment": "group:producer",
				"default": "zh"
			},
			"tagLimit": {
				"title": "Tag Limit",
				"description": "Indicates the maximum number of the returned tags when the operation is tagRecognition.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 50
			},
			"threshold": {
				"title": "Threshold of confidence",
				"description": "Indicates the threshold of confidence. When the operation is tagRecognition, this parameter ranges from 0 to 100. Tags whose confidence score is lower than the threshold will not be returned. The default value is 60. When the operation is celebrityRecognition, this parameter ranges from 0 to 1. Labels whose confidence score is lower than the threshold will not be returned. The default value is 0.48.",
				"type": "number",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"ignoreSslVerification": {
				"title": "SSL Verification Ignored",
				"description": "Ignore SSL verification",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation",
			"accessKey",
			"projectId",
			"region",
			"secretKey"
		]
	},
	"hwcloud-obs": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "Operation to be performed",
				"type": "string",
				"$comment": "group:producer"
			},
			"bucketName": {
				"title": "Bucket Name",
				"description": "Name of bucket to perform operation on",
				"type": "string",
				"$comment": "group:common"
			},
			"endpoint": {
				"title": "Endpoint url",
				"description": "OBS url. Carries higher precedence than region parameter based client initialization",
				"type": "string",
				"$comment": "group:common"
			},
			"objectName": {
				"title": "Object Name",
				"description": "Name of object to perform operation with",
				"type": "string",
				"$comment": "group:common"
			},
			"region": {
				"title": "Service region",
				"description": "OBS service region. This is lower precedence than endpoint based configuration",
				"type": "string",
				"$comment": "group:common"
			},
			"deleteAfterRead": {
				"title": "Delete after read",
				"description": "Determines if objects should be deleted after it has been retrieved",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"delimiter": {
				"title": "Delimiter",
				"description": "The character used for grouping object names",
				"type": "string",
				"$comment": "group:consumer"
			},
			"destinationBucket": {
				"title": "Destination Bucket",
				"description": "Name of destination bucket where objects will be moved when moveAfterRead is set to true",
				"type": "string",
				"$comment": "group:consumer"
			},
			"fileName": {
				"title": "File Name",
				"description": "Get the object from the bucket with the given file name",
				"type": "string",
				"$comment": "group:consumer"
			},
			"includeFolders": {
				"title": "Include Folders",
				"description": "If true, objects in folders will be consumed. Otherwise, they will be ignored and no Exchanges will be created for them",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"maxMessagesPerPoll": {
				"title": "Maximum messages per poll",
				"description": "The maximum number of messages to poll at each polling",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"moveAfterRead": {
				"title": "Move After Read",
				"description": "Determines whether objects should be moved to a different bucket after they have been retrieved. The destinationBucket option must also be set for this option to work.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"prefix": {
				"title": "Prefix",
				"description": "The object name prefix used for filtering objects to be listed",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"bucketLocation": {
				"title": "Bucket Location",
				"description": "Location of bucket when creating a new bucket",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"proxyHost": {
				"title": "Proxy server host",
				"description": "Proxy server ip/hostname",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPassword": {
				"title": "Proxy password",
				"description": "Proxy authentication password",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"proxyPort": {
				"title": "Proxy server port",
				"description": "Proxy server port",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyUser": {
				"title": "Proxy user",
				"description": "Proxy authentication user",
				"type": "string",
				"$comment": "group:proxy",
				"format": "password"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "API access key (AK)",
				"description": "Access key for the cloud user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"ignoreSslVerification": {
				"title": "SSL Verification Ignored",
				"description": "Ignore SSL verification",
				"type": "boolean",
				"$comment": "group:security"
			},
			"secretKey": {
				"title": "API secret key (SK)",
				"description": "Secret key for the cloud user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"serviceKeys": {
				"title": "Service Configuration",
				"description": "Configuration object for cloud service authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.huaweicloud.common.models.ServiceKeys|password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation",
			"region",
			"accessKey",
			"secretKey"
		]
	},
	"hwcloud-smn": {
		"properties": {
			"smnService": {
				"title": "Service name",
				"description": "Name of SMN service to invoke",
				"type": "string",
				"$comment": "group:producer"
			},
			"accessKey": {
				"title": "API access key (AK)",
				"description": "Access key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"endpoint": {
				"title": "Service endpoint",
				"description": "Fully qualified smn service url. Carries higher precedence than region parameter based client initialization",
				"type": "string",
				"$comment": "group:producer"
			},
			"ignoreSslVerification": {
				"title": "SSL Verification Ignored",
				"description": "Ignore SSL verification",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"messageTtl": {
				"title": "Message TTL",
				"description": "TTL for published message",
				"type": "integer",
				"$comment": "group:producer",
				"default": 3600
			},
			"operation": {
				"title": "Operation name",
				"description": "Name of operation to perform",
				"type": "string",
				"$comment": "group:producer"
			},
			"projectId": {
				"title": "Project ID",
				"description": "Cloud project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyHost": {
				"title": "Proxy server host",
				"description": "Proxy server ip/hostname",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyPassword": {
				"title": "Proxy password",
				"description": "Proxy authentication password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"proxyPort": {
				"title": "Proxy server port",
				"description": "Proxy server port",
				"type": "integer",
				"$comment": "group:producer"
			},
			"proxyUser": {
				"title": "Proxy user",
				"description": "Proxy authentication user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"region": {
				"title": "Service region",
				"description": "SMN service region. This is lower precedence than endpoint based configuration",
				"type": "string",
				"$comment": "group:producer"
			},
			"secretKey": {
				"title": "API secret key (SK)",
				"description": "Secret key for the cloud user",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"serviceKeys": {
				"title": "Service Configuration",
				"description": "Configuration object for cloud service authentication",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.huaweicloud.common.models.ServiceKeys|password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"smnService",
			"accessKey",
			"operation",
			"projectId",
			"region",
			"secretKey"
		]
	},
	"ibm-secrets-manager": {
		"properties": {
			"label": {
				"title": "Label",
				"description": "Logical name",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Operation to be performed",
				"type": "string",
				"enum": [
					"createArbitrarySecret",
					"createKVSecret",
					"getSecret",
					"deleteSecret",
					"listSecrets"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.ibm.secrets.manager.IBMSecretsManagerOperation"
			},
			"serviceUrl": {
				"title": "Service Url",
				"description": "Service URL for IBM Secrets Manager",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"token": {
				"title": "Token",
				"description": "IBM Cloud API Token for IBM Secrets Manager",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"label"
		]
	},
	"iec60870-client": {
		"properties": {
			"uriPath": {
				"title": "Uri Path",
				"description": "The object information address",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.iec60870.ObjectAddress"
			},
			"dataModuleOptions": {
				"title": "Data Module Options",
				"description": "Data module options",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.client.data.DataModuleOptions"
			},
			"protocolOptions": {
				"title": "Protocol Options",
				"description": "Protocol options",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.ProtocolOptions"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"acknowledgeWindow": {
				"title": "Acknowledge Window",
				"description": "Parameter W - Acknowledgment window.",
				"type": "integer",
				"$comment": "group:connection",
				"default": "10"
			},
			"adsuAddressType": {
				"title": "Adsu Address Type",
				"description": "The common ASDU address size. May be either SIZE_1 or SIZE_2.",
				"type": "string",
				"enum": [
					"SIZE_1",
					"SIZE_2"
				],
				"$comment": "group:connection",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.ASDUAddressType"
			},
			"causeOfTransmissionType": {
				"title": "Cause Of Transmission Type",
				"description": "The cause of transmission type. May be either SIZE_1 or SIZE_2.",
				"type": "string",
				"enum": [
					"SIZE_1",
					"SIZE_2"
				],
				"$comment": "group:connection",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.CauseOfTransmissionType"
			},
			"informationObjectAddressType": {
				"title": "Information Object Address Type",
				"description": "The information address size. May be either SIZE_1, SIZE_2 or SIZE_3.",
				"type": "string",
				"enum": [
					"SIZE_1",
					"SIZE_2",
					"SIZE_3"
				],
				"$comment": "group:connection",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.InformationObjectAddressType"
			},
			"maxUnacknowledged": {
				"title": "Max Unacknowledged",
				"description": "Parameter K - Maximum number of un-acknowledged messages.",
				"type": "integer",
				"$comment": "group:connection",
				"default": "15"
			},
			"timeout1": {
				"title": "Timeout1",
				"description": "Timeout T1 in milliseconds.",
				"type": "integer",
				"$comment": "group:connection",
				"default": 15000
			},
			"timeout2": {
				"title": "Timeout2",
				"description": "Timeout T2 in milliseconds.",
				"type": "integer",
				"$comment": "group:connection",
				"default": 10000
			},
			"timeout3": {
				"title": "Timeout3",
				"description": "Timeout T3 in milliseconds.",
				"type": "integer",
				"$comment": "group:connection",
				"default": 20000
			},
			"causeSourceAddress": {
				"title": "Cause Source Address",
				"description": "Whether to include the source address",
				"type": "integer",
				"$comment": "group:data"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Timeout in millis to wait for client to establish a connected connection.",
				"type": "integer",
				"$comment": "group:data",
				"default": 10000
			},
			"ignoreBackgroundScan": {
				"title": "Ignore Background Scan",
				"description": "Whether background scan transmissions should be ignored.",
				"type": "boolean",
				"$comment": "group:data",
				"default": true
			},
			"ignoreDaylightSavingTime": {
				"title": "Ignore Daylight Saving Time",
				"description": "Whether to ignore or respect DST",
				"type": "boolean",
				"$comment": "group:data"
			},
			"timeZone": {
				"title": "Time Zone",
				"description": "The timezone to use. May be any Java time zone string",
				"type": "string",
				"$comment": "group:data",
				"format": "bean:java.util.TimeZone",
				"default": "UTC"
			},
			"connectionId": {
				"title": "Connection Id",
				"description": "An identifier grouping connection instances",
				"type": "string",
				"$comment": "group:id"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"uriPath"
		]
	},
	"iec60870-server": {
		"properties": {
			"uriPath": {
				"title": "Uri Path",
				"description": "The object information address",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.iec60870.ObjectAddress"
			},
			"dataModuleOptions": {
				"title": "Data Module Options",
				"description": "Data module options",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.client.data.DataModuleOptions"
			},
			"filterNonExecute": {
				"title": "Filter Non Execute",
				"description": "Filter out all requests which don't have the execute bit set",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"protocolOptions": {
				"title": "Protocol Options",
				"description": "Protocol options",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.ProtocolOptions"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"acknowledgeWindow": {
				"title": "Acknowledge Window",
				"description": "Parameter W - Acknowledgment window.",
				"type": "integer",
				"$comment": "group:connection",
				"default": "10"
			},
			"adsuAddressType": {
				"title": "Adsu Address Type",
				"description": "The common ASDU address size. May be either SIZE_1 or SIZE_2.",
				"type": "string",
				"enum": [
					"SIZE_1",
					"SIZE_2"
				],
				"$comment": "group:connection",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.ASDUAddressType"
			},
			"causeOfTransmissionType": {
				"title": "Cause Of Transmission Type",
				"description": "The cause of transmission type. May be either SIZE_1 or SIZE_2.",
				"type": "string",
				"enum": [
					"SIZE_1",
					"SIZE_2"
				],
				"$comment": "group:connection",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.CauseOfTransmissionType"
			},
			"informationObjectAddressType": {
				"title": "Information Object Address Type",
				"description": "The information address size. May be either SIZE_1, SIZE_2 or SIZE_3.",
				"type": "string",
				"enum": [
					"SIZE_1",
					"SIZE_2",
					"SIZE_3"
				],
				"$comment": "group:connection",
				"format": "bean:org.eclipse.neoscada.protocol.iec60870.InformationObjectAddressType"
			},
			"maxUnacknowledged": {
				"title": "Max Unacknowledged",
				"description": "Parameter K - Maximum number of un-acknowledged messages.",
				"type": "integer",
				"$comment": "group:connection",
				"default": "15"
			},
			"timeout1": {
				"title": "Timeout1",
				"description": "Timeout T1 in milliseconds.",
				"type": "integer",
				"$comment": "group:connection",
				"default": 15000
			},
			"timeout2": {
				"title": "Timeout2",
				"description": "Timeout T2 in milliseconds.",
				"type": "integer",
				"$comment": "group:connection",
				"default": 10000
			},
			"timeout3": {
				"title": "Timeout3",
				"description": "Timeout T3 in milliseconds.",
				"type": "integer",
				"$comment": "group:connection",
				"default": 20000
			},
			"causeSourceAddress": {
				"title": "Cause Source Address",
				"description": "Whether to include the source address",
				"type": "integer",
				"$comment": "group:data"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Timeout in millis to wait for client to establish a connected connection.",
				"type": "integer",
				"$comment": "group:data",
				"default": 10000
			},
			"ignoreBackgroundScan": {
				"title": "Ignore Background Scan",
				"description": "Whether background scan transmissions should be ignored.",
				"type": "boolean",
				"$comment": "group:data",
				"default": true
			},
			"ignoreDaylightSavingTime": {
				"title": "Ignore Daylight Saving Time",
				"description": "Whether to ignore or respect DST",
				"type": "boolean",
				"$comment": "group:data"
			},
			"timeZone": {
				"title": "Time Zone",
				"description": "The timezone to use. May be any Java time zone string",
				"type": "string",
				"$comment": "group:data",
				"format": "bean:java.util.TimeZone",
				"default": "UTC"
			},
			"connectionId": {
				"title": "Connection Id",
				"description": "An identifier grouping connection instances",
				"type": "string",
				"$comment": "group:id"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"uriPath"
		]
	},
	"ignite-cache": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The cache name.",
				"type": "string",
				"$comment": "group:common"
			},
			"propagateIncomingBodyIfNoReturnValue": {
				"title": "Propagate Incoming Body If No Return Value",
				"description": "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"treatCollectionsAsCacheObjects": {
				"title": "Treat Collections As Cache Objects",
				"description": "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"autoUnsubscribe": {
				"title": "Auto Unsubscribe",
				"description": "Whether auto unsubscribe is enabled in the Continuous Query Consumer. Default value notice: ContinuousQuery.DFLT_AUTO_UNSUBSCRIBE",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"fireExistingQueryResults": {
				"title": "Fire Existing Query Results",
				"description": "Whether to process existing results that match the query. Used on initialization of the Continuous Query Consumer.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"oneExchangePerUpdate": {
				"title": "One Exchange Per Update",
				"description": "Whether to pack each update in an individual Exchange, even if multiple updates are received in one batch. Only used by the Continuous Query Consumer.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"pageSize": {
				"title": "Page Size",
				"description": "The page size. Only used by the Continuous Query Consumer. Default value notice: ContinuousQuery.DFLT_PAGE_SIZE",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"query": {
				"title": "Query",
				"description": "The Query to execute, only needed for operations that require it, and for the Continuous Query Consumer.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.ignite.cache.query.Query<javax.cache.Cache.Entry<java.lang.Object, java.lang.Object>>"
			},
			"remoteFilter": {
				"title": "Remote Filter",
				"description": "The remote filter, only used by the Continuous Query Consumer.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.ignite.cache.CacheEntryEventSerializableFilter<java.lang.Object, java.lang.Object>"
			},
			"timeInterval": {
				"title": "Time Interval",
				"description": "The time interval for the Continuous Query Consumer. Default value notice: ContinuousQuery.DFLT_TIME_INTERVAL",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 0
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"cachePeekMode": {
				"title": "Cache Peek Mode",
				"description": "The CachePeekMode, only needed for operations that require it (IgniteCacheOperation#SIZE).",
				"type": "string",
				"enum": [
					"ALL",
					"NEAR",
					"PRIMARY",
					"BACKUP",
					"ONHEAP",
					"OFFHEAP"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.ignite.cache.CachePeekMode",
				"default": "ALL"
			},
			"failIfInexistentCache": {
				"title": "Fail If Inexistent Cache",
				"description": "Whether to fail the initialization if the cache doesn't exist.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The cache operation to invoke. Possible values: GET, PUT, REMOVE, SIZE, REBALANCE, QUERY, CLEAR.",
				"type": "string",
				"enum": [
					"GET",
					"PUT",
					"REMOVE",
					"SIZE",
					"REBALANCE",
					"QUERY",
					"CLEAR",
					"REPLACE"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.ignite.cache.IgniteCacheOperation"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"ignite-compute": {
		"properties": {
			"endpointId": {
				"title": "Endpoint Id",
				"description": "The endpoint ID (not used).",
				"type": "string",
				"$comment": "group:producer"
			},
			"clusterGroupExpression": {
				"title": "Cluster Group Expression",
				"description": "An expression that returns the Cluster Group for the IgniteCompute instance.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.ignite.ClusterGroupExpression"
			},
			"computeName": {
				"title": "Compute Name",
				"description": "The name of the compute job, which will be set via IgniteCompute#withName(String).",
				"type": "string",
				"$comment": "group:producer"
			},
			"executionType": {
				"title": "Execution Type",
				"description": "The compute operation to perform. Possible values: CALL, BROADCAST, APPLY, EXECUTE, RUN, AFFINITY_CALL, AFFINITY_RUN. The component expects different payload types depending on the operation.",
				"type": "string",
				"enum": [
					"CALL",
					"BROADCAST",
					"APPLY",
					"EXECUTE",
					"RUN",
					"AFFINITY_CALL",
					"AFFINITY_RUN"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.ignite.compute.IgniteComputeExecutionType"
			},
			"propagateIncomingBodyIfNoReturnValue": {
				"title": "Propagate Incoming Body If No Return Value",
				"description": "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"taskName": {
				"title": "Task Name",
				"description": "The task name, only applicable if using the IgniteComputeExecutionType#EXECUTE execution type.",
				"type": "string",
				"$comment": "group:producer"
			},
			"timeoutMillis": {
				"title": "Timeout Millis",
				"description": "The timeout interval for triggered jobs, in milliseconds, which will be set via IgniteCompute#withTimeout(long).",
				"type": "integer",
				"$comment": "group:producer"
			},
			"treatCollectionsAsCacheObjects": {
				"title": "Treat Collections As Cache Objects",
				"description": "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"endpointId",
			"executionType"
		]
	},
	"ignite-events": {
		"properties": {
			"endpointId": {
				"title": "Endpoint Id",
				"description": "The endpoint ID (not used).",
				"type": "string",
				"$comment": "group:consumer"
			},
			"clusterGroupExpression": {
				"title": "Cluster Group Expression",
				"description": "The cluster group expression.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.ignite.ClusterGroupExpression"
			},
			"events": {
				"title": "Events",
				"description": "The event types to subscribe to as a comma-separated string of event constants as defined in EventType. For example: EVT_CACHE_ENTRY_CREATED,EVT_CACHE_OBJECT_REMOVED,EVT_IGFS_DIR_CREATED.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "EVTS_ALL"
			},
			"propagateIncomingBodyIfNoReturnValue": {
				"title": "Propagate Incoming Body If No Return Value",
				"description": "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"treatCollectionsAsCacheObjects": {
				"title": "Treat Collections As Cache Objects",
				"description": "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"ignite-idgen": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The sequence name.",
				"type": "string",
				"$comment": "group:producer"
			},
			"batchSize": {
				"title": "Batch Size",
				"description": "The batch size.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"initialValue": {
				"title": "Initial Value",
				"description": "The initial value.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "0"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to invoke on the Ignite ID Generator. Superseded by the IgniteConstants.IGNITE_IDGEN_OPERATION header in the IN message. Possible values: ADD_AND_GET, GET, GET_AND_ADD, GET_AND_INCREMENT, INCREMENT_AND_GET.",
				"type": "string",
				"enum": [
					"ADD_AND_GET",
					"GET",
					"GET_AND_ADD",
					"GET_AND_INCREMENT",
					"INCREMENT_AND_GET"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.ignite.idgen.IgniteIdGenOperation"
			},
			"propagateIncomingBodyIfNoReturnValue": {
				"title": "Propagate Incoming Body If No Return Value",
				"description": "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"treatCollectionsAsCacheObjects": {
				"title": "Treat Collections As Cache Objects",
				"description": "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"ignite-messaging": {
		"properties": {
			"topic": {
				"title": "Topic",
				"description": "The topic name.",
				"type": "string",
				"$comment": "group:common"
			},
			"propagateIncomingBodyIfNoReturnValue": {
				"title": "Propagate Incoming Body If No Return Value",
				"description": "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"treatCollectionsAsCacheObjects": {
				"title": "Treat Collections As Cache Objects",
				"description": "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"clusterGroupExpression": {
				"title": "Cluster Group Expression",
				"description": "The cluster group expression.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.ignite.ClusterGroupExpression"
			},
			"sendMode": {
				"title": "Send Mode",
				"description": "The send mode to use. Possible values: UNORDERED, ORDERED.",
				"type": "string",
				"enum": [
					"ORDERED",
					"UNORDERED"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.ignite.messaging.IgniteMessagingSendMode",
				"default": "UNORDERED"
			},
			"timeout": {
				"title": "Timeout",
				"description": "The timeout for the send operation when using ordered messages.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"topic"
		]
	},
	"ignite-queue": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The queue name.",
				"type": "string",
				"$comment": "group:producer"
			},
			"capacity": {
				"title": "Capacity",
				"description": "The queue capacity. Default: non-bounded.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"configuration": {
				"title": "Configuration",
				"description": "The collection configuration. Default: empty configuration. You can also conveniently set inner properties by using configuration.xyz=123 options.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.ignite.configuration.CollectionConfiguration"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to invoke on the Ignite Queue. Superseded by the IgniteConstants.IGNITE_QUEUE_OPERATION header in the IN message. Possible values: CONTAINS, ADD, SIZE, REMOVE, ITERATOR, CLEAR, RETAIN_ALL, ARRAY, DRAIN, ELEMENT, PEEK, OFFER, POLL, TAKE, PUT.",
				"type": "string",
				"enum": [
					"CONTAINS",
					"ADD",
					"SIZE",
					"REMOVE",
					"ITERATOR",
					"CLEAR",
					"RETAIN_ALL",
					"ARRAY",
					"DRAIN",
					"ELEMENT",
					"PEEK",
					"OFFER",
					"POLL",
					"TAKE",
					"PUT"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.ignite.queue.IgniteQueueOperation"
			},
			"propagateIncomingBodyIfNoReturnValue": {
				"title": "Propagate Incoming Body If No Return Value",
				"description": "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"timeoutMillis": {
				"title": "Timeout Millis",
				"description": "The queue timeout in milliseconds. Default: no timeout.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"treatCollectionsAsCacheObjects": {
				"title": "Treat Collections As Cache Objects",
				"description": "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"ignite-set": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The set name.",
				"type": "string",
				"$comment": "group:producer"
			},
			"configuration": {
				"title": "Configuration",
				"description": "The collection configuration. Default: empty configuration. You can also conveniently set inner properties by using configuration.xyz=123 options.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.ignite.configuration.CollectionConfiguration"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to invoke on the Ignite Set. Superseded by the IgniteConstants.IGNITE_SETS_OPERATION header in the IN message. Possible values: CONTAINS, ADD, SIZE, REMOVE, ITERATOR, CLEAR, RETAIN_ALL, ARRAY.The set operation to perform.",
				"type": "string",
				"enum": [
					"CONTAINS",
					"ADD",
					"SIZE",
					"REMOVE",
					"ITERATOR",
					"CLEAR",
					"RETAIN_ALL",
					"ARRAY"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.ignite.set.IgniteSetOperation"
			},
			"propagateIncomingBodyIfNoReturnValue": {
				"title": "Propagate Incoming Body If No Return Value",
				"description": "Sets whether to propagate the incoming body if the return type of the underlying Ignite operation is void.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"treatCollectionsAsCacheObjects": {
				"title": "Treat Collections As Cache Objects",
				"description": "Sets whether to treat Collections as cache objects or as Collections of items to insert/update/compute, etc.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"imap": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The mail server host name",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The port number of the mail server",
				"type": "integer",
				"$comment": "group:common"
			},
			"closeFolder": {
				"title": "Close Folder",
				"description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keeps the folder open between polls.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"copyTo": {
				"title": "Copy To",
				"description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"decodeFilename": {
				"title": "Decode Filename",
				"description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"delete": {
				"title": "Delete",
				"description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. You can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether the consumer should disconnect after polling. If enabled, this forces Camel to connect on each poll.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"handleFailedMessage": {
				"title": "Handle Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows handling the caused exception by the consumer's error handler. By enabling the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"mimeDecodeHeaders": {
				"title": "Mime Decode Headers",
				"description": "This option enables transparent MIME decoding and unfolding for mail headers.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveTo": {
				"title": "Move To",
				"description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"peek": {
				"title": "Peek",
				"description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek, the mail will not be eagerly marked as SEEN on the mail server, which allows us to roll back the mail message if there is a processing error in Camel.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"skipFailedMessage": {
				"title": "Skip Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows skipping the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"unseen": {
				"title": "Unseen",
				"description": "Whether to limit by unseen mails only.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"failOnDuplicateFileAttachment": {
				"title": "Fail On Duplicate File Attachment",
				"description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true, then an exception is thrown failing to process the mail message.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"fetchSize": {
				"title": "Fetch Size",
				"description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. The default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": -1
			},
			"folderName": {
				"title": "Folder Name",
				"description": "The folder to poll.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "INBOX"
			},
			"generateMissingAttachmentNames": {
				"title": "Generate Missing Attachment Names",
				"description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"handleDuplicateAttachmentNames": {
				"title": "Handle Duplicate Attachment Names",
				"description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with an uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with an underscore and uuid (filename_uuid.fileextension).",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"mailUidGenerator": {
				"title": "Mail Uid Generator",
				"description": "A pluggable MailUidGenerator that allows to use custom logic to generate UUID of the mail message.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailUidGenerator"
			},
			"mapMailMessage": {
				"title": "Map Mail Message",
				"description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false, then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"postProcessAction": {
				"title": "Post Process Action",
				"description": "Refers to an MailBoxPostProcessAction for doing post processing tasks on the mailbox once the normal processing ended.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailBoxPostProcessAction"
			},
			"bcc": {
				"title": "Bcc",
				"description": "Sets the BCC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"cc": {
				"title": "Cc",
				"description": "Sets the CC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"from": {
				"title": "From",
				"description": "The from email address",
				"type": "string",
				"$comment": "group:producer",
				"default": "camel@localhost"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"subject": {
				"title": "Subject",
				"description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
				"type": "string",
				"$comment": "group:producer"
			},
			"to": {
				"title": "To",
				"description": "Sets the destination email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"javaMailSender": {
				"title": "Java Mail Sender",
				"description": "To use a custom org.apache.camel.component.mail.JavaMailSender for sending emails.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.mail.JavaMailSender"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"additionalJavaMailProperties": {
				"title": "Additional Java Mail Properties",
				"description": "Sets additional java mail properties, that will append/override any default properties that are set based on all the other options. This is useful if you need to add some special options but want to keep the others as is.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"alternativeBodyHeader": {
				"title": "Alternative Body Header",
				"description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "CamelMailAlternativeBody"
			},
			"attachmentsContentTransferEncodingResolver": {
				"title": "Attachments Content Transfer Encoding Resolver",
				"description": "To use a custom AttachmentsContentTransferEncodingResolver to resolve what content-type-encoding to use for attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.AttachmentsContentTransferEncodingResolver"
			},
			"authenticator": {
				"title": "Authenticator",
				"description": "The authenticator for login. If set then the password and username are ignored. It can be used for tokens which can expire and therefore must be read dynamically.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailAuthenticator"
			},
			"binding": {
				"title": "Binding",
				"description": "Sets the binding used to convert from a Camel message to and from a Mail message",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailBinding"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "The connection timeout in milliseconds.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 30000
			},
			"contentType": {
				"title": "Content Type",
				"description": "The mail message content type. Use text/html for HTML mails.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "text/plain"
			},
			"contentTypeResolver": {
				"title": "Content Type Resolver",
				"description": "Resolver to determine Content-Type for file attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.ContentTypeResolver"
			},
			"debugMode": {
				"title": "Debug Mode",
				"description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"ignoreUnsupportedCharset": {
				"title": "Ignore Unsupported Charset",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"ignoreUriScheme": {
				"title": "Ignore Uri Scheme",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"javaMailProperties": {
				"title": "Java Mail Properties",
				"description": "Sets the java mail options. Will clear any default properties and only use the properties provided for this method.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"session": {
				"title": "Session",
				"description": "Specifies the mail session that camel should use for all mail interactions. Useful in scenarios where mail sessions are created and managed by some other resource, such as a JavaEE container. When using a custom mail session, then the hostname and port from the mail session will be used (if configured on the session).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.mail.Session"
			},
			"useInlineAttachments": {
				"title": "Use Inline Attachments",
				"description": "Whether to use disposition inline or attachment.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which allows to cluster consuming from the same mailbox, and let the repository coordinate whether a mail message is valid for the consumer to process. By default no repository is in use.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"idempotentRepositoryRemoveOnCommit": {
				"title": "Idempotent Repository Remove On Commit",
				"description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"searchTerm": {
				"title": "Search Term",
				"description": "Refers to a jakarta.mail.search.SearchTerm which allows to filter mails based on search criteria such as subject, body, from, sent after a certain date etc.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:jakarta.mail.search.SearchTerm"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "60000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "The password for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"username": {
				"title": "Username",
				"description": "The username for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sortTerm": {
				"title": "Sort Term",
				"description": "Sorting order for messages. Only natively supported for IMAP. Emulated to some degree when using POP3 or when IMAP server does not have the SORT capability.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:org.eclipse.angus.mail.imap.SortTerm[]"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"imaps": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The mail server host name",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The port number of the mail server",
				"type": "integer",
				"$comment": "group:common"
			},
			"closeFolder": {
				"title": "Close Folder",
				"description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keeps the folder open between polls.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"copyTo": {
				"title": "Copy To",
				"description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"decodeFilename": {
				"title": "Decode Filename",
				"description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"delete": {
				"title": "Delete",
				"description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. You can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether the consumer should disconnect after polling. If enabled, this forces Camel to connect on each poll.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"handleFailedMessage": {
				"title": "Handle Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows handling the caused exception by the consumer's error handler. By enabling the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"mimeDecodeHeaders": {
				"title": "Mime Decode Headers",
				"description": "This option enables transparent MIME decoding and unfolding for mail headers.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveTo": {
				"title": "Move To",
				"description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"peek": {
				"title": "Peek",
				"description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek, the mail will not be eagerly marked as SEEN on the mail server, which allows us to roll back the mail message if there is a processing error in Camel.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"skipFailedMessage": {
				"title": "Skip Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows skipping the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"unseen": {
				"title": "Unseen",
				"description": "Whether to limit by unseen mails only.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"failOnDuplicateFileAttachment": {
				"title": "Fail On Duplicate File Attachment",
				"description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true, then an exception is thrown failing to process the mail message.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"fetchSize": {
				"title": "Fetch Size",
				"description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. The default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": -1
			},
			"folderName": {
				"title": "Folder Name",
				"description": "The folder to poll.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "INBOX"
			},
			"generateMissingAttachmentNames": {
				"title": "Generate Missing Attachment Names",
				"description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"handleDuplicateAttachmentNames": {
				"title": "Handle Duplicate Attachment Names",
				"description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with an uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with an underscore and uuid (filename_uuid.fileextension).",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"mailUidGenerator": {
				"title": "Mail Uid Generator",
				"description": "A pluggable MailUidGenerator that allows to use custom logic to generate UUID of the mail message.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailUidGenerator"
			},
			"mapMailMessage": {
				"title": "Map Mail Message",
				"description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false, then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"postProcessAction": {
				"title": "Post Process Action",
				"description": "Refers to an MailBoxPostProcessAction for doing post processing tasks on the mailbox once the normal processing ended.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailBoxPostProcessAction"
			},
			"bcc": {
				"title": "Bcc",
				"description": "Sets the BCC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"cc": {
				"title": "Cc",
				"description": "Sets the CC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"from": {
				"title": "From",
				"description": "The from email address",
				"type": "string",
				"$comment": "group:producer",
				"default": "camel@localhost"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"subject": {
				"title": "Subject",
				"description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
				"type": "string",
				"$comment": "group:producer"
			},
			"to": {
				"title": "To",
				"description": "Sets the destination email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"javaMailSender": {
				"title": "Java Mail Sender",
				"description": "To use a custom org.apache.camel.component.mail.JavaMailSender for sending emails.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.mail.JavaMailSender"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"additionalJavaMailProperties": {
				"title": "Additional Java Mail Properties",
				"description": "Sets additional java mail properties, that will append/override any default properties that are set based on all the other options. This is useful if you need to add some special options but want to keep the others as is.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"alternativeBodyHeader": {
				"title": "Alternative Body Header",
				"description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "CamelMailAlternativeBody"
			},
			"attachmentsContentTransferEncodingResolver": {
				"title": "Attachments Content Transfer Encoding Resolver",
				"description": "To use a custom AttachmentsContentTransferEncodingResolver to resolve what content-type-encoding to use for attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.AttachmentsContentTransferEncodingResolver"
			},
			"authenticator": {
				"title": "Authenticator",
				"description": "The authenticator for login. If set then the password and username are ignored. It can be used for tokens which can expire and therefore must be read dynamically.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailAuthenticator"
			},
			"binding": {
				"title": "Binding",
				"description": "Sets the binding used to convert from a Camel message to and from a Mail message",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailBinding"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "The connection timeout in milliseconds.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 30000
			},
			"contentType": {
				"title": "Content Type",
				"description": "The mail message content type. Use text/html for HTML mails.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "text/plain"
			},
			"contentTypeResolver": {
				"title": "Content Type Resolver",
				"description": "Resolver to determine Content-Type for file attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.ContentTypeResolver"
			},
			"debugMode": {
				"title": "Debug Mode",
				"description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"ignoreUnsupportedCharset": {
				"title": "Ignore Unsupported Charset",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"ignoreUriScheme": {
				"title": "Ignore Uri Scheme",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"javaMailProperties": {
				"title": "Java Mail Properties",
				"description": "Sets the java mail options. Will clear any default properties and only use the properties provided for this method.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"session": {
				"title": "Session",
				"description": "Specifies the mail session that camel should use for all mail interactions. Useful in scenarios where mail sessions are created and managed by some other resource, such as a JavaEE container. When using a custom mail session, then the hostname and port from the mail session will be used (if configured on the session).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.mail.Session"
			},
			"useInlineAttachments": {
				"title": "Use Inline Attachments",
				"description": "Whether to use disposition inline or attachment.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which allows to cluster consuming from the same mailbox, and let the repository coordinate whether a mail message is valid for the consumer to process. By default no repository is in use.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"idempotentRepositoryRemoveOnCommit": {
				"title": "Idempotent Repository Remove On Commit",
				"description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"searchTerm": {
				"title": "Search Term",
				"description": "Refers to a jakarta.mail.search.SearchTerm which allows to filter mails based on search criteria such as subject, body, from, sent after a certain date etc.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:jakarta.mail.search.SearchTerm"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "60000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "The password for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"username": {
				"title": "Username",
				"description": "The username for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sortTerm": {
				"title": "Sort Term",
				"description": "Sorting order for messages. Only natively supported for IMAP. Emulated to some degree when using POP3 or when IMAP server does not have the SORT capability.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:org.eclipse.angus.mail.imap.SortTerm[]"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"infinispan": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache to use. Use current to use the existing cache name from the currently configured cached manager. Or use default for the default cache manager name.",
				"type": "string",
				"$comment": "group:common"
			},
			"hosts": {
				"title": "Hosts",
				"description": "Specifies the host of the cache on Infinispan instance. Multiple hosts can be separated by semicolon.",
				"type": "string",
				"$comment": "group:common"
			},
			"queryBuilder": {
				"title": "Query Builder",
				"description": "Specifies the query builder.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.infinispan.InfinispanQueryBuilder"
			},
			"customListener": {
				"title": "Custom Listener",
				"description": "Returns the custom listener in use, if provided",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.infinispan.remote.InfinispanRemoteCustomListener"
			},
			"eventTypes": {
				"title": "Event Types",
				"description": "Specifies the set of event types to register by the consumer.Multiple event can be separated by comma. The possible event types are: CLIENT_CACHE_ENTRY_CREATED, CLIENT_CACHE_ENTRY_MODIFIED, CLIENT_CACHE_ENTRY_REMOVED, CLIENT_CACHE_ENTRY_EXPIRED, CLIENT_CACHE_FAILOVER",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"defaultValue": {
				"title": "Default Value",
				"description": "Set a specific default value for some producer operations",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"key": {
				"title": "Key",
				"description": "Set a specific key for producer operations",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"oldValue": {
				"title": "Old Value",
				"description": "Set a specific old value for some producer operations",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"PUT",
					"PUTASYNC",
					"PUTALL",
					"PUTALLASYNC",
					"PUTIFABSENT",
					"PUTIFABSENTASYNC",
					"GET",
					"GETORDEFAULT",
					"CONTAINSKEY",
					"CONTAINSVALUE",
					"REMOVE",
					"REMOVEASYNC",
					"REPLACE",
					"REPLACEASYNC",
					"SIZE",
					"CLEAR",
					"CLEARASYNC",
					"QUERY",
					"STATS",
					"COMPUTE",
					"COMPUTEASYNC"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.infinispan.InfinispanOperation",
				"default": "PUT"
			},
			"value": {
				"title": "Value",
				"description": "Set a specific value for producer operations",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"embeddingStoreDimension": {
				"title": "Embedding Store Dimension",
				"description": "The dimension size used to store vector embeddings. This should be equal to the dimension size of the model used to create the vector embeddings. This option is mandatory if the embedding store is enabled.",
				"type": "integer",
				"$comment": "group:producer (advanced)"
			},
			"embeddingStoreDistance": {
				"title": "Embedding Store Distance",
				"description": "The distance to use for kNN search queries in relation to the configured vector similarity.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": 3
			},
			"embeddingStoreEnabled": {
				"title": "Embedding Store Enabled",
				"description": "Whether to enable the embedding store. When enabled, the embedding store will be configured automatically when Camel starts. Note that this feature requires camel-langchain4j-embeddings to be on the classpath.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"embeddingStoreRegisterSchema": {
				"title": "Embedding Store Register Schema",
				"description": "Whether to automatically register the proto schema for the types required by embedding store cache put and query operations.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"embeddingStoreTypeName": {
				"title": "Embedding Store Type Name",
				"description": "The name of the type used to store embeddings. The default is 'InfinispanRemoteEmbedding' suffixed with the value of the embeddingStoreDimension option. E.g. CamelInfinispanRemoteEmbedding384.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"embeddingStoreVectorSimilarity": {
				"title": "Embedding Store Vector Similarity",
				"description": "The vector similarity algorithm used to store embeddings.",
				"type": "string",
				"enum": [
					"L2",
					"INNER_PRODUCT",
					"MAX_INNER_PRODUCT",
					"COSINE"
				],
				"$comment": "group:producer (advanced)",
				"format": "bean:org.infinispan.api.annotations.indexing.option.VectorSimilarity",
				"default": "COSINE"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"cacheContainer": {
				"title": "Cache Container",
				"description": "Specifies the cache Container to connect",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.infinispan.client.hotrod.RemoteCacheManager"
			},
			"cacheContainerConfiguration": {
				"title": "Cache Container Configuration",
				"description": "The CacheContainer configuration. Used if the cacheContainer is not defined.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.infinispan.client.hotrod.configuration.Configuration"
			},
			"configurationProperties": {
				"title": "Configuration Properties",
				"description": "Implementation specific properties for the CacheManager",
				"type": "object",
				"$comment": "group:advanced"
			},
			"configurationUri": {
				"title": "Configuration Uri",
				"description": "An implementation specific URI for the CacheManager",
				"type": "string",
				"$comment": "group:advanced"
			},
			"flags": {
				"title": "Flags",
				"description": "A comma separated list of org.infinispan.client.hotrod.Flag to be applied by default on each cache invocation.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"remappingFunction": {
				"title": "Remapping Function",
				"description": "Set a specific remappingFunction to use in a compute operation.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.function.BiFunction"
			},
			"resultHeader": {
				"title": "Result Header",
				"description": "Store the operation result in a header instead of the message body. By default, resultHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If resultHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved. This value can be overridden by an in message header named: CamelInfinispanOperationResultHeader",
				"type": "string",
				"$comment": "group:advanced"
			},
			"password": {
				"title": "Password",
				"description": "Define the password to access the infinispan instance",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"saslMechanism": {
				"title": "Sasl Mechanism",
				"description": "Define the SASL Mechanism to access the infinispan instance",
				"type": "string",
				"$comment": "group:security"
			},
			"secure": {
				"title": "Secure",
				"description": "Define if we are connecting to a secured Infinispan instance",
				"type": "boolean",
				"$comment": "group:security"
			},
			"securityRealm": {
				"title": "Security Realm",
				"description": "Define the security realm to access the infinispan instance",
				"type": "string",
				"$comment": "group:security"
			},
			"securityServerName": {
				"title": "Security Server Name",
				"description": "Define the security server name to access the infinispan instance",
				"type": "string",
				"$comment": "group:security"
			},
			"username": {
				"title": "Username",
				"description": "Define the username to access the infinispan instance",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"infinispan-embedded": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache to use. Use current to use the existing cache name from the currently configured cached manager. Or use default for the default cache manager name.",
				"type": "string",
				"$comment": "group:common"
			},
			"queryBuilder": {
				"title": "Query Builder",
				"description": "Specifies the query builder.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.infinispan.InfinispanQueryBuilder"
			},
			"clusteredListener": {
				"title": "Clustered Listener",
				"description": "If true, the listener will be installed for the entire cluster",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"customListener": {
				"title": "Custom Listener",
				"description": "Returns the custom listener in use, if provided",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.infinispan.embedded.InfinispanEmbeddedCustomListener"
			},
			"eventTypes": {
				"title": "Event Types",
				"description": "Specifies the set of event types to register by the consumer.Multiple event can be separated by comma. The possible event types are: CACHE_ENTRY_ACTIVATED, CACHE_ENTRY_PASSIVATED, CACHE_ENTRY_VISITED, CACHE_ENTRY_LOADED, CACHE_ENTRY_EVICTED, CACHE_ENTRY_CREATED, CACHE_ENTRY_REMOVED, CACHE_ENTRY_MODIFIED, TRANSACTION_COMPLETED, TRANSACTION_REGISTERED, CACHE_ENTRY_INVALIDATED, CACHE_ENTRY_EXPIRED, DATA_REHASHED, TOPOLOGY_CHANGED, PARTITION_STATUS_CHANGED, PERSISTENCE_AVAILABILITY_CHANGED",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sync": {
				"title": "Sync",
				"description": "If true, the consumer will receive notifications synchronously",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"defaultValue": {
				"title": "Default Value",
				"description": "Set a specific default value for some producer operations",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"key": {
				"title": "Key",
				"description": "Set a specific key for producer operations",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"oldValue": {
				"title": "Old Value",
				"description": "Set a specific old value for some producer operations",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform",
				"type": "string",
				"enum": [
					"PUT",
					"PUTASYNC",
					"PUTALL",
					"PUTALLASYNC",
					"PUTIFABSENT",
					"PUTIFABSENTASYNC",
					"GET",
					"GETORDEFAULT",
					"CONTAINSKEY",
					"CONTAINSVALUE",
					"REMOVE",
					"REMOVEASYNC",
					"REPLACE",
					"REPLACEASYNC",
					"SIZE",
					"CLEAR",
					"CLEARASYNC",
					"QUERY",
					"STATS",
					"COMPUTE",
					"COMPUTEASYNC"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.infinispan.InfinispanOperation",
				"default": "PUT"
			},
			"value": {
				"title": "Value",
				"description": "Set a specific value for producer operations",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"cacheContainer": {
				"title": "Cache Container",
				"description": "Specifies the cache Container to connect",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.infinispan.manager.EmbeddedCacheManager"
			},
			"cacheContainerConfiguration": {
				"title": "Cache Container Configuration",
				"description": "The CacheContainer configuration. Used if the cacheContainer is not defined.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.infinispan.configuration.cache.Configuration"
			},
			"configurationUri": {
				"title": "Configuration Uri",
				"description": "An implementation specific URI for the CacheManager",
				"type": "string",
				"$comment": "group:advanced"
			},
			"flags": {
				"title": "Flags",
				"description": "A comma separated list of org.infinispan.context.Flag to be applied by default on each cache invocation",
				"type": "string",
				"$comment": "group:advanced"
			},
			"remappingFunction": {
				"title": "Remapping Function",
				"description": "Set a specific remappingFunction to use in a compute operation.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.function.BiFunction"
			},
			"resultHeader": {
				"title": "Result Header",
				"description": "Store the operation result in a header instead of the message body. By default, resultHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If resultHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved. This value can be overridden by an in message header named: CamelInfinispanOperationResultHeader",
				"type": "string",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"influxdb": {
		"properties": {
			"connectionBean": {
				"title": "Connection Bean",
				"description": "Connection to the influx database, of class InfluxDB.class",
				"type": "string",
				"$comment": "group:producer"
			},
			"autoCreateDatabase": {
				"title": "Auto Create Database",
				"description": "Define if we want to auto create the database if it's not present",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"batch": {
				"title": "Batch",
				"description": "Define if this operation is a batch operation or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"checkDatabaseExistence": {
				"title": "Check Database Existence",
				"description": "Define if we want to check the database existence while starting the endpoint",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"databaseName": {
				"title": "Database Name",
				"description": "The name of the database where the time series will be stored",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Define if this operation is an insert or a query",
				"type": "string",
				"$comment": "group:producer",
				"default": "insert"
			},
			"query": {
				"title": "Query",
				"description": "Define the query in case of operation query",
				"type": "string",
				"$comment": "group:producer"
			},
			"retentionPolicy": {
				"title": "Retention Policy",
				"description": "The string that defines the retention policy to the data created by the endpoint",
				"type": "string",
				"$comment": "group:producer",
				"default": "default"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"connectionBean"
		]
	},
	"influxdb2": {
		"properties": {
			"connectionBean": {
				"title": "Connection Bean",
				"description": "Connection to the Influx database, of class com.influxdb.client.InfluxDBClient.class.",
				"type": "string",
				"$comment": "group:producer"
			},
			"autoCreateBucket": {
				"title": "Auto Create Bucket",
				"description": "Define if we want to auto create the bucket if it's not present.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"autoCreateOrg": {
				"title": "Auto Create Org",
				"description": "Define if we want to auto create the organization if it's not present.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"bucket": {
				"title": "Bucket",
				"description": "The name of the bucket where the time series will be stored.",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Define if this operation is an insert of ping.",
				"type": "string",
				"enum": [
					"INSERT",
					"PING"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.influxdb2.enums.Operation",
				"default": "INSERT"
			},
			"org": {
				"title": "Org",
				"description": "The name of the organization where the time series will be stored.",
				"type": "string",
				"$comment": "group:producer"
			},
			"retentionPolicy": {
				"title": "Retention Policy",
				"description": "Define the retention policy to the data created by the endpoint.",
				"type": "string",
				"$comment": "group:producer",
				"default": "default"
			},
			"writePrecision": {
				"title": "Write Precision",
				"description": "The format or precision of time series timestamps.",
				"type": "string",
				"enum": [
					"ms",
					"s",
					"us",
					"ns"
				],
				"$comment": "group:producer",
				"format": "bean:com.influxdb.client.domain.WritePrecision",
				"default": "ms"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"connectionBean",
			"bucket",
			"org"
		]
	},
	"irc": {
		"properties": {
			"hostname": {
				"title": "Hostname",
				"description": "Hostname for the IRC chat server",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port number for the IRC chat server. If no port is configured then a default port of either 6667, 6668 or 6669 is used.",
				"type": "integer",
				"$comment": "group:common"
			},
			"autoRejoin": {
				"title": "Auto Rejoin",
				"description": "Whether to auto re-join when being kicked",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"channels": {
				"title": "Channels",
				"description": "Comma separated list of IRC channels.",
				"type": "string",
				"$comment": "group:common"
			},
			"commandTimeout": {
				"title": "Command Timeout",
				"description": "Delay in milliseconds before sending commands after the connection is established.",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"keys": {
				"title": "Keys",
				"description": "Comma separated list of keys for channels.",
				"type": "string",
				"$comment": "group:common"
			},
			"namesOnJoin": {
				"title": "Names On Join",
				"description": "Sends NAMES command to channel after joining it. onReply has to be true in order to process the result which will have the header value irc.num = '353'.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"nickname": {
				"title": "Nickname",
				"description": "The nickname used in chat.",
				"type": "string",
				"$comment": "group:common"
			},
			"persistent": {
				"title": "Persistent",
				"description": "Use persistent messages.",
				"type": "boolean",
				"$comment": "group:common",
				"deprecated": true,
				"default": true
			},
			"realname": {
				"title": "Realname",
				"description": "The IRC user's actual name.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"colors": {
				"title": "Colors",
				"description": "Whether or not the server supports color codes.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"onJoin": {
				"title": "On Join",
				"description": "Handle user join events.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"onKick": {
				"title": "On Kick",
				"description": "Handle kick events.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"onMode": {
				"title": "On Mode",
				"description": "Handle mode change events.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"onNick": {
				"title": "On Nick",
				"description": "Handle nickname change events.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"onPart": {
				"title": "On Part",
				"description": "Handle user part events.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"onPrivmsg": {
				"title": "On Privmsg",
				"description": "Handle private message events.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"onQuit": {
				"title": "On Quit",
				"description": "Handle user quit events.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"onReply": {
				"title": "On Reply",
				"description": "Whether or not to handle general responses to commands or informational messages.",
				"type": "boolean",
				"$comment": "group:filter"
			},
			"onTopic": {
				"title": "On Topic",
				"description": "Handle topic change events.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"nickPassword": {
				"title": "Nick Password",
				"description": "Your IRC server nickname password.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "The IRC server password.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "Used for configuring security using SSL. Reference to a org.apache.camel.support.jsse.SSLContextParameters in the Registry. This reference overrides any configured SSLContextParameters at the component level. Note that this setting overrides the trustManager option.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"trustManager": {
				"title": "Trust Manager",
				"description": "The trust manager used to verify the SSL server's certificate.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.schwering.irc.lib.ssl.SSLTrustManager"
			},
			"username": {
				"title": "Username",
				"description": "The IRC server user name.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"hostname"
		]
	},
	"ironmq": {
		"properties": {
			"queueName": {
				"title": "Queue Name",
				"description": "The name of the IronMQ queue",
				"type": "string",
				"$comment": "group:common"
			},
			"ironMQCloud": {
				"title": "Iron MQCloud",
				"description": "IronMq Cloud url. Urls for public clusters: https://mq-aws-us-east-1-1.iron.io (US) and https://mq-aws-eu-west-1-1.iron.io (EU)",
				"type": "string",
				"$comment": "group:common",
				"default": "https://mq-aws-us-east-1-1.iron.io"
			},
			"preserveHeaders": {
				"title": "Preserve Headers",
				"description": "Should message headers be preserved when publishing messages. This will add the Camel headers to the Iron MQ message as a json payload with a header list, and a message body. Useful when Camel is both consumer and producer.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"projectId": {
				"title": "Project Id",
				"description": "IronMQ projectId",
				"type": "string",
				"$comment": "group:common"
			},
			"batchDelete": {
				"title": "Batch Delete",
				"description": "Should messages be deleted in one batch. This will limit the number of api requests since messages are deleted in one request, instead of one per exchange. If enabled care should be taken that the consumer is idempotent when processing exchanges.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "The number of concurrent consumers.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Number of messages to poll per call. Maximum is 100.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"timeout": {
				"title": "Timeout",
				"description": "After timeout (in seconds), item will be placed back onto the queue.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 60
			},
			"wait": {
				"title": "Wait",
				"description": "Time in seconds to wait for a message to become available. This enables long polling. Default is 0 (does not wait), maximum is 30.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"visibilityDelay": {
				"title": "Visibility Delay",
				"description": "The item will not be available on the queue until this many seconds have passed. Default is 0 seconds.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"client": {
				"title": "Client",
				"description": "Reference to a io.iron.ironmq.Client in the Registry.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.iron.ironmq.Client"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"token": {
				"title": "Token",
				"description": "IronMQ token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"queueName"
		]
	},
	"jcache": {
		"properties": {
			"cacheName": {
				"title": "Cache Name",
				"description": "The name of the cache",
				"type": "string",
				"$comment": "group:common"
			},
			"cacheConfigurationProperties": {
				"title": "Cache Configuration Properties",
				"description": "The Properties for the javax.cache.spi.CachingProvider to create the CacheManager",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.util.Properties"
			},
			"cachingProvider": {
				"title": "Caching Provider",
				"description": "The fully qualified class name of the javax.cache.spi.CachingProvider",
				"type": "string",
				"$comment": "group:common"
			},
			"configurationUri": {
				"title": "Configuration Uri",
				"description": "An implementation specific URI for the CacheManager",
				"type": "string",
				"$comment": "group:common"
			},
			"managementEnabled": {
				"title": "Management Enabled",
				"description": "Whether management gathering is enabled",
				"type": "boolean",
				"$comment": "group:common"
			},
			"readThrough": {
				"title": "Read Through",
				"description": "If read-through caching should be used",
				"type": "boolean",
				"$comment": "group:common"
			},
			"statisticsEnabled": {
				"title": "Statistics Enabled",
				"description": "Whether statistics gathering is enabled",
				"type": "boolean",
				"$comment": "group:common"
			},
			"storeByValue": {
				"title": "Store By Value",
				"description": "If cache should use store-by-value or store-by-reference semantics",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"writeThrough": {
				"title": "Write Through",
				"description": "If write-through caching should be used",
				"type": "boolean",
				"$comment": "group:common"
			},
			"filteredEvents": {
				"title": "Filtered Events",
				"description": "Events a consumer should filter (multiple events can be separated by comma). If using filteredEvents option, then eventFilters one will be ignored",
				"type": "string",
				"enum": [
					"CREATED",
					"UPDATED",
					"REMOVED",
					"EXPIRED"
				],
				"$comment": "group:consumer"
			},
			"oldValueRequired": {
				"title": "Old Value Required",
				"description": "if the old value is required for events",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "if the event listener should block the thread causing the event",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eventFilters": {
				"title": "Event Filters",
				"description": "The CacheEntryEventFilter. If using eventFilters option, then filteredEvents one will be ignored",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"action": {
				"title": "Action",
				"description": "To configure using a cache operation by default. If an operation in the message header, then the operation from the header takes precedence.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"cacheConfiguration": {
				"title": "Cache Configuration",
				"description": "A Configuration for the Cache",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.cache.configuration.Configuration"
			},
			"cacheLoaderFactory": {
				"title": "Cache Loader Factory",
				"description": "The CacheLoader factory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.cache.configuration.Factory<javax.cache.integration.CacheLoader>"
			},
			"cacheWriterFactory": {
				"title": "Cache Writer Factory",
				"description": "The CacheWriter factory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.cache.configuration.Factory<javax.cache.integration.CacheWriter>"
			},
			"createCacheIfNotExists": {
				"title": "Create Cache If Not Exists",
				"description": "Configure if a cache need to be created if it does exist or can't be pre-configured.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"expiryPolicyFactory": {
				"title": "Expiry Policy Factory",
				"description": "The ExpiryPolicy factory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.cache.configuration.Factory<javax.cache.expiry.ExpiryPolicy>"
			},
			"lookupProviders": {
				"title": "Lookup Providers",
				"description": "Configure if a camel-cache should try to find implementations of jcache api in runtimes like OSGi.",
				"type": "boolean",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"cacheName"
		]
	},
	"jcr": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Name of the javax.jcr.Repository to lookup from the Camel registry to be used.",
				"type": "string",
				"$comment": "group:common"
			},
			"base": {
				"title": "Base",
				"description": "Get the base node when accessing the repository",
				"type": "string",
				"$comment": "group:common"
			},
			"deep": {
				"title": "Deep",
				"description": "When isDeep is true, events whose associated parent node is at absPath or within its subgraph are received.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"eventTypes": {
				"title": "Event Types",
				"description": "eventTypes (a combination of one or more event types encoded as a bit mask value such as javax.jcr.observation.Event.NODE_ADDED, javax.jcr.observation.Event.NODE_REMOVED, etc.).",
				"type": "integer",
				"$comment": "group:common"
			},
			"nodeTypeNames": {
				"title": "Node Type Names",
				"description": "When a comma separated nodeTypeName list string is set, only events whose associated parent node has one of the node types (or a subtype of one of the node types) in this list will be received.",
				"type": "string",
				"$comment": "group:common"
			},
			"noLocal": {
				"title": "No Local",
				"description": "If noLocal is true, then events generated by the session through which the listener was registered are ignored. Otherwise, they are not ignored.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"password": {
				"title": "Password",
				"description": "Password for login",
				"type": "string",
				"$comment": "group:common"
			},
			"sessionLiveCheckInterval": {
				"title": "Session Live Check Interval",
				"description": "Interval in milliseconds to wait before each session live checking The default value is 60000 ms.",
				"type": "string",
				"$comment": "group:common",
				"format": "duration",
				"default": "60000"
			},
			"sessionLiveCheckIntervalOnStart": {
				"title": "Session Live Check Interval On Start",
				"description": "Interval in milliseconds to wait before the first session live checking. The default value is 3000 ms.",
				"type": "string",
				"$comment": "group:common",
				"format": "duration",
				"default": "3000"
			},
			"username": {
				"title": "Username",
				"description": "Username for login",
				"type": "string",
				"$comment": "group:common"
			},
			"uuids": {
				"title": "Uuids",
				"description": "When a comma separated uuid list string is set, only events whose associated parent node has one of the identifiers in the comma separated uuid list will be received.",
				"type": "string",
				"$comment": "group:common"
			},
			"workspaceName": {
				"title": "Workspace Name",
				"description": "The workspace to access. If it's not specified then the default one will be used",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"jdbc": {
		"properties": {
			"dataSourceName": {
				"title": "Data Source Name",
				"description": "Name of DataSource to lookup in the Registry. If the name is dataSource or default, then Camel will attempt to lookup a default DataSource from the registry, meaning if there is a only one instance of DataSource found, then this DataSource will be used.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowNamedParameters": {
				"title": "Allow Named Parameters",
				"description": "Whether to allow using named parameters in the queries.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"outputClass": {
				"title": "Output Class",
				"description": "Specify the full package and class name to use as conversion when outputType=SelectOne or SelectList.",
				"type": "string",
				"$comment": "group:producer"
			},
			"outputType": {
				"title": "Output Type",
				"description": "Determines the output the producer should use.",
				"type": "string",
				"enum": [
					"SelectOne",
					"SelectList",
					"StreamList"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jdbc.JdbcOutputType",
				"default": "SelectList"
			},
			"parameters": {
				"title": "Parameters",
				"description": "Optional parameters to the java.sql.Statement. For example to set maxRows, fetchSize etc.",
				"type": "object",
				"$comment": "group:producer"
			},
			"readSize": {
				"title": "Read Size",
				"description": "The default maximum number of rows that can be read by a polling query. The default value is 0.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"resetAutoCommit": {
				"title": "Reset Auto Commit",
				"description": "Camel will set the autoCommit on the JDBC connection to be false, commit the change after executed the statement and reset the autoCommit flag of the connection at the end, if the resetAutoCommit is true. If the JDBC connection doesn't support to reset the autoCommit flag, you can set the resetAutoCommit flag to be false, and Camel will not try to reset the autoCommit flag. When used with XA transactions you most likely need to set it to false so that the transaction manager is in charge of committing this tx.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"transacted": {
				"title": "Transacted",
				"description": "Whether transactions are in use.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useGetBytesForBlob": {
				"title": "Use Get Bytes For Blob",
				"description": "To read BLOB columns as bytes instead of string data. This may be needed for certain databases such as Oracle where you must read BLOB columns as bytes.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useHeadersAsParameters": {
				"title": "Use Headers As Parameters",
				"description": "Set this option to true to use the prepareStatementStrategy with named parameters. This allows to define queries with named placeholders, and use headers with the dynamic values for the query placeholders.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useJDBC4ColumnNameAndLabelSemantics": {
				"title": "Use JDBC4 Column Name And Label Semantics",
				"description": "Sets whether to use JDBC 4 or JDBC 3.0 or older semantic when retrieving column name. JDBC 4.0 uses columnLabel to get the column name where as JDBC 3.0 uses both columnName or columnLabel. Unfortunately JDBC drivers behave differently so you can use this option to work out issues around your JDBC driver if you get problem using this component This option is default true.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"beanRowMapper": {
				"title": "Bean Row Mapper",
				"description": "To use a custom org.apache.camel.component.jdbc.BeanRowMapper when using outputClass. The default implementation will lower case the row names and skip underscores, and dashes. For example CUST_ID is mapped as custId.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jdbc.BeanRowMapper"
			},
			"connectionStrategy": {
				"title": "Connection Strategy",
				"description": "To use a custom strategy for working with connections. Do not use a custom strategy when using the spring-jdbc component because a special Spring ConnectionStrategy is used by default to support Spring Transactions.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jdbc.ConnectionStrategy"
			},
			"prepareStatementStrategy": {
				"title": "Prepare Statement Strategy",
				"description": "Allows the plugin to use a custom org.apache.camel.component.jdbc.JdbcPrepareStatementStrategy to control preparation of the query and prepared statement.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jdbc.JdbcPrepareStatementStrategy"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"dataSourceName"
		]
	},
	"jetty": {
		"properties": {
			"httpUri": {
				"title": "Http Uri",
				"description": "The url of the HTTP endpoint to call.",
				"type": "string",
				"$comment": "group:common"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:common (advanced)",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"httpBinding": {
				"title": "Http Binding",
				"description": "To use a custom HttpBinding to control the mapping between Camel message and HttpClient.",
				"type": "string",
				"$comment": "group:common (advanced)",
				"format": "bean:org.apache.camel.http.common.HttpBinding"
			},
			"chunked": {
				"title": "Chunked",
				"description": "If this option is false the Servlet will disable the HTTP streaming and set the content-length header on the response",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"disableStreamCache": {
				"title": "Disable Stream Cache",
				"description": "Determines whether or not the raw input stream is cached or not. The Camel consumer (camel-servlet, camel-jetty etc.) will by default cache the input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The producer (camel-http) will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is (the stream can only be read once) as the message body.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"async": {
				"title": "Async",
				"description": "Configure the consumer to work in async mode",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"continuationTimeout": {
				"title": "Continuation Timeout",
				"description": "Allows to set a timeout in millis when using Jetty as consumer (server). By default Jetty uses 30000. You can use a value of = 0 to never expire. If a timeout occurs then the request will be expired and Jetty will return back a http error 503 to the client. This option is only in use when using Jetty with the Asynchronous Routing Engine.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "30000"
			},
			"enableCORS": {
				"title": "Enable CORS",
				"description": "If the option is true, Jetty server will setup the CrossOriginFilter which supports the CORS out of box.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"enableJmx": {
				"title": "Enable Jmx",
				"description": "If this option is true, Jetty JMX support will be enabled for this endpoint. See Jetty JMX support for more details.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"enableMultipartFilter": {
				"title": "Enable Multipart Filter",
				"description": "Whether org.apache.camel.component.jetty.MultiPartFilter is enabled or not. You should set this value to false when bridging endpoints, to ensure multipart requests is proxied/bridged as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"httpMethodRestrict": {
				"title": "Http Method Restrict",
				"description": "Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"logException": {
				"title": "Log Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side the exception's stack trace will be logged when the exception stack trace is not sent in the response's body.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"matchOnUriPrefix": {
				"title": "Match On Uri Prefix",
				"description": "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"muteException": {
				"title": "Mute Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"responseBufferSize": {
				"title": "Response Buffer Size",
				"description": "To use a custom buffer size on the jakarta.servlet.ServletResponse.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"sendDateHeader": {
				"title": "Send Date Header",
				"description": "If the option is true, jetty server will send the date header to the client which sends the request. NOTE please make sure there is no any other camel-jetty endpoint is share the same port, otherwise this option may not work as expected.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendServerVersion": {
				"title": "Send Server Version",
				"description": "If the option is true, jetty will send the server header with the jetty version information to the client which sends the request. NOTE please make sure there is no any other camel-jetty endpoint is share the same port, otherwise this option may not work as expected.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"sessionSupport": {
				"title": "Session Support",
				"description": "Specifies whether to enable the session manager on the server side of Jetty.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"useContinuation": {
				"title": "Use Continuation",
				"description": "Whether or not to use Jetty continuations for the Jetty Server.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerCheckContentAvailable": {
				"title": "Eager Check Content Available",
				"description": "Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present. This can be turned on in case HTTP clients do not send streamed data.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"fileSizeThreshold": {
				"title": "File Size Threshold",
				"description": "The size threshold after which files will be written to disk for multipart/form-data requests. By default the files are not written to disk",
				"type": "integer",
				"$comment": "group:consumer (advanced)"
			},
			"filesLocation": {
				"title": "Files Location",
				"description": "The directory location where files will be store for multipart/form-data requests. By default the files are written in the system temporary folder",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"filterInitParameters": {
				"title": "Filter Init Parameters",
				"description": "Configuration of the filter init parameters. These parameters will be applied to the filter list before starting the jetty server.",
				"type": "object",
				"$comment": "group:consumer (advanced)"
			},
			"filters": {
				"title": "Filters",
				"description": "Allows using a custom filters which is putted into a list and can be find in the Registry. Multiple values can be separated by comma.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:consumer (advanced)"
			},
			"handlers": {
				"title": "Handlers",
				"description": "Specifies a comma-delimited set of Handler instances to lookup in your Registry. These handlers are added to the Jetty servlet context (for example, to add security). Important: You can not use different handlers with different Jetty endpoints using the same port number. The handlers is associated to the port number. If you need different handlers, then use different port numbers.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:consumer (advanced)"
			},
			"idleTimeout": {
				"title": "Idle Timeout",
				"description": "The max idle time (in milli seconds) is applied to an HTTP request for IO operations and delayed dispatch. Idle time 0 implies an infinite timeout, -1 (default) implies no HTTP channel timeout and the connection timeout is used instead.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": -1
			},
			"mapHttpMessageBody": {
				"title": "Map Http Message Body",
				"description": "If this option is true then IN exchange Body of the exchange will be mapped to HTTP body. Setting this to false will avoid the HTTP mapping.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"mapHttpMessageFormUrlEncodedBody": {
				"title": "Map Http Message Form Url Encoded Body",
				"description": "If this option is true then IN exchange Form Encoded body of the exchange will be mapped to HTTP. Setting this to false will avoid the HTTP Form Encoded body mapping.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"mapHttpMessageHeaders": {
				"title": "Map Http Message Headers",
				"description": "If this option is true then IN exchange Headers of the exchange will be mapped to HTTP headers. Setting this to false will avoid the HTTP Headers mapping.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"maxFileSize": {
				"title": "Max File Size",
				"description": "The maximum size allowed for uploaded files. -1 means no limit",
				"type": "integer",
				"$comment": "group:consumer (advanced)"
			},
			"maxRequestSize": {
				"title": "Max Request Size",
				"description": "The maximum size allowed for multipart/form-data requests. -1 means no limit",
				"type": "integer",
				"$comment": "group:consumer (advanced)"
			},
			"multipartFilter": {
				"title": "Multipart Filter",
				"description": "Allows using a custom multipart filter. Note: setting multipartFilterRef forces the value of enableMultipartFilter to true.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:jakarta.servlet.Filter"
			},
			"optionsEnabled": {
				"title": "Options Enabled",
				"description": "Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"traceEnabled": {
				"title": "Trace Enabled",
				"description": "Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"httpUri"
		]
	},
	"jgroups": {
		"properties": {
			"clusterName": {
				"title": "Cluster Name",
				"description": "The name of the JGroups cluster the component should connect to.",
				"type": "string",
				"$comment": "group:common"
			},
			"channelProperties": {
				"title": "Channel Properties",
				"description": "Specifies configuration properties of the JChannel used by the endpoint.",
				"type": "string",
				"$comment": "group:common"
			},
			"enableViewMessages": {
				"title": "Enable View Messages",
				"description": "If set to true, the consumer endpoint will receive org.jgroups.View messages as well (not only org.jgroups.Message instances). By default only regular messages are consumed by the endpoint.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"clusterName"
		]
	},
	"jgroups-raft": {
		"properties": {
			"clusterName": {
				"title": "Cluster Name",
				"description": "The name of the JGroupsraft cluster the component should connect to.",
				"type": "string",
				"$comment": "group:common"
			},
			"enableRoleChangeEvents": {
				"title": "Enable Role Change Events",
				"description": "If set to true, the consumer endpoint will receive roleChange event as well (not just connecting and/or using the state machine). By default it is set to false.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"clusterName"
		]
	},
	"jira": {
		"properties": {
			"type": {
				"title": "Type",
				"description": "Operation to perform. Consumers: NewIssues, NewComments. Producers: AddIssue, AttachFile, DeleteIssue, TransitionIssue, UpdateIssue, Watchers. See this class javadoc description for more information.",
				"type": "string",
				"enum": [
					"ADDCOMMENT",
					"ADDISSUE",
					"ATTACH",
					"DELETEISSUE",
					"NEWISSUES",
					"NEWCOMMENTS",
					"WATCHUPDATES",
					"UPDATEISSUE",
					"TRANSITIONISSUE",
					"WATCHERS",
					"ADDISSUELINK",
					"ADDWORKLOG",
					"FETCHISSUE",
					"FETCHCOMMENTS"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.jira.JiraType"
			},
			"delay": {
				"title": "Delay",
				"description": "Time in milliseconds to elapse for the next poll.",
				"type": "integer",
				"$comment": "group:common",
				"default": "6000"
			},
			"jiraUrl": {
				"title": "Jira Url",
				"description": "The Jira server url, for example http://my_jira.com:8081.",
				"type": "string",
				"$comment": "group:common"
			},
			"jql": {
				"title": "Jql",
				"description": "JQL is the query language from JIRA which allows you to retrieve the data you want. For example jql=project=MyProject Where MyProject is the product key in Jira. It is important to use the RAW() and set the JQL inside it to prevent camel parsing it, example: RAW(project in (MYP, COM) AND resolution = Unresolved)",
				"type": "string",
				"$comment": "group:consumer"
			},
			"maxResults": {
				"title": "Max Results",
				"description": "Max number of issues to search for",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "50"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendOnlyUpdatedField": {
				"title": "Send Only Updated Field",
				"description": "Indicator for sending only changed fields in exchange body or issue object. By default consumer sends only changed fields.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"watchedFields": {
				"title": "Watched Fields",
				"description": "Comma separated list of fields to watch for changes. Status,Priority are the defaults.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "Status,Priority"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "(OAuth or Personal Access Token authentication) The access token generated by the Jira server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"consumerKey": {
				"title": "Consumer Key",
				"description": "(OAuth only) The consumer key from Jira settings.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "(Basic authentication only) The password or the API Token to authenticate to the Jira server. Use only if username basic authentication is used.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privateKey": {
				"title": "Private Key",
				"description": "(OAuth only) The private key generated by the client to encrypt the conversation to the server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "(Basic authentication only) The username to authenticate to the Jira server. Use only if OAuth is not enabled on the Jira server. Do not set the username and OAuth token parameter, if they are both set, the username basic authentication takes precedence.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"verificationCode": {
				"title": "Verification Code",
				"description": "(OAuth only) The verification code from Jira generated in the first step of the authorization proccess.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"type",
			"jiraUrl"
		]
	},
	"jms": {
		"properties": {
			"destinationType": {
				"title": "Destination Type",
				"description": "The kind of destination to use",
				"type": "string",
				"enum": [
					"queue",
					"topic",
					"temp-queue",
					"temp-topic"
				],
				"$comment": "group:common",
				"default": "queue"
			},
			"destinationName": {
				"title": "Destination Name",
				"description": "Name of the queue or topic to use as destination",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions with JMS 1.1.",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:jakarta.jms.ConnectionFactory"
			},
			"disableReplyTo": {
				"title": "Disable Reply To",
				"description": "Specifies whether Camel ignores the JMSReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the JMSReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"durableSubscriptionName": {
				"title": "Durable Subscription Name",
				"description": "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.",
				"type": "string",
				"$comment": "group:common"
			},
			"jmsMessageType": {
				"title": "Jms Message Type",
				"description": "Allows you to force the use of a specific jakarta.jms.Message implementation for sending JMS messages. Possible values are: Bytes, Map, Object, Stream, Text. By default, Camel would determine which JMS message type to use from the In body type. This option allows you to specify it.",
				"type": "string",
				"enum": [
					"Bytes",
					"Map",
					"Object",
					"Stream",
					"Text"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.jms.JmsMessageType"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "Provides an explicit ReplyTo destination (overrides any incoming value of Message.getJMSReplyTo() in consumer).",
				"type": "string",
				"$comment": "group:common"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"acknowledgementModeName": {
				"title": "Acknowledgement Mode Name",
				"description": "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
				"type": "string",
				"enum": [
					"SESSION_TRANSACTED",
					"CLIENT_ACKNOWLEDGE",
					"AUTO_ACKNOWLEDGE",
					"DUPS_OK_ACKNOWLEDGE"
				],
				"$comment": "group:consumer",
				"default": "AUTO_ACKNOWLEDGE"
			},
			"artemisConsumerPriority": {
				"title": "Artemis Consumer Priority",
				"description": "Consumer priorities allow you to ensure that high priority consumers receive messages while they are active. Normally, active consumers connected to a queue receive messages from it in a round-robin fashion. When consumer priorities are in use, messages are delivered round-robin if multiple active consumers exist with the same high priority. Messages will only going to lower priority consumers when the high priority consumers do not have credit available to consume the message, or those high priority consumers have declined to accept the message (for instance because it does not meet the criteria of any selectors associated with the consumer).",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"asyncConsumer": {
				"title": "Async Consumer",
				"description": "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"autoStartup": {
				"title": "Auto Startup",
				"description": "Specifies whether the consumer container should auto-startup.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"cacheLevel": {
				"title": "Cache Level",
				"description": "Sets the cache level by ID for the underlying JMS resources. See cacheLevelName option for more details.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"cacheLevelName": {
				"title": "Cache Level Name",
				"description": "Sets the cache level by name for the underlying JMS resources. Possible values are: CACHE_AUTO, CACHE_CONNECTION, CACHE_CONSUMER, CACHE_NONE, and CACHE_SESSION. The default setting is CACHE_AUTO. See the Spring documentation and Transactions Cache Levels for more information.",
				"type": "string",
				"enum": [
					"CACHE_AUTO",
					"CACHE_CONNECTION",
					"CACHE_CONSUMER",
					"CACHE_NONE",
					"CACHE_SESSION"
				],
				"$comment": "group:consumer",
				"default": "CACHE_AUTO"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"maxConcurrentConsumers": {
				"title": "Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToMaxConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"replyToDeliveryPersistent": {
				"title": "Reply To Delivery Persistent",
				"description": "Specifies whether to use persistent delivery by default for replies.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"selector": {
				"title": "Selector",
				"description": "Sets the JMS selector to use",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscriptionDurable": {
				"title": "Subscription Durable",
				"description": "Set whether to make the subscription durable. The durable subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a durable subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"subscriptionName": {
				"title": "Subscription Name",
				"description": "Set the name of a subscription to create. To be applied in case of a topic (pub-sub domain) with a shared or durable subscription. The subscription name needs to be unique within this client's JMS client id. Default is the class name of the specified message listener. Note: Only 1 concurrent consumer (which is the default of this message listener container) is allowed for each subscription, except for a shared subscription (which requires JMS 2.0).",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscriptionShared": {
				"title": "Subscription Shared",
				"description": "Set whether to make the subscription shared. The shared subscription name to be used can be specified through the subscriptionName property. Default is false. Set this to true to register a shared subscription, typically in combination with a subscriptionName value (unless your message listener class name is good enough as subscription name). Note that shared subscriptions may also be durable, so this flag can (and often will) be combined with subscriptionDurable as well. Only makes sense when listening to a topic (pub-sub domain), therefore this method switches the pubSubDomain flag as well. Requires a JMS 2.0 compatible message broker.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"acceptMessagesWhileStopping": {
				"title": "Accept Messages While Stopping",
				"description": "Specifies whether the consumer accept messages while it is stopping. You may consider enabling this option, if you start and stop JMS routes at runtime, while there are still messages enqueued on the queue. If this option is false, and you stop the JMS route, then messages may be rejected, and the JMS broker would have to attempt redeliveries, which yet again may be rejected, and eventually the message may be moved at a dead letter queue on the JMS broker. To avoid this its recommended to enable this option.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"allowReplyManagerQuickStop": {
				"title": "Allow Reply Manager Quick Stop",
				"description": "Whether the DefaultMessageListenerContainer used in the reply managers for request-reply messaging allow the DefaultMessageListenerContainer.runningAllowed flag to quick stop in case JmsConfiguration#isAcceptMessagesWhileStopping is enabled, and org.apache.camel.CamelContext is currently being stopped. This quick stop ability is enabled by default in the regular JMS consumers but to enable for reply managers you must enable this flag.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"consumerType": {
				"title": "Consumer Type",
				"description": "The consumer type to use, which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
				"type": "string",
				"enum": [
					"Simple",
					"Default",
					"Custom"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.ConsumerType",
				"default": "Default"
			},
			"defaultTaskExecutorType": {
				"title": "Default Task Executor Type",
				"description": "Specifies what default TaskExecutor type to use in the DefaultMessageListenerContainer, for both consumer endpoints and the ReplyTo consumer of producer endpoints. Possible values: SimpleAsync (uses Spring's SimpleAsyncTaskExecutor) or ThreadPool (uses Spring's ThreadPoolTaskExecutor with optimal values - cached thread-pool-like). If not set, it defaults to the previous behaviour, which uses a cached thread pool for consumer endpoints and SimpleAsync for reply consumers. The use of ThreadPool is recommended to reduce thread trash in elastic configurations with dynamically increasing and decreasing concurrent consumers.",
				"type": "string",
				"enum": [
					"ThreadPool",
					"SimpleAsync"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.DefaultTaskExecutorType"
			},
			"eagerLoadingOfProperties": {
				"title": "Eager Loading Of Properties",
				"description": "Enables eager loading of JMS properties and payload as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties. See also the option eagerPoisonBody.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerPoisonBody": {
				"title": "Eager Poison Body",
				"description": "If eagerLoadingOfProperties is enabled and the JMS message payload (JMS body or JMS properties) is poison (cannot be read/mapped), then set this text as the message body instead so the message can be processed (the cause of the poison are already stored as exception on the Exchange). This can be turned off by setting eagerPoisonBody=false. See also the option eagerLoadingOfProperties.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "Poison JMS message due to ${exception.message}"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"exposeListenerSession": {
				"title": "Expose Listener Session",
				"description": "Specifies whether the listener session should be exposed when consuming messages.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"replyToConsumerType": {
				"title": "Reply To Consumer Type",
				"description": "The consumer type of the reply consumer (when doing request/reply), which can be one of: Simple, Default, or Custom. The consumer type determines which Spring JMS listener to use. Default will use org.springframework.jms.listener.DefaultMessageListenerContainer, Simple will use org.springframework.jms.listener.SimpleMessageListenerContainer. When Custom is specified, the MessageListenerContainerFactory defined by the messageListenerContainerFactory option will determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use.",
				"type": "string",
				"enum": [
					"Simple",
					"Default",
					"Custom"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.jms.ConsumerType",
				"default": "Default"
			},
			"replyToSameDestinationAllowed": {
				"title": "Reply To Same Destination Allowed",
				"description": "Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"taskExecutor": {
				"title": "Task Executor",
				"description": "Allows you to specify a custom task executor for consuming messages.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.springframework.core.task.TaskExecutor"
			},
			"deliveryDelay": {
				"title": "Delivery Delay",
				"description": "Sets delivery delay to use for send calls for JMS. This option requires JMS 2.0 compliant broker.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"deliveryMode": {
				"title": "Delivery Mode",
				"description": "Specifies the delivery mode to be used. Possible values are those defined by jakarta.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.",
				"type": "integer",
				"enum": [
					"1",
					"2"
				],
				"$comment": "group:producer"
			},
			"deliveryPersistent": {
				"title": "Delivery Persistent",
				"description": "Specifies whether persistent delivery is used by default.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"explicitQosEnabled": {
				"title": "Explicit Qos Enabled",
				"description": "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"formatDateHeadersToIso8601": {
				"title": "Format Date Headers To Iso8601",
				"description": "Sets whether JMS date properties should be formatted according to the ISO 8601 standard.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"preserveMessageQos": {
				"title": "Preserve Message Qos",
				"description": "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"priority": {
				"title": "Priority",
				"description": "Values greater than 1 specify the message priority when sending (where 1 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
				"type": "integer",
				"enum": [
					"1",
					"2",
					"3",
					"4",
					"5",
					"6",
					"7",
					"8",
					"9"
				],
				"$comment": "group:producer",
				"default": 4
			},
			"replyToConcurrentConsumers": {
				"title": "Reply To Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToMaxConcurrentConsumers": {
				"title": "Reply To Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers when using request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"replyToOnTimeoutMaxConcurrentConsumers": {
				"title": "Reply To On Timeout Max Concurrent Consumers",
				"description": "Specifies the maximum number of concurrent consumers for continue routing when timeout occurred when using request/reply over JMS.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToOverride": {
				"title": "Reply To Override",
				"description": "Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.",
				"type": "string",
				"$comment": "group:producer"
			},
			"replyToType": {
				"title": "Reply To Type",
				"description": "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary, Shared, or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Shared is used by default. This option allows you to use exclusive queues instead of shared ones. See Camel JMS documentation for more details, and especially the notes about the implications if running in a clustered environment, and the fact that Shared reply queues has lower performance than its alternatives Temporary and Exclusive.",
				"type": "string",
				"enum": [
					"Temporary",
					"Shared",
					"Exclusive"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jms.ReplyToType"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "20000"
			},
			"timeToLive": {
				"title": "Time To Live",
				"description": "When sending messages, specifies the time-to-live of the message (in milliseconds).",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"allowAdditionalHeaders": {
				"title": "Allow Additional Headers",
				"description": "This option is used to allow additional headers which may have values that are invalid according to JMS specification. For example, some message systems, such as WMQ, do this with header names using prefix JMS_IBM_MQMD_ containing values with byte array or other invalid types. You can specify multiple header names separated by comma, and use as suffix for wildcard matching.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"alwaysCopyMessage": {
				"title": "Always Copy Message",
				"description": "If true, Camel will always make a JMS message copy of the message when it is passed to the producer for sending. Copying the message is needed in some situations, such as when a replyToDestinationSelectorName is set (incidentally, Camel will set the alwaysCopyMessage option to true, if a replyToDestinationSelectorName is set)",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"correlationProperty": {
				"title": "Correlation Property",
				"description": "When using InOut exchange pattern use this JMS property instead of JMSCorrelationID JMS property to correlate messages. If set messages will be correlated solely on the value of this property JMSCorrelationID property will be ignored and not set by Camel.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"disableTimeToLive": {
				"title": "Disable Time To Live",
				"description": "Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"forceSendOriginalMessage": {
				"title": "Force Send Original Message",
				"description": "When using mapJmsMessage=false Camel will create a new JMS message to send to a new JMS destination if you touch the headers (get or set) during the route. Set this option to true to force Camel to send the original JMS message that was received.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"includeSentJMSMessageID": {
				"title": "Include Sent JMSMessage ID",
				"description": "Only applicable when sending to JMS destination using InOnly (eg fire and forget). Enabling this option will enrich the Camel Exchange with the actual JMSMessageID that was used by the JMS client when the message was sent to the JMS destination.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"replyToCacheLevelName": {
				"title": "Reply To Cache Level Name",
				"description": "Sets the cache level by name for the reply consumer when doing request/reply over JMS. This option only applies when using fixed reply queues (not temporary). Camel will by default use: CACHE_CONSUMER for exclusive or shared w/ replyToSelectorName. And CACHE_SESSION for shared without replyToSelectorName. Some JMS brokers such as IBM WebSphere may require to set the replyToCacheLevelName=CACHE_NONE to work. Note: If using temporary queues then CACHE_NONE is not allowed, and you must use a higher value such as CACHE_CONSUMER or CACHE_SESSION.",
				"type": "string",
				"enum": [
					"CACHE_AUTO",
					"CACHE_CONNECTION",
					"CACHE_CONSUMER",
					"CACHE_NONE",
					"CACHE_SESSION"
				],
				"$comment": "group:producer (advanced)"
			},
			"replyToDestinationSelectorName": {
				"title": "Reply To Destination Selector Name",
				"description": "Sets the JMS Selector using the fixed name to be used so you can filter out your own replies from the others when using a shared queue (that is, if you are not using a temporary reply queue).",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"streamMessageTypeEnabled": {
				"title": "Stream Message Type Enabled",
				"description": "Sets whether StreamMessage type is enabled or not. Message payloads of streaming kind such as files, InputStream, etc will either by sent as BytesMessage or StreamMessage. This option controls which kind will be used. By default BytesMessage is used which enforces the entire message payload to be read into memory. By enabling this option the message payload is read into memory in chunks and each chunk is then written to the StreamMessage until no more data.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"allowSerializedHeaders": {
				"title": "Allow Serialized Headers",
				"description": "Controls whether or not to include serialized headers. Applies only when transferExchange is true. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"artemisStreamingEnabled": {
				"title": "Artemis Streaming Enabled",
				"description": "Whether optimizing for Apache Artemis streaming mode. This can reduce memory overhead when using Artemis with JMS StreamMessage types. This option must only be enabled if Apache Artemis is being used.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStartListener": {
				"title": "Async Start Listener",
				"description": "Whether to startup the JmsConsumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or fail-over. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStopListener": {
				"title": "Async Stop Listener",
				"description": "Whether to stop the JmsConsumer message listener asynchronously, when stopping a route.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"destinationResolver": {
				"title": "Destination Resolver",
				"description": "A pluggable org.springframework.jms.support.destination.DestinationResolver that allows you to use your own resolver (for example, to lookup the real destination in a JNDI registry).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.jms.support.destination.DestinationResolver"
			},
			"errorHandler": {
				"title": "Error Handler",
				"description": "Specifies a org.springframework.util.ErrorHandler to be invoked in case of any uncaught exceptions thrown while processing a Message. By default these exceptions will be logged at the WARN level, if no errorHandler has been configured. You can configure logging level and whether stack traces should be logged using errorHandlerLoggingLevel and errorHandlerLogStackTrace options. This makes it much easier to configure, than having to code a custom errorHandler.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.util.ErrorHandler"
			},
			"exceptionListener": {
				"title": "Exception Listener",
				"description": "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.jms.ExceptionListener"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"idleConsumerLimit": {
				"title": "Idle Consumer Limit",
				"description": "Specify the limit for the number of consumers that are allowed to be idle at any given time.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"idleReceivesPerTaskLimit": {
				"title": "Idle Receives Per Task Limit",
				"description": "Marks the consumer as idle after the specified number of idle receives have been reached. An idle receive is counted from the moment a null message is returned by the receiver after the potential setReceiveTimeout elapsed. This gives the opportunity to check if the idle task count exceeds setIdleTaskExecutionLimit and based on that decide if the task needs to be re-scheduled or not, saving resources that would otherwise be held. This setting differs from setMaxMessagesPerTask where the task is released and re-scheduled after this limit is reached, no matter if the received messages were null or non-null messages. This setting alone can be inflexible if one desires to have a large enough batch for each task but requires a quick(er) release from the moment there are no more messages to process. This setting differs from setIdleTaskExecutionLimit where this limit decides after how many iterations of being marked as idle, a task is released. For example: If setMaxMessagesPerTask is set to '500' and #setIdleReceivesPerTaskLimit is set to '60' and setReceiveTimeout is set to '1000' and setIdleTaskExecutionLimit is set to '1', then 500 messages per task would be processed unless there is a subsequent number of 60 idle messages received, the task would be marked as idle and released. This also means that after the last message was processed, the task would be released after 60 seconds as long as no new messages appear.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"idleTaskExecutionLimit": {
				"title": "Idle Task Execution Limit",
				"description": "Specifies the limit for idle executions of a receive task, not having received any message within its execution. If this limit is reached, the task will shut down and leave receiving to other executing tasks (in the case of dynamic scheduling; see the maxConcurrentConsumers setting). There is additional doc available from Spring.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"includeAllJMSXProperties": {
				"title": "Include All JMSXProperties",
				"description": "Whether to include all JMSX prefixed properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"jmsKeyFormatStrategy": {
				"title": "Jms Key Format Strategy",
				"description": "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
				"type": "string",
				"enum": [
					"default",
					"passthrough"
				],
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.JmsKeyFormatStrategy"
			},
			"mapJmsMessage": {
				"title": "Map Jms Message",
				"description": "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as jakarta.jms.TextMessage to a String etc.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"maxMessagesPerTask": {
				"title": "Max Messages Per Task",
				"description": "The number of messages per task. -1 is unlimited. If you use a range for concurrent consumers (eg min max), then this option can be used to set a value to eg 100 to control how fast the consumers will shrink when less work is required.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": -1
			},
			"messageConverter": {
				"title": "Message Converter",
				"description": "To use a custom Spring org.springframework.jms.support.converter.MessageConverter so you can be in control how to map to/from a jakarta.jms.Message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.jms.support.converter.MessageConverter"
			},
			"messageCreatedStrategy": {
				"title": "Message Created Strategy",
				"description": "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of jakarta.jms.Message objects when Camel is sending a JMS message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.MessageCreatedStrategy"
			},
			"messageIdEnabled": {
				"title": "Message Id Enabled",
				"description": "When sending, specifies whether message IDs should be added. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the message ID set to null; if the provider ignores the hint, the message ID must be set to its normal unique value.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"messageListenerContainerFactory": {
				"title": "Message Listener Container Factory",
				"description": "Registry ID of the MessageListenerContainerFactory used to determine what org.springframework.jms.listener.AbstractMessageListenerContainer to use to consume messages. Setting this will automatically set consumerType to Custom.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.MessageListenerContainerFactory"
			},
			"messageTimestampEnabled": {
				"title": "Message Timestamp Enabled",
				"description": "Specifies whether timestamps should be enabled by default on sending messages. This is just an hint to the JMS broker. If the JMS provider accepts this hint, these messages must have the timestamp set to zero; if the provider ignores the hint the timestamp must be set to its normal value.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"pubSubNoLocal": {
				"title": "Pub Sub No Local",
				"description": "Specifies whether to inhibit the delivery of messages published by its own connection.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"receiveTimeout": {
				"title": "Receive Timeout",
				"description": "The timeout for receiving messages (in milliseconds).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"recoveryInterval": {
				"title": "Recovery Interval",
				"description": "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "5000"
			},
			"requestTimeoutCheckerInterval": {
				"title": "Request Timeout Checker Interval",
				"description": "Configures how often Camel should check for timed out Exchanges when doing request/reply over JMS. By default Camel checks once per second. But if you must react faster when a timeout occurs, then you can lower this interval, to check more frequently. The timeout is determined by the option requestTimeout.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"temporaryQueueResolver": {
				"title": "Temporary Queue Resolver",
				"description": "A pluggable TemporaryQueueResolver that allows you to use your own resolver for creating temporary queues (some messaging systems has special requirements for creating temporary queues).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jms.TemporaryQueueResolver"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a jakarta.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transferExchange": {
				"title": "Transfer Exchange",
				"description": "You can transfer the exchange over the wire instead of just the body and headers. The following fields are transferred: In body, Out body, Fault body, In headers, Out headers, Fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. You must enable this option on both the producer and consumer side, so Camel knows the payloads is an Exchange and not a regular payload. Use this with caution as the data is using Java Object serialization and requires the receiver to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumers having to use compatible Camel versions!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"useMessageIDAsCorrelationID": {
				"title": "Use Message IDAs Correlation ID",
				"description": "Specifies whether JMSMessageID should always be used as JMSCorrelationID for InOut messages.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"waitForProvisionCorrelationToBeUpdatedCounter": {
				"title": "Wait For Provision Correlation To Be Updated Counter",
				"description": "Number of times to wait for provisional correlation id to be updated to the actual correlation id when doing request/reply over JMS and when the option useMessageIDAsCorrelationID is enabled.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 50
			},
			"waitForProvisionCorrelationToBeUpdatedThreadSleepingTime": {
				"title": "Wait For Provision Correlation To Be Updated Thread Sleeping Time",
				"description": "Interval in millis to sleep each time while waiting for provisional correlation id to be updated.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "100"
			},
			"waitForTemporaryReplyToToBeUpdatedCounter": {
				"title": "Wait For Temporary Reply To To Be Updated Counter",
				"description": "Number of times to wait for temporary replyTo queue to be created and ready when doing request/reply over JMS.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 200
			},
			"waitForTemporaryReplyToToBeUpdatedThreadSleepingTime": {
				"title": "Wait For Temporary Reply To To Be Updated Thread Sleeping Time",
				"description": "Interval in millis to sleep each time while waiting for temporary replyTo queue to be ready.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "100"
			},
			"errorHandlerLoggingLevel": {
				"title": "Error Handler Logging Level",
				"description": "Allows to configure the default errorHandler logging level for logging uncaught exceptions.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:logging",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"errorHandlerLogStackTrace": {
				"title": "Error Handler Log Stack Trace",
				"description": "Allows to control whether stack-traces should be logged or not, by the default errorHandler.",
				"type": "boolean",
				"$comment": "group:logging",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to use with the ConnectionFactory. You can also configure username/password directly on the ConnectionFactory.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"transacted": {
				"title": "Transacted",
				"description": "Specifies whether to use transacted mode",
				"type": "boolean",
				"$comment": "group:transaction"
			},
			"transactedInOut": {
				"title": "Transacted In Out",
				"description": "Specifies whether InOut operations (request reply) default to using transacted mode If this flag is set to true, then Spring JmsTemplate will have sessionTransacted set to true, and the acknowledgeMode as transacted on the JmsTemplate used for InOut operations. Note from Spring JMS: that within a JTA transaction, the parameters passed to createQueue, createTopic methods are not taken into account. Depending on the Java EE transaction context, the container makes its own decisions on these values. Analogously, these parameters are not taken into account within a locally managed transaction either, since Spring JMS operates on an existing JMS Session in this case. Setting this flag to true will use a short local JMS transaction when running outside of a managed transaction, and a synchronized local JMS transaction in case of a managed transaction (other than an XA transaction) being present. This has the effect of a local JMS transaction being managed alongside the main transaction (which might be a native JDBC transaction), with the JMS transaction committing right after the main transaction.",
				"type": "boolean",
				"$comment": "group:transaction"
			},
			"lazyCreateTransactionManager": {
				"title": "Lazy Create Transaction Manager",
				"description": "If true, Camel will create a JmsTransactionManager, if there is no transactionManager injected when option transacted=true.",
				"type": "boolean",
				"$comment": "group:transaction (advanced)",
				"default": true
			},
			"transactionManager": {
				"title": "Transaction Manager",
				"description": "The Spring transaction manager to use.",
				"type": "string",
				"$comment": "group:transaction (advanced)",
				"format": "bean:org.springframework.transaction.PlatformTransactionManager"
			},
			"transactionName": {
				"title": "Transaction Name",
				"description": "The name of the transaction to use.",
				"type": "string",
				"$comment": "group:transaction (advanced)"
			},
			"transactionTimeout": {
				"title": "Transaction Timeout",
				"description": "The timeout value of the transaction (in seconds), if using transacted mode.",
				"type": "integer",
				"$comment": "group:transaction (advanced)",
				"default": -1
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"destinationName"
		]
	},
	"jmx": {
		"properties": {
			"serverURL": {
				"title": "Server URL",
				"description": "Server url comes from the remaining endpoint. Use platform to connect to local JVM.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"format": {
				"title": "Format",
				"description": "Format for the message body. Either xml or raw. If xml, the notification is serialized to xml. If raw, then the raw java object is set as the body.",
				"type": "string",
				"enum": [
					"xml",
					"raw"
				],
				"$comment": "group:consumer",
				"default": "xml"
			},
			"granularityPeriod": {
				"title": "Granularity Period",
				"description": "The frequency to poll the bean to check the monitor (monitor types only).",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "10000"
			},
			"monitorType": {
				"title": "Monitor Type",
				"description": "The type of monitor to create. One of string, gauge, counter (monitor types only).",
				"type": "string",
				"enum": [
					"counter",
					"gauge",
					"string"
				],
				"$comment": "group:consumer"
			},
			"objectDomain": {
				"title": "Object Domain",
				"description": "The domain for the mbean you're connecting to",
				"type": "string",
				"$comment": "group:consumer"
			},
			"objectName": {
				"title": "Object Name",
				"description": "The name key for the mbean you're connecting to. This value is mutually exclusive with the object properties that get passed.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"observedAttribute": {
				"title": "Observed Attribute",
				"description": "The attribute to observe for the monitor bean or consumer.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"executorService": {
				"title": "Executor Service",
				"description": "To use a custom shared thread pool for the consumers. By default each consume has their own thread-pool to process and route notifications.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.concurrent.ExecutorService"
			},
			"handback": {
				"title": "Handback",
				"description": "Value to handback to the listener when a notification is received. This value will be put in the message header with the key JMXConstants#JMX_HANDBACK.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.lang.Object"
			},
			"notificationFilter": {
				"title": "Notification Filter",
				"description": "Reference to a bean that implements the NotificationFilter.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.management.NotificationFilter"
			},
			"objectProperties": {
				"title": "Object Properties",
				"description": "Properties for the object name. These values will be used if the objectName param is not set",
				"type": "object",
				"$comment": "group:advanced"
			},
			"reconnectDelay": {
				"title": "Reconnect Delay",
				"description": "The number of seconds to wait before attempting to retry establishment of the initial connection or attempt to reconnect a lost connection",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 10
			},
			"reconnectOnConnectionFailure": {
				"title": "Reconnect On Connection Failure",
				"description": "If true the consumer will attempt to reconnect to the JMX server when any connection failure occurs. The consumer will attempt to re-establish the JMX connection every 'x' seconds until the connection is made-- where 'x' is the configured reconnectionDelay",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "If true the consumer will throw an exception if unable to establish the JMX connection upon startup. If false, the consumer will attempt to establish the JMX connection every 'x' seconds until the connection is made -- where 'x' is the configured reconnectionDelay",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"initThreshold": {
				"title": "Init Threshold",
				"description": "Initial threshold for the monitor. The value must exceed this before notifications are fired (counter monitor only).",
				"type": "integer",
				"$comment": "group:counter"
			},
			"modulus": {
				"title": "Modulus",
				"description": "The value at which the counter is reset to zero (counter monitor only).",
				"type": "integer",
				"$comment": "group:counter"
			},
			"offset": {
				"title": "Offset",
				"description": "The amount to increment the threshold after it's been exceeded (counter monitor only).",
				"type": "integer",
				"$comment": "group:counter"
			},
			"differenceMode": {
				"title": "Difference Mode",
				"description": "If true, then the value reported in the notification is the difference from the threshold as opposed to the value itself (counter and gauge monitor only).",
				"type": "boolean",
				"$comment": "group:gauge"
			},
			"notifyHigh": {
				"title": "Notify High",
				"description": "If true, the gauge will fire a notification when the high threshold is exceeded (gauge monitor only).",
				"type": "boolean",
				"$comment": "group:gauge"
			},
			"notifyLow": {
				"title": "Notify Low",
				"description": "If true, the gauge will fire a notification when the low threshold is exceeded (gauge monitor only).",
				"type": "boolean",
				"$comment": "group:gauge"
			},
			"thresholdHigh": {
				"title": "Threshold High",
				"description": "Value for the gauge's high threshold (gauge monitor only).",
				"type": "number",
				"$comment": "group:gauge"
			},
			"thresholdLow": {
				"title": "Threshold Low",
				"description": "Value for the gauge's low threshold (gauge monitor only).",
				"type": "number",
				"$comment": "group:gauge"
			},
			"password": {
				"title": "Password",
				"description": "Credentials for making a remote connection",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"user": {
				"title": "User",
				"description": "Credentials for making a remote connection",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"notifyDiffer": {
				"title": "Notify Differ",
				"description": "If true, will fire a notification when the string attribute differs from the string to compare (string monitor or consumer). By default the consumer will notify match if observed attribute and string to compare has been configured.",
				"type": "boolean",
				"$comment": "group:string"
			},
			"notifyMatch": {
				"title": "Notify Match",
				"description": "If true, will fire a notification when the string attribute matches the string to compare (string monitor or consumer). By default the consumer will notify match if observed attribute and string to compare has been configured.",
				"type": "boolean",
				"$comment": "group:string"
			},
			"stringToCompare": {
				"title": "String To Compare",
				"description": "Value for attribute to compare (string monitor or consumer). By default the consumer will notify match if observed attribute and string to compare has been configured.",
				"type": "string",
				"$comment": "group:string"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"objectDomain"
		]
	},
	"jolt": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"inputType": {
				"title": "Input Type",
				"description": "Specifies if the input is hydrated JSON or a JSON String.",
				"type": "string",
				"enum": [
					"Hydrated",
					"JsonString"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jolt.JoltInputOutputType",
				"default": "Hydrated"
			},
			"outputType": {
				"title": "Output Type",
				"description": "Specifies if the output should be hydrated JSON or a JSON String.",
				"type": "string",
				"enum": [
					"Hydrated",
					"JsonString"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jolt.JoltInputOutputType",
				"default": "Hydrated"
			},
			"transformDsl": {
				"title": "Transform Dsl",
				"description": "Specifies the Transform DSL of the endpoint resource. If none is specified Chainr will be used.",
				"type": "string",
				"enum": [
					"Chainr",
					"Shiftr",
					"Defaultr",
					"Removr",
					"Sortr"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jolt.JoltTransformType",
				"default": "Chainr"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"jooq": {
		"properties": {
			"entityType": {
				"title": "Entity Type",
				"description": "JOOQ entity class",
				"type": "string",
				"$comment": "group:common"
			},
			"databaseConfiguration": {
				"title": "Database Configuration",
				"description": "To use a specific database configuration",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.jooq.Configuration"
			},
			"consumeDelete": {
				"title": "Consume Delete",
				"description": "Delete entity after it is consumed",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"operation": {
				"title": "Operation",
				"description": "Type of operation to execute on query",
				"type": "string",
				"enum": [
					"EXECUTE",
					"FETCH",
					"NONE"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jooq.JooqOperation",
				"default": "NONE"
			},
			"query": {
				"title": "Query",
				"description": "To execute plain SQL query",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"jpa": {
		"properties": {
			"entityType": {
				"title": "Entity Type",
				"description": "Entity class name",
				"type": "string",
				"$comment": "group:common"
			},
			"joinTransaction": {
				"title": "Join Transaction",
				"description": "The camel-jpa component will join transaction by default. You can use this option to turn this off, for example, if you use LOCAL_RESOURCE and join transaction doesn't work with your JPA provider. This option can also be set globally on the JpaComponent, instead of having to set it on all endpoints.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"maximumResults": {
				"title": "Maximum Results",
				"description": "Set the maximum number of results to retrieve on the Query.",
				"type": "integer",
				"$comment": "group:common",
				"default": -1
			},
			"namedQuery": {
				"title": "Named Query",
				"description": "To use a named query.",
				"type": "string",
				"$comment": "group:common"
			},
			"nativeQuery": {
				"title": "Native Query",
				"description": "To use a custom native query. You may want to use the option resultClass also when using native queries.",
				"type": "string",
				"$comment": "group:common"
			},
			"persistenceUnit": {
				"title": "Persistence Unit",
				"description": "The JPA persistence unit used by default.",
				"type": "string",
				"$comment": "group:common",
				"default": "camel"
			},
			"query": {
				"title": "Query",
				"description": "To use a custom query.",
				"type": "string",
				"$comment": "group:common"
			},
			"resultClass": {
				"title": "Result Class",
				"description": "Defines the type of the returned payload (we will call entityManager.createNativeQuery(nativeQuery, resultClass) instead of entityManager.createNativeQuery(nativeQuery)). Without this option, we will return an object array. Only has an effect when using in conjunction with a native query when consuming data.",
				"type": "string",
				"$comment": "group:common"
			},
			"consumeDelete": {
				"title": "Consume Delete",
				"description": "If true, the entity is deleted after it is consumed; if false, the entity is not deleted.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"consumeLockEntity": {
				"title": "Consume Lock Entity",
				"description": "Specifies whether to set an exclusive lock on each entity bean while processing the results from polling.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"deleteHandler": {
				"title": "Delete Handler",
				"description": "To use a custom DeleteHandler to delete the row after the consumer is done processing the exchange",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.jpa.DeleteHandler<java.lang.Object>"
			},
			"lockModeType": {
				"title": "Lock Mode Type",
				"description": "To configure the lock mode on the consumer.",
				"type": "string",
				"enum": [
					"READ",
					"WRITE",
					"OPTIMISTIC",
					"OPTIMISTIC_FORCE_INCREMENT",
					"PESSIMISTIC_READ",
					"PESSIMISTIC_WRITE",
					"PESSIMISTIC_FORCE_INCREMENT",
					"NONE"
				],
				"$comment": "group:consumer",
				"format": "bean:jakarta.persistence.LockModeType",
				"default": "PESSIMISTIC_WRITE"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "An integer value to define the maximum number of messages to gather per poll. By default, no maximum is set. It can be used to avoid polling many thousands of messages when starting up the server. Set a value of 0 or negative to disable.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"preDeleteHandler": {
				"title": "Pre Delete Handler",
				"description": "To use a custom Pre-DeleteHandler to delete the row after the consumer has read the entity.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.jpa.DeleteHandler<java.lang.Object>"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"skipLockedEntity": {
				"title": "Skip Locked Entity",
				"description": "To configure whether to use NOWAIT on lock and silently skip the entity.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"transacted": {
				"title": "Transacted",
				"description": "Whether to run the consumer in transacted mode, by which all messages will either commit or rollback, when the entire batch has been processed. The default behavior (false) is to commit all the previously successfully processed messages, and only roll back the last failed message.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"parameters": {
				"title": "Parameters",
				"description": "This key/value mapping is used for building the query parameters. It is expected to be of the generic type java.util.Map where the keys are the named parameters of a given JPA query and the values are their corresponding effective values you want to select for. When it's used for producer, Simple expression can be used as a parameter value. It allows you to retrieve parameter values from the message body, header and etc.",
				"type": "object",
				"$comment": "group:consumer (advanced)"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"findEntity": {
				"title": "Find Entity",
				"description": "If enabled, then the producer will find a single entity by using the message body as a key and entityType as the class type. This can be used instead of a query to find a single entity.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"firstResult": {
				"title": "First Result",
				"description": "Set the position of the first result to retrieve.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"flushOnSend": {
				"title": "Flush On Send",
				"description": "Flushes the EntityManager after the entity bean has been persisted.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"outputTarget": {
				"title": "Output Target",
				"description": "To put the query (or find) result in a header or property instead of the body. If the value starts with the prefix property:, put the result into the so named property, otherwise into the header.",
				"type": "string",
				"$comment": "group:producer"
			},
			"remove": {
				"title": "Remove",
				"description": "Indicates to use entityManager.remove(entity).",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"singleResult": {
				"title": "Single Result",
				"description": "If enabled, a query or a find which would return no results or more than one result, will throw an exception instead.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useExecuteUpdate": {
				"title": "Use Execute Update",
				"description": "To configure whether to use executeUpdate() when producer executes a query. When you use INSERT, UPDATE or a DELETE statement as a named query, you need to specify this option to 'true'.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"usePersist": {
				"title": "Use Persist",
				"description": "Indicates to use entityManager.persist(entity) instead of entityManager.merge(entity). Note: entityManager.persist(entity) doesn't work for detached entities (where the EntityManager has to execute an UPDATE instead of an INSERT query)!",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"usePassedInEntityManager": {
				"title": "Use Passed In Entity Manager",
				"description": "If set to true, then Camel will use the EntityManager from the header JpaConstants.ENTITY_MANAGER instead of the configured entity manager on the component/endpoint. This allows end users to control which entity manager will be in use.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"entityManagerProperties": {
				"title": "Entity Manager Properties",
				"description": "Additional properties for the entity manager to use.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"sharedEntityManager": {
				"title": "Shared Entity Manager",
				"description": "Whether to use Spring's SharedEntityManager for the consumer/producer. Note in most cases, joinTransaction should be set to false as this is not an EXTENDED EntityManager.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"entityType",
			"persistenceUnit"
		]
	},
	"jslt": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"mapBigDecimalAsFloats": {
				"title": "Map Big Decimal As Floats",
				"description": "If true, the mapper will use the USE_BIG_DECIMAL_FOR_FLOATS in serialization features",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"objectMapper": {
				"title": "Object Mapper",
				"description": "Setting a custom JSON Object Mapper to be used",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:com.fasterxml.jackson.databind.ObjectMapper"
			},
			"prettyPrint": {
				"title": "Pretty Print",
				"description": "If true, JSON in output message is pretty printed.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"json-patch": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"json-validator": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"failOnNullBody": {
				"title": "Fail On Null Body",
				"description": "Whether to fail if no body exists.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"failOnNullHeader": {
				"title": "Fail On Null Header",
				"description": "Whether to fail if no header exists when validating against a header.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"headerName": {
				"title": "Header Name",
				"description": "To validate against a header instead of the message body.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"disabledDeserializationFeatures": {
				"title": "Disabled Deserialization Features",
				"description": "Comma-separated list of Jackson DeserializationFeature enum values which will be disabled for parsing exchange body",
				"type": "string",
				"$comment": "group:advanced"
			},
			"enabledDeserializationFeatures": {
				"title": "Enabled Deserialization Features",
				"description": "Comma-separated list of Jackson DeserializationFeature enum values which will be enabled for parsing exchange body",
				"type": "string",
				"$comment": "group:advanced"
			},
			"errorHandler": {
				"title": "Error Handler",
				"description": "To use a custom ValidatorErrorHandler. The default error handler captures the errors and throws an exception.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jsonvalidator.JsonValidatorErrorHandler"
			},
			"objectMapper": {
				"title": "Object Mapper",
				"description": "The used Jackson object mapper",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.fasterxml.jackson.databind.ObjectMapper"
			},
			"uriSchemaLoader": {
				"title": "Uri Schema Loader",
				"description": "To use a custom schema loader allowing for adding custom format validation. The default implementation will create a schema loader that tries to determine the schema version from the $schema property of the specified schema.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jsonvalidator.JsonUriSchemaLoader"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"jsonata": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"inputType": {
				"title": "Input Type",
				"description": "Specifies if the input should be Jackson JsonNode or a JSON String.",
				"type": "string",
				"enum": [
					"Jackson",
					"JsonString"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jsonata.JsonataInputOutputType",
				"default": "Jackson"
			},
			"outputType": {
				"title": "Output Type",
				"description": "Specifies if the output should be Jackson JsonNode or a JSON String.",
				"type": "string",
				"enum": [
					"Jackson",
					"JsonString"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jsonata.JsonataInputOutputType",
				"default": "Jackson"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"frameBinding": {
				"title": "Frame Binding",
				"description": "To configure the Jsonata frame binding. Allows custom functions to be added.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jsonata.JsonataFrameBinding"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"jt400": {
		"properties": {
			"userID": {
				"title": "User ID",
				"description": "Returns the ID of the IBM i user.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Returns the password of the IBM i user.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"systemName": {
				"title": "System Name",
				"description": "Returns the name of the IBM i system.",
				"type": "string",
				"$comment": "group:security"
			},
			"objectPath": {
				"title": "Object Path",
				"description": "Returns the fully qualified integrated file system path name of the target object of this endpoint.",
				"type": "string",
				"$comment": "group:common"
			},
			"type": {
				"title": "Type",
				"description": "Whether to work with data queues or remote program call",
				"type": "string",
				"enum": [
					"DTAQ",
					"PGM",
					"SRVPGM",
					"MSGQ"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.jt400.Jt400Type"
			},
			"ccsid": {
				"title": "Ccsid",
				"description": "Sets the CCSID to use for the connection with the IBM i system.",
				"type": "integer",
				"$comment": "group:common"
			},
			"format": {
				"title": "Format",
				"description": "Sets the data format for sending messages.",
				"type": "string",
				"enum": [
					"text",
					"binary"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.jt400.Jt400Configuration.Format",
				"default": "text"
			},
			"guiAvailable": {
				"title": "Gui Available",
				"description": "Sets whether IBM i prompting is enabled in the environment running Camel.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"keyed": {
				"title": "Keyed",
				"description": "Whether to use keyed or non-keyed data queues.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"searchKey": {
				"title": "Search Key",
				"description": "Search key for keyed data queues.",
				"type": "string",
				"$comment": "group:common"
			},
			"messageAction": {
				"title": "Message Action",
				"description": "Action to be taken on messages when read from a message queue. Messages can be marked as old (OLD), removed from the queue (REMOVE), or neither (SAME).",
				"type": "string",
				"enum": [
					"OLD",
					"REMOVE",
					"SAME"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.jt400.Jt400Configuration.MessageAction",
				"default": "OLD"
			},
			"readTimeout": {
				"title": "Read Timeout",
				"description": "Timeout in millis the consumer will wait while trying to read a new message of the data queue.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 30000
			},
			"searchType": {
				"title": "Search Type",
				"description": "Search type such as EQ for equal etc.",
				"type": "string",
				"enum": [
					"EQ",
					"NE",
					"LT",
					"LE",
					"GT",
					"GE"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.jt400.Jt400Configuration.SearchType",
				"default": "EQ"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendingReply": {
				"title": "Sending Reply",
				"description": "If true, the consumer endpoint will set the Jt400Constants.MESSAGE_REPLYTO_KEY header of the camel message for any IBM i inquiry messages received. If that message is then routed to a producer endpoint, the action will not be processed as sending a message to the queue, but rather a reply to the specific inquiry message.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"outputFieldsIdxArray": {
				"title": "Output Fields Idx Array",
				"description": "Specifies which fields (program parameters) are output parameters.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Integer[]"
			},
			"outputFieldsLengthArray": {
				"title": "Output Fields Length Array",
				"description": "Specifies the fields (program parameters) length as in the IBM i program definition.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Integer[]"
			},
			"procedureName": {
				"title": "Procedure Name",
				"description": "Procedure name from a service program to call",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"secured": {
				"title": "Secured",
				"description": "Whether connections to IBM i are secured with SSL.",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"userID",
			"password",
			"systemName",
			"objectPath",
			"type"
		]
	},
	"jte": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"kafka": {
		"properties": {
			"topic": {
				"title": "Topic",
				"description": "Name of the topic to use. On the consumer you can use comma to separate multiple topics. A producer can only send a message to a single topic.",
				"type": "string",
				"$comment": "group:common"
			},
			"additionalProperties": {
				"title": "Additional Properties",
				"description": "Sets additional properties for either kafka consumer or kafka producer in case they can't be set directly on the camel configurations (e.g.: new Kafka properties that are not reflected yet in Camel configurations), the properties have to be prefixed with additionalProperties.., e.g.: additionalProperties.transactional.id=12345&additionalProperties.schema.registry.url=http://localhost:8811/avro. If the properties are set in the application.properties file, they must be prefixed with camel.component.kafka.additional-properties and the property enclosed in square brackets, like this example: camel.component.kafka.additional-propertiesdelivery.timeout.ms=15000.",
				"type": "object",
				"$comment": "group:common"
			},
			"brokers": {
				"title": "Brokers",
				"description": "URL of the Kafka brokers to use. The format is host1:port1,host2:port2, and the list can be a subset of brokers or a VIP pointing to a subset of brokers. This option is known as bootstrap.servers in the Kafka documentation.",
				"type": "string",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request.",
				"type": "string",
				"$comment": "group:common"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"reconnectBackoffMaxMs": {
				"title": "Reconnect Backoff Max Ms",
				"description": "The maximum amount of time in milliseconds to wait when reconnecting to a broker that has repeatedly failed to connect. If provided, the backoff per host will increase exponentially for each consecutive connection failure, up to this maximum. After calculating the backoff increase, 20% random jitter is added to avoid connection storms.",
				"type": "integer",
				"$comment": "group:common",
				"default": "1000"
			},
			"retryBackoffMaxMs": {
				"title": "Retry Backoff Max Ms",
				"description": "The maximum amount of time in milliseconds to wait when retrying a request to the broker that has repeatedly failed. If provided, the backoff per client will increase exponentially for each failed request, up to this maximum. To prevent all clients from being synchronized upon retry, a randomized jitter with a factor of 0.2 will be applied to the backoff, resulting in the backoff falling within a range between 20% below and 20% above the computed value. If retry.backoff.ms is set to be higher than retry.backoff.max.ms, then retry.backoff.max.ms will be used as a constant backoff from the beginning without any exponential increase",
				"type": "integer",
				"$comment": "group:common",
				"default": "1000"
			},
			"retryBackoffMs": {
				"title": "Retry Backoff Ms",
				"description": "The amount of time to wait before attempting to retry a failed request to a given topic partition. This avoids repeatedly sending requests in a tight loop under some failure scenarios. This value is the initial backoff value and will increase exponentially for each failed request, up to the retry.backoff.max.ms value.",
				"type": "integer",
				"$comment": "group:common",
				"default": "100"
			},
			"shutdownTimeout": {
				"title": "Shutdown Timeout",
				"description": "Timeout in milliseconds to wait gracefully for the consumer or producer to shut down and terminate its worker threads.",
				"type": "integer",
				"$comment": "group:common",
				"default": 30000
			},
			"allowManualCommit": {
				"title": "Allow Manual Commit",
				"description": "Whether to allow doing manual commits via KafkaManualCommit. If this option is enabled then an instance of KafkaManualCommit is stored on the Exchange message header, which allows end users to access this API and perform manual offset commits via the Kafka consumer.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"autoCommitEnable": {
				"title": "Auto Commit Enable",
				"description": "If true, periodically commit to ZooKeeper the offset of messages already fetched by the consumer. This committed offset will be used when the process fails as the position from which the new consumer will begin.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"autoCommitIntervalMs": {
				"title": "Auto Commit Interval Ms",
				"description": "The frequency in ms that the consumer offsets are committed to zookeeper.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "5000"
			},
			"autoOffsetReset": {
				"title": "Auto Offset Reset",
				"description": "What to do when there is no initial offset in ZooKeeper or if an offset is out of range: earliest : automatically reset the offset to the earliest offset latest: automatically reset the offset to the latest offset fail: throw exception to the consumer",
				"type": "string",
				"enum": [
					"latest",
					"earliest",
					"none"
				],
				"$comment": "group:consumer",
				"default": "latest"
			},
			"batching": {
				"title": "Batching",
				"description": "Whether to use batching for processing or streaming. The default is false, which uses streaming. In streaming mode, then a single kafka record is processed per Camel exchange in the message body. In batching mode, then Camel groups many kafka records together as a List objects in the message body. The option maxPollRecords is used to define the number of records to group together in batching mode.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"batchingIntervalMs": {
				"title": "Batching Interval Ms",
				"description": "In consumer batching mode, then this option is specifying a time in millis, to trigger batch completion eager when the current batch size has not reached the maximum size defined by maxPollRecords. Notice the trigger is not exact at the given interval, as this can only happen between kafka polls (see pollTimeoutMs option). So for example setting this to 10000, then the trigger happens in the interval 10000 pollTimeoutMs. The default value for pollTimeoutMs is 5000, so this would mean a trigger interval at about every 15 seconds.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"breakOnFirstError": {
				"title": "Break On First Error",
				"description": "This options controls what happens when a consumer is processing an exchange and it fails. If the option is false then the consumer continues to the next message and processes it. If the option is true then the consumer breaks out. Using the default NoopCommitManager will cause the consumer to not commit the offset so that the message is re-attempted. The consumer should use the KafkaManualCommit to determine the best way to handle the message. Using either the SyncCommitManager or the AsyncCommitManager, the consumer will seek back to the offset of the message that caused a failure, and then re-attempt to process this message. However, this can lead to endless processing of the same message if it's bound to fail every time, e.g., a poison message. Therefore, it's recommended to deal with that, for example, by using Camel's error handler.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"checkCrcs": {
				"title": "Check Crcs",
				"description": "Automatically check the CRC32 of the records consumed. This ensures no on-the-wire or on-disk corruption to the messages occurred. This check adds some overhead, so it may be disabled in cases seeking extreme performance.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"commitTimeoutMs": {
				"title": "Commit Timeout Ms",
				"description": "The maximum time, in milliseconds, that the code will wait for a synchronous commit to complete",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "5000"
			},
			"consumerRequestTimeoutMs": {
				"title": "Consumer Request Timeout Ms",
				"description": "The configuration controls the maximum amount of time the client will wait for the response of a request. If the response is not received before the timeout elapsed, the client will resend the request if necessary or fail the request if retries are exhausted.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "30000"
			},
			"consumersCount": {
				"title": "Consumers Count",
				"description": "The number of consumers that connect to kafka server. Each consumer is run on a separate thread that retrieves and process the incoming data.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"fetchMaxBytes": {
				"title": "Fetch Max Bytes",
				"description": "The maximum amount of data the server should return for a fetch request. This is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that the consumer can make progress. The maximum message size accepted by the broker is defined via message.max.bytes (broker config) or max.message.bytes (topic config). Note that the consumer performs multiple fetches in parallel.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "52428800"
			},
			"fetchMinBytes": {
				"title": "Fetch Min Bytes",
				"description": "The minimum amount of data the server should return for a fetch request. If insufficient data is available, the request will wait for that much data to accumulate before answering the request.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "1"
			},
			"fetchWaitMaxMs": {
				"title": "Fetch Wait Max Ms",
				"description": "The maximum amount of time the server will block before answering the fetch request if there isn't enough data to immediately satisfy fetch.min.bytes",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "500"
			},
			"groupId": {
				"title": "Group Id",
				"description": "A string that uniquely identifies the group of consumer processes to which this consumer belongs. By setting the same group id, multiple processes can indicate that they are all part of the same consumer group. This option is required for consumers.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"groupInstanceId": {
				"title": "Group Instance Id",
				"description": "A unique identifier of the consumer instance provided by the end user. Only non-empty strings are permitted. If set, the consumer is treated as a static member, which means that only one instance with this ID is allowed in the consumer group at any time. This can be used in combination with a larger session timeout to avoid group rebalances caused by transient unavailability (e.g., process restarts). If not set, the consumer will join the group as a dynamic member, which is the traditional behavior.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"headerDeserializer": {
				"title": "Header Deserializer",
				"description": "To use a custom KafkaHeaderDeserializer to deserialize kafka headers values",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.kafka.serde.KafkaHeaderDeserializer"
			},
			"heartbeatIntervalMs": {
				"title": "Heartbeat Interval Ms",
				"description": "The expected time between heartbeats to the consumer coordinator when using Kafka's group management facilities. Heartbeats are used to ensure that the consumer's session stays active and to facilitate rebalancing when new consumers join or leave the group. The value must be set lower than session.timeout.ms, but typically should be set no higher than 1/3 of that value. It can be adjusted even lower to control the expected time for normal rebalances.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "3000"
			},
			"keyDeserializer": {
				"title": "Key Deserializer",
				"description": "Deserializer class for the key that implements the Deserializer interface.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.common.serialization.StringDeserializer"
			},
			"maxPartitionFetchBytes": {
				"title": "Max Partition Fetch Bytes",
				"description": "The maximum amount of data per-partition the server will return. The maximum total memory used for a request will be #partitions max.partition.fetch.bytes. This size must be at least as large as the maximum message size the server allows or else it is possible for the producer to send messages larger than the consumer can fetch. If that happens, the consumer can get stuck trying to fetch a large message on a certain partition.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "1048576"
			},
			"maxPollIntervalMs": {
				"title": "Max Poll Interval Ms",
				"description": "The maximum delay between invocations of poll() when using consumer group management. This places an upper bound on the amount of time that the consumer can be idle before fetching more records. If poll() is not called before expiration of this timeout, then the consumer is considered failed, and the group will re-balance to reassign the partitions to another member.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration"
			},
			"maxPollRecords": {
				"title": "Max Poll Records",
				"description": "The maximum number of records returned in a single call to poll()",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "500"
			},
			"offsetRepository": {
				"title": "Offset Repository",
				"description": "The offset repository to use to locally store the offset of each partition of the topic. Defining one will disable the autocommit.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.spi.StateRepository<java.lang.String, java.lang.String>"
			},
			"partitionAssignor": {
				"title": "Partition Assignor",
				"description": "The class name of the partition assignment strategy that the client will use to distribute partition ownership amongst consumer instances when group management is used",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.clients.consumer.RangeAssignor"
			},
			"pollOnError": {
				"title": "Poll On Error",
				"description": "What to do if kafka threw an exception while polling for new messages. Will by default use the value from the component configuration unless an explicit value has been configured on the endpoint level. DISCARD will discard the message and continue to poll the next message. ERROR_HANDLER will use Camel's error handler to process the exception, and afterwards continue to poll the next message. RECONNECT will re-connect the consumer and try polling the message again. RETRY will let the consumer retry poll the same message again. STOP will stop the consumer (it has to be manually started/restarted if the consumer should be able to consume messages again)",
				"type": "string",
				"enum": [
					"DISCARD",
					"ERROR_HANDLER",
					"RECONNECT",
					"RETRY",
					"STOP"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.kafka.PollOnError",
				"default": "ERROR_HANDLER"
			},
			"pollTimeoutMs": {
				"title": "Poll Timeout Ms",
				"description": "The timeout used when polling the KafkaConsumer.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "5000"
			},
			"preValidateHostAndPort": {
				"title": "Pre Validate Host And Port",
				"description": "Whether to eager validate that broker host:port is valid and can be DNS resolved to known host during starting this consumer. If the validation fails, then an exception is thrown, which makes Camel fail fast. Disabling this will postpone the validation after the consumer is started, and Camel will keep re-connecting in case of validation or DNS resolution error.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"seekTo": {
				"title": "Seek To",
				"description": "Set if KafkaConsumer should read from the beginning or the end on startup: SeekPolicy.BEGINNING: read from the beginning. SeekPolicy.END: read from the end.",
				"type": "string",
				"enum": [
					"BEGINNING",
					"END"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.kafka.SeekPolicy"
			},
			"sessionTimeoutMs": {
				"title": "Session Timeout Ms",
				"description": "The timeout used to detect failures when using Kafka's group management facilities.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "45000"
			},
			"specificAvroReader": {
				"title": "Specific Avro Reader",
				"description": "This enables the use of a specific Avro reader for use with the in multiple Schema registries documentation with Avro Deserializers implementation. This option is only available externally (not standard Apache Kafka)",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"topicIsPattern": {
				"title": "Topic Is Pattern",
				"description": "Whether the topic is a pattern (regular expression). This can be used to subscribe to dynamic number of topics matching the pattern.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"valueDeserializer": {
				"title": "Value Deserializer",
				"description": "Deserializer class for value that implements the Deserializer interface.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "org.apache.kafka.common.serialization.StringDeserializer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"isolationLevel": {
				"title": "Isolation Level",
				"description": "Controls how to read messages written transactionally. If set to read_committed, consumer.poll() will only return transactional messages which have been committed. If set to read_uncommitted (the default), consumer.poll() will return all messages, even transactional messages which have been aborted. Non-transactional messages will be returned unconditionally in either mode. Messages will always be returned in offset order. Hence, in read_committed mode, consumer.poll() will only return messages up to the last stable offset (LSO), which is the one less than the offset of the first open transaction. In particular, any messages appearing after messages belonging to ongoing transactions will be withheld until the relevant transaction has been completed. As a result, read_committed consumers will not be able to read up to the high watermark when there are in flight transactions. Further, when in read_committed the seekToEnd method will return the LSO",
				"type": "string",
				"enum": [
					"read_uncommitted",
					"read_committed"
				],
				"$comment": "group:consumer (advanced)",
				"default": "read_uncommitted"
			},
			"kafkaManualCommitFactory": {
				"title": "Kafka Manual Commit Factory",
				"description": "Factory to use for creating KafkaManualCommit instances. This allows to plugin a custom factory to create custom KafkaManualCommit instances in case special logic is needed when doing manual commits that deviates from the default implementation that comes out of the box.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.kafka.consumer.KafkaManualCommitFactory"
			},
			"batchWithIndividualHeaders": {
				"title": "Batch With Individual Headers",
				"description": "If this feature is enabled and a single element of a batch is an Exchange or Message, the producer will generate individual kafka header values for it by using the batch Message to determine the values. Normal behavior consists of always using the same header values (which are determined by the parent Exchange which contains the Iterable or Iterator).",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"bufferMemorySize": {
				"title": "Buffer Memory Size",
				"description": "The total bytes of memory the producer can use to buffer records waiting to be sent to the server. If records are sent faster than they can be delivered to the server, the producer will either block or throw an exception based on the preference specified by block.on.buffer.full.This setting should correspond roughly to the total memory the producer will use, but is not a hard bound since not all memory the producer uses is used for buffering. Some additional memory will be used for compression (if compression is enabled) as well as for maintaining in-flight requests.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "33554432"
			},
			"compressionCodec": {
				"title": "Compression Codec",
				"description": "This parameter allows you to specify the compression codec for all data generated by this producer. Valid values are none, gzip, snappy, lz4 and zstd.",
				"type": "string",
				"enum": [
					"none",
					"gzip",
					"snappy",
					"lz4",
					"zstd"
				],
				"$comment": "group:producer",
				"default": "none"
			},
			"connectionMaxIdleMs": {
				"title": "Connection Max Idle Ms",
				"description": "Close idle connections after the number of milliseconds specified by this config.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "540000"
			},
			"deliveryTimeoutMs": {
				"title": "Delivery Timeout Ms",
				"description": "An upper bound on the time to report success or failure after a call to send() returns. This limits the total time that a record will be delayed prior to sending, the time to await acknowledgement from the broker (if expected), and the time allowed for retriable send failures.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "120000"
			},
			"enableIdempotence": {
				"title": "Enable Idempotence",
				"description": "When set to 'true', the producer will ensure that exactly one copy of each message is written in the stream. If 'false', producer retries due to broker failures, etc., may write duplicates of the retried message in the stream. Note that enabling idempotence requires max.in.flight.requests.per.connection to be less than or equal to 5 (with message ordering preserved for any allowable value), retries to be greater than 0, and acks must be 'all'. Idempotence is enabled by default if no conflicting configurations are set. If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled. If idempotence is explicitly enabled and conflicting configurations are set, a ConfigException is thrown.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"headerSerializer": {
				"title": "Header Serializer",
				"description": "To use a custom KafkaHeaderSerializer to serialize kafka headers values",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.kafka.serde.KafkaHeaderSerializer"
			},
			"key": {
				"title": "Key",
				"description": "The record key (or null if no key is specified). If this option has been configured then it take precedence over header KafkaConstants#KEY",
				"type": "string",
				"$comment": "group:producer"
			},
			"keySerializer": {
				"title": "Key Serializer",
				"description": "The serializer class for keys (defaults to the same as for messages if nothing is given).",
				"type": "string",
				"$comment": "group:producer",
				"default": "org.apache.kafka.common.serialization.StringSerializer"
			},
			"lingerMs": {
				"title": "Linger Ms",
				"description": "The producer groups together any records that arrive in between request transmissions into a single, batched, request. Normally, this occurs only under load when records arrive faster than they can be sent out. However, in some circumstances, the client may want to reduce the number of requests even under a moderate load. This setting achieves this by adding a small amount of artificial delay. That is, rather than immediately sending out a record, the producer will wait for up to the given delay to allow other records to be sent so that they can be batched together. This can be thought of as analogous to Nagle's algorithm in TCP. This setting gives the upper bound on the delay for batching: once we get batch.size worth of records for a partition, it will be sent immediately regardless of this setting, however, if we have fewer than this many bytes accumulated for this partition, we will 'linger' for the specified time waiting for more records to show up. This setting defaults to 0 (i.e., no delay). Setting linger.ms=5, for example, would have the effect of reducing the number of requests sent but would add up to 5ms of latency to records sent in the absence of load.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "0"
			},
			"maxBlockMs": {
				"title": "Max Block Ms",
				"description": "The configuration controls how long the KafkaProducer's send(), partitionsFor(), initTransactions(), sendOffsetsToTransaction(), commitTransaction() and abortTransaction() methods will block. For send() this timeout bounds the total time waiting for both metadata fetch and buffer allocation (blocking in the user-supplied serializers or partitioner is not counted against this timeout). For partitionsFor() this time out bounds the time spent waiting for metadata if it is unavailable. The transaction-related methods always block, but may time out if the transaction coordinator could not be discovered or did not respond within the timeout.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "60000"
			},
			"maxInFlightRequest": {
				"title": "Max In Flight Request",
				"description": "The maximum number of unacknowledged requests the client will send on a single connection before blocking. Note that if this setting is set to be greater than 1 and there are failed sends, there is a risk of message re-ordering due to retries (i.e., if retries are enabled).",
				"type": "integer",
				"$comment": "group:producer",
				"default": "5"
			},
			"maxRequestSize": {
				"title": "Max Request Size",
				"description": "The maximum size of a request. This is also effectively a cap on the maximum record size. Note that the server has its own cap on record size which may be different from this. This setting will limit the number of record batches the producer will send in a single request to avoid sending huge requests.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "1048576"
			},
			"metadataMaxAgeMs": {
				"title": "Metadata Max Age Ms",
				"description": "The period of time in milliseconds after which we force a refresh of metadata even if we haven't seen any partition leadership changes to proactively discover any new brokers or partitions.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "300000"
			},
			"metricReporters": {
				"title": "Metric Reporters",
				"description": "A list of classes to use as metrics reporters. Implementing the MetricReporter interface allows plugging in classes that will be notified of new metric creation. The JmxReporter is always included to register JMX statistics.",
				"type": "string",
				"$comment": "group:producer"
			},
			"metricsSampleWindowMs": {
				"title": "Metrics Sample Window Ms",
				"description": "The window of time a metrics sample is computed over.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "30000"
			},
			"noOfMetricsSample": {
				"title": "No Of Metrics Sample",
				"description": "The number of samples maintained to compute metrics.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "2"
			},
			"partitioner": {
				"title": "Partitioner",
				"description": "The partitioner class for partitioning messages amongst sub-topics. The default partitioner is based on the hash of the key.",
				"type": "string",
				"$comment": "group:producer"
			},
			"partitionerIgnoreKeys": {
				"title": "Partitioner Ignore Keys",
				"description": "Whether the message keys should be ignored when computing the partition. This setting has effect only when partitioner is not set",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"partitionKey": {
				"title": "Partition Key",
				"description": "The partition to which the record will be sent (or null if no partition was specified). If this option has been configured then it take precedence over header KafkaConstants#PARTITION_KEY",
				"type": "integer",
				"$comment": "group:producer"
			},
			"producerBatchSize": {
				"title": "Producer Batch Size",
				"description": "The producer will attempt to batch records together into fewer requests whenever multiple records are being sent to the same partition. This helps performance on both the client and the server. This configuration controls the default batch size in bytes. No attempt will be made to batch records larger than this size. Requests sent to brokers will contain multiple batches, one for each partition with data available to be sent. A small batch size will make batching less common and may reduce throughput (a batch size of zero will disable batching entirely). A very large batch size may use memory a bit more wastefully as we will always allocate a buffer of the specified batch size in anticipation of additional records.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "16384"
			},
			"queueBufferingMaxMessages": {
				"title": "Queue Buffering Max Messages",
				"description": "The maximum number of unsent messages that can be queued up the producer when using async mode before either the producer must be blocked or data must be dropped.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "10000"
			},
			"receiveBufferBytes": {
				"title": "Receive Buffer Bytes",
				"description": "The size of the TCP receive buffer (SO_RCVBUF) to use when reading data.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "65536"
			},
			"reconnectBackoffMs": {
				"title": "Reconnect Backoff Ms",
				"description": "The amount of time to wait before attempting to reconnect to a given host. This avoids repeatedly connecting to a host in a tight loop. This backoff applies to all requests sent by the consumer to the broker.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "50"
			},
			"requestRequiredAcks": {
				"title": "Request Required Acks",
				"description": "The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the durability of records that are sent. The following settings are allowed: acks=0 If set to zero, then the producer will not wait for any acknowledgment from the server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be made that the server has received the record in this case, and the retry configuration will not take effect (as the client won't generally know of any failures). The offset given back for each record will always be set to -1. acks=1 This will mean the leader will write the record to its local log but will respond without awaiting full acknowledgment from all followers. In this case should the leader fail immediately after acknowledging the record, but before the followers have replicated it, then the record will be lost. acks=all This means the leader will wait for the full set of in-sync replicas to acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica remains alive. This is the strongest available guarantee. This is equivalent to the acks=-1 setting. Note that enabling idempotence requires this config value to be 'all'. If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled.",
				"type": "string",
				"enum": [
					"all",
					"-1",
					"0",
					"1"
				],
				"$comment": "group:producer",
				"default": "all"
			},
			"requestTimeoutMs": {
				"title": "Request Timeout Ms",
				"description": "The amount of time the broker will wait trying to meet the request.required.acks requirement before sending back an error to the client.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "30000"
			},
			"retries": {
				"title": "Retries",
				"description": "Setting a value greater than zero will cause the client to resend any record that has failed to be sent due to a potentially transient error. Note that this retry is no different from if the client re-sending the record upon receiving the error. Produce requests will be failed before the number of retries has been exhausted if the timeout configured by delivery.timeout.ms expires first before successful acknowledgement. Users should generally prefer to leave this config unset and instead use delivery.timeout.ms to control retry behavior. Enabling idempotence requires this config value to be greater than 0. If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled. Allowing retries while setting enable.idempotence to false and max.in.flight.requests.per.connection to 1 will potentially change the ordering of records, because if two batches are sent to a single partition, and the first fails and is retried but the second succeeds; then the records in the second batch may appear first.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"sendBufferBytes": {
				"title": "Send Buffer Bytes",
				"description": "Socket write buffer size",
				"type": "integer",
				"$comment": "group:producer",
				"default": "131072"
			},
			"useIterator": {
				"title": "Use Iterator",
				"description": "Sets whether sending to kafka should send the message body as a single record, or use a java.util.Iterator to send multiple records to kafka (if the message body can be iterated).",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"valueSerializer": {
				"title": "Value Serializer",
				"description": "The serializer class for messages.",
				"type": "string",
				"$comment": "group:producer",
				"default": "org.apache.kafka.common.serialization.StringSerializer"
			},
			"workerPool": {
				"title": "Worker Pool",
				"description": "To use a custom worker pool for continue routing Exchange after kafka server has acknowledged the message that was sent to it from KafkaProducer using asynchronous non-blocking processing. If using this option, then you must handle the lifecycle of the thread pool to shut the pool down when no longer needed.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.util.concurrent.ExecutorService"
			},
			"workerPoolCoreSize": {
				"title": "Worker Pool Core Size",
				"description": "Number of core threads for the worker pool for continue routing Exchange after kafka server has acknowledged the message that was sent to it from KafkaProducer using asynchronous non-blocking processing.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "10"
			},
			"workerPoolMaxSize": {
				"title": "Worker Pool Max Size",
				"description": "Maximum number of threads for the worker pool for continue routing Exchange after kafka server has acknowledged the message that was sent to it from KafkaProducer using asynchronous non-blocking processing.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "20"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"recordMetadata": {
				"title": "Record Metadata",
				"description": "Whether the producer should store the RecordMetadata results from sending to Kafka. The results are stored in a List containing the RecordMetadata metadata's. The list is stored on a header with the key KafkaConstants#KAFKA_RECORD_META",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"kafkaClientFactory": {
				"title": "Kafka Client Factory",
				"description": "Factory to use for creating org.apache.kafka.clients.consumer.KafkaConsumer and org.apache.kafka.clients.producer.KafkaProducer instances. This allows to configure a custom factory to create instances with logic that extends the vanilla Kafka clients.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.kafka.KafkaClientFactory"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"interceptorClasses": {
				"title": "Interceptor Classes",
				"description": "Sets interceptors for producer or consumers. Producer interceptors have to be classes implementing org.apache.kafka.clients.producer.ProducerInterceptor Consumer interceptors have to be classes implementing org.apache.kafka.clients.consumer.ConsumerInterceptor Note that if you use Producer interceptor on a consumer it will throw a class cast exception in runtime",
				"type": "string",
				"$comment": "group:monitoring"
			},
			"schemaRegistryURL": {
				"title": "Schema Registry URL",
				"description": "URL of the schema registry servers to use. The format is host1:port1,host2:port2. This is known as schema.registry.url in multiple Schema registries documentation. This option is only available externally (not standard Apache Kafka)",
				"type": "string",
				"$comment": "group:schema"
			},
			"kerberosBeforeReloginMinTime": {
				"title": "Kerberos Before Relogin Min Time",
				"description": "Login thread sleep time between refresh attempts.",
				"type": "integer",
				"$comment": "group:security",
				"default": "60000"
			},
			"kerberosConfigLocation": {
				"title": "Kerberos Config Location",
				"description": "Location of the kerberos config file.",
				"type": "string",
				"$comment": "group:security"
			},
			"kerberosInitCmd": {
				"title": "Kerberos Init Cmd",
				"description": "Kerberos kinit command path. Default is /usr/bin/kinit",
				"type": "string",
				"$comment": "group:security",
				"default": "/usr/bin/kinit"
			},
			"kerberosPrincipalToLocalRules": {
				"title": "Kerberos Principal To Local Rules",
				"description": "A list of rules for mapping from principal names to short names (typically operating system usernames). The rules are evaluated in order, and the first rule that matches a principal name is used to map it to a short name. Any later rules in the list are ignored. By default, principal names of the form {username}/{hostname}{REALM} are mapped to {username}. For more details on the format, please see the Security Authorization and ACLs documentation (at the Apache Kafka project website). Multiple values can be separated by comma",
				"type": "string",
				"$comment": "group:security",
				"default": "DEFAULT"
			},
			"kerberosRenewJitter": {
				"title": "Kerberos Renew Jitter",
				"description": "Percentage of random jitter added to the renewal time.",
				"type": "number",
				"$comment": "group:security",
				"default": "0.05"
			},
			"kerberosRenewWindowFactor": {
				"title": "Kerberos Renew Window Factor",
				"description": "Login thread will sleep until the specified window factor of time from last refresh to ticket's expiry has been reached, at which time it will try to renew the ticket.",
				"type": "number",
				"$comment": "group:security",
				"default": "0.8"
			},
			"saslJaasConfig": {
				"title": "Sasl Jaas Config",
				"description": "Expose the kafka sasl.jaas.config parameter Example: org.apache.kafka.common.security.plain.PlainLoginModule required username=USERNAME password=PASSWORD;",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"saslKerberosServiceName": {
				"title": "Sasl Kerberos Service Name",
				"description": "The Kerberos principal name that Kafka runs as. This can be defined either in Kafka's JAAS config or in Kafka's config.",
				"type": "string",
				"$comment": "group:security"
			},
			"saslMechanism": {
				"title": "Sasl Mechanism",
				"description": "The Simple Authentication and Security Layer (SASL) Mechanism used. For the valid values see http://www.iana.org/assignments/sasl-mechanisms/sasl-mechanisms.xhtml",
				"type": "string",
				"$comment": "group:security",
				"default": "GSSAPI"
			},
			"securityProtocol": {
				"title": "Security Protocol",
				"description": "Protocol used to communicate with brokers. SASL_PLAINTEXT, PLAINTEXT, SASL_SSL and SSL are supported",
				"type": "string",
				"$comment": "group:security",
				"default": "PLAINTEXT"
			},
			"sslCipherSuites": {
				"title": "Ssl Cipher Suites",
				"description": "A list of cipher suites. This is a named combination of authentication, encryption, MAC and key exchange algorithm used to negotiate the security settings for a network connection using TLS or SSL network protocol. By default, all the available cipher suites are supported.",
				"type": "string",
				"$comment": "group:security"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "SSL configuration using a Camel SSLContextParameters object. If configured, it's applied before the other SSL endpoint parameters. NOTE: Kafka only supports loading keystore from file locations, so prefix the location with file: in the KeyStoreParameters.resource option.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"sslEnabledProtocols": {
				"title": "Ssl Enabled Protocols",
				"description": "The list of protocols enabled for SSL connections. The default is TLSv1.2,TLSv1.3 when running with Java 11 or newer, TLSv1.2 otherwise. With the default value for Java 11, clients and servers will prefer TLSv1.3 if both support it and fallback to TLSv1.2 otherwise (assuming both support at least TLSv1.2). This default should be fine for most cases. Also see the config documentation for SslProtocol.",
				"type": "string",
				"$comment": "group:security"
			},
			"sslEndpointAlgorithm": {
				"title": "Ssl Endpoint Algorithm",
				"description": "The endpoint identification algorithm to validate server hostname using server certificate. Use none or false to disable server hostname verification.",
				"type": "string",
				"$comment": "group:security",
				"default": "https"
			},
			"sslKeymanagerAlgorithm": {
				"title": "Ssl Keymanager Algorithm",
				"description": "The algorithm used by key manager factory for SSL connections. Default value is the key manager factory algorithm configured for the Java Virtual Machine.",
				"type": "string",
				"$comment": "group:security",
				"default": "SunX509"
			},
			"sslKeyPassword": {
				"title": "Ssl Key Password",
				"description": "The password of the private key in the key store file or the PEM key specified in sslKeystoreKey. This is required for clients only if two-way authentication is configured.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslKeystoreLocation": {
				"title": "Ssl Keystore Location",
				"description": "The location of the key store file. This is optional for the client and can be used for two-way authentication for the client.",
				"type": "string",
				"$comment": "group:security"
			},
			"sslKeystorePassword": {
				"title": "Ssl Keystore Password",
				"description": "The store password for the key store file. This is optional for the client and only needed if sslKeystoreLocation is configured. Key store password is not supported for PEM format.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslKeystoreType": {
				"title": "Ssl Keystore Type",
				"description": "The file format of the key store file. This is optional for the client. The default value is JKS",
				"type": "string",
				"$comment": "group:security",
				"default": "JKS"
			},
			"sslProtocol": {
				"title": "Ssl Protocol",
				"description": "The SSL protocol used to generate the SSLContext. The default is TLSv1.3 when running with Java 11 or newer, TLSv1.2 otherwise. This value should be fine for most use cases. Allowed values in recent JVMs are TLSv1.2 and TLSv1.3. TLS, TLSv1.1, SSL, SSLv2 and SSLv3 may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities. With the default value for this config and sslEnabledProtocols, clients will downgrade to TLSv1.2 if the server does not support TLSv1.3. If this config is set to TLSv1.2, clients will not use TLSv1.3 even if it is one of the values in sslEnabledProtocols and the server only supports TLSv1.3.",
				"type": "string",
				"$comment": "group:security"
			},
			"sslProvider": {
				"title": "Ssl Provider",
				"description": "The name of the security provider used for SSL connections. Default value is the default security provider of the JVM.",
				"type": "string",
				"$comment": "group:security"
			},
			"sslTrustmanagerAlgorithm": {
				"title": "Ssl Trustmanager Algorithm",
				"description": "The algorithm used by trust manager factory for SSL connections. Default value is the trust manager factory algorithm configured for the Java Virtual Machine.",
				"type": "string",
				"$comment": "group:security",
				"default": "PKIX"
			},
			"sslTruststoreLocation": {
				"title": "Ssl Truststore Location",
				"description": "The location of the trust store file.",
				"type": "string",
				"$comment": "group:security"
			},
			"sslTruststorePassword": {
				"title": "Ssl Truststore Password",
				"description": "The password for the trust store file. If a password is not set, trust store file configured will still be used, but integrity checking is disabled. Trust store password is not supported for PEM format.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslTruststoreType": {
				"title": "Ssl Truststore Type",
				"description": "The file format of the trust store file. The default value is JKS.",
				"type": "string",
				"$comment": "group:security",
				"default": "JKS"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"topic"
		]
	},
	"kamelet": {
		"properties": {
			"templateId": {
				"title": "Template Id",
				"description": "The Route Template ID",
				"type": "string",
				"$comment": "group:common"
			},
			"routeId": {
				"title": "Route Id",
				"description": "The Route ID. Default value notice: The ID will be auto-generated if not provided",
				"type": "string",
				"$comment": "group:advanced"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"block": {
				"title": "Block",
				"description": "If sending a message to a direct endpoint which has no active consumer, then we can tell the producer to block and wait for the consumer to become active.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"failIfNoConsumers": {
				"title": "Fail If No Consumers",
				"description": "Whether the producer should fail by throwing an exception, when sending to a kamelet endpoint with no active consumers.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"timeout": {
				"title": "Timeout",
				"description": "The timeout value to use if block is enabled.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": 30000
			},
			"location": {
				"title": "Location",
				"description": "Location of the Kamelet to use which can be specified as a resource from file system, classpath etc. The location cannot use wildcards, and must refer to a file including extension, for example file:/etc/foo-kamelet.xml",
				"type": "string",
				"$comment": "group:advanced"
			},
			"noErrorHandler": {
				"title": "No Error Handler",
				"description": "Whether kamelets should use error handling or not. By default, the Kamelet uses the same error handler as from the calling route. This means that if the calling route has error handling that performs retries, or routing to a dead letter channel, then the kamelet route will use this also. This can be turned off by setting this option to true. If off then the kamelet route is not using error handling, and any exception thrown will for source kamelets be logged by the consumer, and the sink/action kamelets will fail processing.",
				"type": "boolean",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"templateId"
		]
	},
	"knative": {
		"properties": {
			"type": {
				"title": "Type",
				"description": "The Knative resource type",
				"type": "string",
				"enum": [
					"endpoint",
					"channel",
					"event"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.knative.spi.Knative.Type"
			},
			"typeId": {
				"title": "Type Id",
				"description": "The identifier of the Knative resource",
				"type": "string",
				"$comment": "group:common"
			},
			"ceOverride": {
				"title": "Ce Override",
				"description": "CloudEvent headers to override",
				"type": "object",
				"$comment": "group:common"
			},
			"cloudEventsSpecVersion": {
				"title": "Cloud Events Spec Version",
				"description": "Set the version of the cloudevents spec.",
				"type": "string",
				"enum": [
					"1.0",
					"1.0.1",
					"1.0.2"
				],
				"$comment": "group:common",
				"default": "1.0"
			},
			"cloudEventsType": {
				"title": "Cloud Events Type",
				"description": "Set the event-type information of the produced events.",
				"type": "string",
				"$comment": "group:common",
				"default": "org.apache.camel.event"
			},
			"environment": {
				"title": "Environment",
				"description": "The environment",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.knative.spi.KnativeEnvironment"
			},
			"filters": {
				"title": "Filters",
				"description": "Set the filters.",
				"type": "object",
				"$comment": "group:common"
			},
			"sinkBinding": {
				"title": "Sink Binding",
				"description": "The SinkBinding configuration.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.knative.spi.KnativeSinkBinding"
			},
			"transportOptions": {
				"title": "Transport Options",
				"description": "Set the transport options.",
				"type": "object",
				"$comment": "group:common"
			},
			"replyWithCloudEvent": {
				"title": "Reply With Cloud Event",
				"description": "Transforms the reply into a cloud event that will be processed by the caller. When listening to events from a Knative Broker, if this flag is enabled, replies will be published to the same Broker where the request comes from (beware that if you don't change the type of the received message, you may create a loop and receive your same reply). When this flag is disabled, CloudEvent headers are removed from the reply.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"reply": {
				"title": "Reply",
				"description": "If the consumer should construct a full reply to knative request.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The version of the k8s resource referenced by the endpoint.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"kind": {
				"title": "Kind",
				"description": "The type of the k8s resource referenced by the endpoint.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"name": {
				"title": "Name",
				"description": "The name of the k8s resource referenced by the endpoint.",
				"type": "string",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"kserve": {
		"properties": {
			"api": {
				"title": "Api",
				"description": "The KServe API",
				"type": "string",
				"enum": [
					"infer",
					"model/ready",
					"model/metadata",
					"server/ready",
					"server/live",
					"server/metadata"
				],
				"$comment": "group:producer"
			},
			"modelName": {
				"title": "Model Name",
				"description": "The name of the model used for inference.",
				"type": "string",
				"$comment": "group:common"
			},
			"modelVersion": {
				"title": "Model Version",
				"description": "The version of the model used for inference.",
				"type": "string",
				"$comment": "group:common"
			},
			"target": {
				"title": "Target",
				"description": "The target URI of the client. See: https://grpc.github.io/grpc-java/javadoc/io/grpc/Grpc.html#newChannelBuilder%28java.lang.String,io.grpc.ChannelCredentials%29",
				"type": "string",
				"$comment": "group:common",
				"default": "localhost:8001"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"credentials": {
				"title": "Credentials",
				"description": "The credentials of the client.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:io.grpc.ChannelCredentials"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"api"
		]
	},
	"kubernetes-config-maps": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-cronjob": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer",
				"default": "tcp"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-custom-resources": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-deployments": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-events": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-hpa": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-job": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer",
				"default": "tcp"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-namespaces": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-nodes": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-persistent-volumes": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer",
				"default": "tcp"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-persistent-volumes-claims": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer",
				"default": "tcp"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-pods": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-replication-controllers": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-resources-quota": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer",
				"default": "tcp"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-secrets": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer",
				"default": "tcp"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-service-accounts": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer",
				"default": "tcp"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kubernetes-services": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"kudu": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Host of the server to connect to",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port of the server to connect to",
				"type": "string",
				"$comment": "group:common"
			},
			"tableName": {
				"title": "Table Name",
				"description": "Table to connect to",
				"type": "string",
				"$comment": "group:common"
			},
			"operation": {
				"title": "Operation",
				"description": "Operation to perform",
				"type": "string",
				"enum": [
					"INSERT",
					"DELETE",
					"UPDATE",
					"UPSERT",
					"CREATE_TABLE",
					"SCAN"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.kudu.KuduOperations"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"port"
		]
	},
	"langchain4j-chat": {
		"properties": {
			"chatId": {
				"title": "Chat Id",
				"description": "The id",
				"type": "string",
				"$comment": "group:common"
			},
			"chatOperation": {
				"title": "Chat Operation",
				"description": "Operation in case of Endpoint of type CHAT. The value is one of the values of org.apache.camel.component.langchain4j.chat.LangChain4jChatOperations",
				"type": "string",
				"enum": [
					"CHAT_SINGLE_MESSAGE",
					"CHAT_SINGLE_MESSAGE_WITH_PROMPT",
					"CHAT_MULTIPLE_MESSAGES"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.langchain4j.chat.LangChain4jChatOperations",
				"default": "CHAT_SINGLE_MESSAGE"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"chatModel": {
				"title": "Chat Model",
				"description": "Chat Language Model of type dev.langchain4j.model.chat.ChatLanguageModel",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:dev.langchain4j.model.chat.ChatLanguageModel"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"chatId",
			"chatOperation"
		]
	},
	"langchain4j-embeddings": {
		"properties": {
			"embeddingId": {
				"title": "Embedding Id",
				"description": "The id",
				"type": "string",
				"$comment": "group:producer"
			},
			"embeddingModel": {
				"title": "Embedding Model",
				"description": "The EmbeddingModel engine to use.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:dev.langchain4j.model.embedding.EmbeddingModel"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"embeddingId",
			"embeddingModel"
		]
	},
	"langchain4j-tools": {
		"properties": {
			"toolId": {
				"title": "Tool Id",
				"description": "The tool name",
				"type": "string",
				"$comment": "group:common"
			},
			"tags": {
				"title": "Tags",
				"description": "The tags for the tools",
				"type": "string",
				"$comment": "group:common"
			},
			"description": {
				"title": "Description",
				"description": "Tool description",
				"type": "string",
				"$comment": "group:consumer"
			},
			"parameters": {
				"title": "Parameters",
				"description": "List of Tool parameters in the form of parameter.=",
				"type": "object",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"camelToolParameter": {
				"title": "Camel Tool Parameter",
				"description": "Tool's Camel Parameters, programmatically define Tool description and parameters",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.langchain4j.tools.spec.CamelSimpleToolParameter"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"chatModel": {
				"title": "Chat Model",
				"description": "Chat Language Model of type dev.langchain4j.model.chat.ChatLanguageModel",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:dev.langchain4j.model.chat.ChatLanguageModel"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"toolId",
			"tags"
		]
	},
	"langchain4j-web-search": {
		"properties": {
			"searchId": {
				"title": "Search Id",
				"description": "The id",
				"type": "string",
				"$comment": "group:producer"
			},
			"additionalParams": {
				"title": "Additional Params",
				"description": "The additionalParams is the additional parameters for the search request are a map of key-value pairs that represent additional parameters for the search request.",
				"type": "object",
				"$comment": "group:producer"
			},
			"geoLocation": {
				"title": "Geo Location",
				"description": "The geoLocation is the desired geolocation for search results. Each search engine may have a different set of supported geolocations.",
				"type": "string",
				"$comment": "group:producer"
			},
			"language": {
				"title": "Language",
				"description": "The language is the desired language for search results. The expected values may vary depending on the search engine.",
				"type": "string",
				"$comment": "group:producer"
			},
			"maxResults": {
				"title": "Max Results",
				"description": "The maxResults is the expected number of results to be found if the search request were made. Each search engine may have a different limit for the maximum number of results that can be returned.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "1"
			},
			"resultType": {
				"title": "Result Type",
				"description": "The resultType is the result type of the request. Valid values are LANGCHAIN4J_WEB_SEARCH_ORGANIC_RESULT, CONTENT, or SNIPPET. CONTENT is the default value; it will return a list of String . You can also specify to return either the Langchain4j Web Search Organic Result object (using LANGCHAIN4J_WEB_SEARCH_ORGANIC_RESULT) or snippet (using SNIPPET) for each result. If maxResults is equal to 1, the response will be a single object instead of a list.",
				"type": "string",
				"enum": [
					"LANGCHAIN4J_WEB_SEARCH_ORGANIC_RESULT",
					"CONTENT",
					"SNIPPET"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.langchain4j.web.search.LangChain4jWebSearchResultType",
				"default": "CONTENT"
			},
			"safeSearch": {
				"title": "Safe Search",
				"description": "The safeSearch is the safe search flag, indicating whether to enable or disable safe search.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"startIndex": {
				"title": "Start Index",
				"description": "The startIndex is the start index for search results, which may vary depending on the search engine.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"startPage": {
				"title": "Start Page",
				"description": "The startPage is the start page number for search results",
				"type": "integer",
				"$comment": "group:producer"
			},
			"webSearchEngine": {
				"title": "Web Search Engine",
				"description": "The WebSearchEngine engine to use. This is mandatory. Use one of the implementations from Langchain4j web search engines.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:dev.langchain4j.web.search.WebSearchEngine"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"webSearchRequest": {
				"title": "Web Search Request",
				"description": "The webSearchRequest is the custom WebSearchRequest - advanced",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:dev.langchain4j.web.search.WebSearchRequest"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"searchId",
			"maxResults",
			"resultType",
			"webSearchEngine"
		]
	},
	"language": {
		"properties": {
			"languageName": {
				"title": "Language Name",
				"description": "Sets the name of the language to use",
				"type": "string",
				"enum": [
					"bean",
					"constant",
					"csimple",
					"datasonnet",
					"exchangeProperty",
					"file",
					"groovy",
					"header",
					"hl7terser",
					"java",
					"joor",
					"jq",
					"jsonpath",
					"mvel",
					"ognl",
					"ref",
					"simple",
					"spel",
					"sql",
					"tokenize",
					"xpath",
					"xquery",
					"xtokenize"
				],
				"$comment": "group:producer"
			},
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource, or a reference to lookup a bean in the Registry to use as the resource",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"binary": {
				"title": "Binary",
				"description": "Whether the script is binary content or text content. By default the script is read as text content (eg java.lang.String)",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"cacheScript": {
				"title": "Cache Script",
				"description": "Whether to cache the compiled script and reuse Notice reusing the script can cause side effects from processing one Camel org.apache.camel.Exchange to the next org.apache.camel.Exchange.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"resultType": {
				"title": "Result Type",
				"description": "Sets the class of the result type (type from output)",
				"type": "string",
				"$comment": "group:producer"
			},
			"script": {
				"title": "Script",
				"description": "Sets the script to execute",
				"type": "string",
				"$comment": "group:producer"
			},
			"transform": {
				"title": "Transform",
				"description": "Whether or not the result of the script should be used as message body. This options is default true.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"languageName"
		]
	},
	"ldap": {
		"properties": {
			"dirContextName": {
				"title": "Dir Context Name",
				"description": "Name of either a javax.naming.directory.DirContext, or java.util.Hashtable, or Map bean to lookup in the registry. If the bean is either a Hashtable or Map then a new javax.naming.directory.DirContext instance is created for each use. If the bean is a javax.naming.directory.DirContext then the bean is used as given. The latter may not be possible in all situations where the javax.naming.directory.DirContext must not be shared, and in those situations it can be better to use java.util.Hashtable or Map instead.",
				"type": "string",
				"$comment": "group:producer"
			},
			"base": {
				"title": "Base",
				"description": "The base DN for searches.",
				"type": "string",
				"$comment": "group:producer",
				"default": "ou=system"
			},
			"pageSize": {
				"title": "Page Size",
				"description": "When specified the ldap module uses paging to retrieve all results (most LDAP Servers throw an exception when trying to retrieve more than 1000 entries in one query). To be able to use this a LdapContext (subclass of DirContext) has to be passed in as ldapServerBean (otherwise an exception is thrown)",
				"type": "integer",
				"$comment": "group:producer"
			},
			"returnedAttributes": {
				"title": "Returned Attributes",
				"description": "Comma-separated list of attributes that should be set in each entry of the result",
				"type": "string",
				"$comment": "group:producer"
			},
			"scope": {
				"title": "Scope",
				"description": "Specifies how deeply to search the tree of entries, starting at the base DN.",
				"type": "string",
				"enum": [
					"object",
					"onelevel",
					"subtree"
				],
				"$comment": "group:producer",
				"default": "subtree"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"dirContextName"
		]
	},
	"ldif": {
		"properties": {
			"ldapConnectionName": {
				"title": "Ldap Connection Name",
				"description": "The name of the LdapConnection bean to pull from the registry. Note that this must be of scope prototype to avoid it being shared among threads or using a connection that has timed out.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"ldapConnectionName"
		]
	},
	"log": {
		"properties": {
			"loggerName": {
				"title": "Logger Name",
				"description": "Name of the logging category to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"groupActiveOnly": {
				"title": "Group Active Only",
				"description": "If true, will hide stats when no new messages have been received for a time interval, if false, show stats regardless of message traffic.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"groupDelay": {
				"title": "Group Delay",
				"description": "Set the initial delay for stats (in millis)",
				"type": "integer",
				"$comment": "group:producer"
			},
			"groupInterval": {
				"title": "Group Interval",
				"description": "If specified will group message stats by this time interval (in millis)",
				"type": "integer",
				"$comment": "group:producer"
			},
			"groupSize": {
				"title": "Group Size",
				"description": "An integer that specifies a group size for throughput logging.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"level": {
				"title": "Level",
				"description": "Logging level to use. The default value is INFO.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:producer",
				"default": "INFO"
			},
			"logMask": {
				"title": "Log Mask",
				"description": "If true, mask sensitive information like password or passphrase in the log.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"marker": {
				"title": "Marker",
				"description": "An optional Marker name to use.",
				"type": "string",
				"$comment": "group:producer"
			},
			"plain": {
				"title": "Plain",
				"description": "If enabled only the body will be printed out",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"sourceLocationLoggerName": {
				"title": "Source Location Logger Name",
				"description": "If enabled then the source location of where the log endpoint is used in Camel routes, would be used as logger name, instead of the given name. However, if the source location is disabled or not possible to resolve then the existing logger name will be used.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"exchangeFormatter": {
				"title": "Exchange Formatter",
				"description": "To use a custom exchange formatter",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.ExchangeFormatter"
			},
			"maxChars": {
				"title": "Max Chars",
				"description": "Limits the number of characters logged per line.",
				"type": "integer",
				"$comment": "group:formatting",
				"default": 10000
			},
			"multiline": {
				"title": "Multiline",
				"description": "If enabled then each information is outputted on a newline.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showAll": {
				"title": "Show All",
				"description": "Quick option for turning all options on. (multiline, maxChars has to be manually set if to be used)",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showAllProperties": {
				"title": "Show All Properties",
				"description": "Show all of the exchange properties (both internal and custom).",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showBody": {
				"title": "Show Body",
				"description": "Show the message body.",
				"type": "boolean",
				"$comment": "group:formatting",
				"default": true
			},
			"showBodyType": {
				"title": "Show Body Type",
				"description": "Show the body Java type.",
				"type": "boolean",
				"$comment": "group:formatting",
				"default": true
			},
			"showCachedStreams": {
				"title": "Show Cached Streams",
				"description": "Whether Camel should show cached stream bodies or not (org.apache.camel.StreamCache).",
				"type": "boolean",
				"$comment": "group:formatting",
				"default": true
			},
			"showCaughtException": {
				"title": "Show Caught Exception",
				"description": "If the exchange has a caught exception, show the exception message (no stack trace). A caught exception is stored as a property on the exchange (using the key org.apache.camel.Exchange#EXCEPTION_CAUGHT) and for instance a doCatch can catch exceptions.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showException": {
				"title": "Show Exception",
				"description": "If the exchange has an exception, show the exception message (no stacktrace)",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showExchangeId": {
				"title": "Show Exchange Id",
				"description": "Show the unique exchange ID.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showExchangePattern": {
				"title": "Show Exchange Pattern",
				"description": "Shows the Message Exchange Pattern (or MEP for short).",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showFiles": {
				"title": "Show Files",
				"description": "If enabled Camel will output files",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showFuture": {
				"title": "Show Future",
				"description": "If enabled Camel will on Future objects wait for it to complete to obtain the payload to be logged.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showHeaders": {
				"title": "Show Headers",
				"description": "Show the message headers.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showProperties": {
				"title": "Show Properties",
				"description": "Show the exchange properties (only custom). Use showAllProperties to show both internal and custom properties.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showRouteGroup": {
				"title": "Show Route Group",
				"description": "Show route Group.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showRouteId": {
				"title": "Show Route Id",
				"description": "Show route ID.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showStackTrace": {
				"title": "Show Stack Trace",
				"description": "Show the stack trace, if an exchange has an exception. Only effective if one of showAll, showException or showCaughtException are enabled.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showStreams": {
				"title": "Show Streams",
				"description": "Whether Camel should show stream bodies or not (eg such as java.io.InputStream). Beware if you enable this option then you may not be able later to access the message body as the stream have already been read by this logger. To remedy this you will have to use Stream Caching.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"showVariables": {
				"title": "Show Variables",
				"description": "Show the variables.",
				"type": "boolean",
				"$comment": "group:formatting"
			},
			"skipBodyLineSeparator": {
				"title": "Skip Body Line Separator",
				"description": "Whether to skip line separators when logging the message body. This allows to log the message body in one line, setting this option to false will preserve any line separators from the body, which then will log the body as is.",
				"type": "boolean",
				"$comment": "group:formatting",
				"default": true
			},
			"style": {
				"title": "Style",
				"description": "Sets the outputs style to use.",
				"type": "string",
				"enum": [
					"Default",
					"Tab",
					"Fixed"
				],
				"$comment": "group:formatting",
				"format": "bean:org.apache.camel.support.processor.DefaultExchangeFormatter.OutputStyle",
				"default": "Default"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"loggerName"
		]
	},
	"lpr": {
		"properties": {
			"hostname": {
				"title": "Hostname",
				"description": "Hostname of the printer",
				"type": "string",
				"$comment": "group:producer"
			},
			"port": {
				"title": "Port",
				"description": "Port number of the printer",
				"type": "integer",
				"$comment": "group:producer"
			},
			"printername": {
				"title": "Printername",
				"description": "Name of the printer",
				"type": "string",
				"$comment": "group:producer"
			},
			"copies": {
				"title": "Copies",
				"description": "Number of copies to print",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"docFlavor": {
				"title": "Doc Flavor",
				"description": "Sets DocFlavor to use.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:javax.print.DocFlavor"
			},
			"flavor": {
				"title": "Flavor",
				"description": "Sets DocFlavor to use.",
				"type": "string",
				"$comment": "group:producer"
			},
			"mediaSize": {
				"title": "Media Size",
				"description": "Sets the stationary as defined by enumeration names in the javax.print.attribute.standard.MediaSizeName API. The default setting is to use North American Letter sized stationary. The value's case is ignored, e.g. values of iso_a4 and ISO_A4 may be used.",
				"type": "string",
				"$comment": "group:producer",
				"default": "na-letter"
			},
			"mediaTray": {
				"title": "Media Tray",
				"description": "Sets MediaTray supported by the javax.print.DocFlavor API, for example upper,middle etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"mimeType": {
				"title": "Mime Type",
				"description": "Sets mimeTypes supported by the javax.print.DocFlavor API",
				"type": "string",
				"$comment": "group:producer"
			},
			"orientation": {
				"title": "Orientation",
				"description": "Sets the page orientation.",
				"type": "string",
				"enum": [
					"portrait",
					"landscape",
					"reverse-portrait",
					"reverse-landscape"
				],
				"$comment": "group:producer",
				"default": "portrait"
			},
			"printerPrefix": {
				"title": "Printer Prefix",
				"description": "Sets the prefix name of the printer, it is useful when the printer name does not start with //hostname/printer",
				"type": "string",
				"$comment": "group:producer"
			},
			"sendToPrinter": {
				"title": "Send To Printer",
				"description": "etting this option to false prevents sending of the print data to the printer",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"sides": {
				"title": "Sides",
				"description": "Sets one sided or two sided printing based on the javax.print.attribute.standard.Sides API",
				"type": "string",
				"enum": [
					"one-sided",
					"duplex",
					"tumble",
					"two-sided-short-edge",
					"two-sided-long-edge"
				],
				"$comment": "group:producer",
				"default": "one-sided"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"hostname"
		]
	},
	"lucene": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The URL to the lucene server",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Operation to do such as insert or query.",
				"type": "string",
				"enum": [
					"insert",
					"query"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.lucene.LuceneOperation"
			},
			"analyzer": {
				"title": "Analyzer",
				"description": "An Analyzer builds TokenStreams, which analyze text. It thus represents a policy for extracting index terms from text. The value for analyzer can be any class that extends the abstract class org.apache.lucene.analysis.Analyzer. Lucene also offers a rich set of analyzers out of the box",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.lucene.analysis.Analyzer"
			},
			"indexDir": {
				"title": "Index Dir",
				"description": "A file system directory in which index files are created upon analysis of the document by the specified analyzer",
				"type": "string",
				"$comment": "group:producer"
			},
			"maxHits": {
				"title": "Max Hits",
				"description": "An integer value that limits the result set of the search operation",
				"type": "integer",
				"$comment": "group:producer"
			},
			"srcDir": {
				"title": "Src Dir",
				"description": "An optional directory containing files to be used to be analyzed and added to the index at producer startup.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"operation"
		]
	},
	"lumberjack": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Network interface on which to listen for Lumberjack",
				"type": "string",
				"$comment": "group:consumer"
			},
			"port": {
				"title": "Port",
				"description": "Network port on which to listen for Lumberjack",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 5044
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "SSL configuration",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"mapstruct": {
		"properties": {
			"className": {
				"title": "Class Name",
				"description": "The fully qualified class name of the POJO that mapstruct should convert to (target)",
				"type": "string",
				"$comment": "group:producer"
			},
			"mandatory": {
				"title": "Mandatory",
				"description": "Whether there must exist a mapstruct converter to convert to the POJO.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"className"
		]
	},
	"master": {
		"properties": {
			"namespace": {
				"title": "Namespace",
				"description": "The name of the cluster namespace to use",
				"type": "string",
				"$comment": "group:consumer"
			},
			"delegateUri": {
				"title": "Delegate Uri",
				"description": "The endpoint uri to use in master/slave mode",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"namespace",
			"delegateUri"
		]
	},
	"metrics": {
		"properties": {
			"metricsType": {
				"title": "Metrics Type",
				"description": "Type of metrics",
				"type": "string",
				"enum": [
					"gauge",
					"counter",
					"histogram",
					"meter",
					"timer"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.metrics.MetricsType"
			},
			"metricsName": {
				"title": "Metrics Name",
				"description": "Name of metrics",
				"type": "string",
				"$comment": "group:producer"
			},
			"action": {
				"title": "Action",
				"description": "Action when using timer type",
				"type": "string",
				"enum": [
					"start",
					"stop"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.metrics.MetricsTimerAction"
			},
			"decrement": {
				"title": "Decrement",
				"description": "Decrement value when using counter type",
				"type": "integer",
				"$comment": "group:producer"
			},
			"increment": {
				"title": "Increment",
				"description": "Increment value when using counter type",
				"type": "integer",
				"$comment": "group:producer"
			},
			"mark": {
				"title": "Mark",
				"description": "Mark when using meter type",
				"type": "integer",
				"$comment": "group:producer"
			},
			"subject": {
				"title": "Subject",
				"description": "Subject value when using gauge type",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"value": {
				"title": "Value",
				"description": "Value value when using histogram type",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"metricsType",
			"metricsName"
		]
	},
	"micrometer": {
		"properties": {
			"metricsType": {
				"title": "Metrics Type",
				"description": "Type of metrics",
				"type": "string",
				"enum": [
					"counter",
					"summary",
					"timer"
				],
				"$comment": "group:producer",
				"format": "bean:io.micrometer.core.instrument.Meter.Type"
			},
			"metricsName": {
				"title": "Metrics Name",
				"description": "Name of metrics",
				"type": "string",
				"$comment": "group:producer"
			},
			"tags": {
				"title": "Tags",
				"description": "Tags of metrics",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Iterable<io.micrometer.core.instrument.Tag>"
			},
			"action": {
				"title": "Action",
				"description": "Action expression when using timer type",
				"type": "string",
				"enum": [
					"start",
					"stop"
				],
				"$comment": "group:producer"
			},
			"decrement": {
				"title": "Decrement",
				"description": "Decrement value expression when using counter type",
				"type": "string",
				"$comment": "group:producer"
			},
			"increment": {
				"title": "Increment",
				"description": "Increment value expression when using counter type",
				"type": "string",
				"$comment": "group:producer"
			},
			"metricsDescription": {
				"title": "Metrics Description",
				"description": "Description of metrics",
				"type": "string",
				"$comment": "group:producer"
			},
			"value": {
				"title": "Value",
				"description": "Value expression when using histogram type",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"metricsType",
			"metricsName"
		]
	},
	"milvus": {
		"properties": {
			"collection": {
				"title": "Collection",
				"description": "The collection Name",
				"type": "string",
				"$comment": "group:producer"
			},
			"host": {
				"title": "Host",
				"description": "The host to connect to.",
				"type": "string",
				"$comment": "group:producer",
				"default": "localhost"
			},
			"port": {
				"title": "Port",
				"description": "The port to connect to.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 19530
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets a default timeout for all requests",
				"type": "integer",
				"$comment": "group:producer"
			},
			"token": {
				"title": "Token",
				"description": "Sets the API key to use for authentication",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"collection"
		]
	},
	"mina": {
		"properties": {
			"protocol": {
				"title": "Protocol",
				"description": "Protocol to use",
				"type": "string",
				"$comment": "group:common"
			},
			"host": {
				"title": "Host",
				"description": "Hostname to use. Use localhost or 0.0.0.0 for local server as consumer. For producer use the hostname or ip address of the remote server.",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port number",
				"type": "integer",
				"$comment": "group:common"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether to disconnect(close) from Mina session right after use. Can be used for both consumer and producer.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"minaLogger": {
				"title": "Mina Logger",
				"description": "You can enable the Apache MINA logging filter. Apache MINA uses slf4j logging at INFO level to log all input and output.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"sync": {
				"title": "Sync",
				"description": "Setting to set endpoint as one-way or request-response.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"timeout": {
				"title": "Timeout",
				"description": "You can configure the timeout that specifies how long to wait for a response from a remote server. The timeout unit is in milliseconds, so 60000 is 60 seconds.",
				"type": "integer",
				"$comment": "group:common",
				"default": 30000
			},
			"writeTimeout": {
				"title": "Write Timeout",
				"description": "Maximum amount of time it should take to send data to the MINA session. Default is 10000 milliseconds.",
				"type": "integer",
				"$comment": "group:common",
				"default": 10000
			},
			"clientMode": {
				"title": "Client Mode",
				"description": "If the clientMode is true, mina consumer will connect the address as a TCP client.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"noReplyLogLevel": {
				"title": "No Reply Log Level",
				"description": "If sync is enabled this option dictates MinaConsumer which logging level to use when logging a there is no reply to send back.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"cachedAddress": {
				"title": "Cached Address",
				"description": "Whether to create the InetAddress once and reuse. Setting this to false allows to pickup DNS changes in the network.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"lazySessionCreation": {
				"title": "Lazy Session Creation",
				"description": "Sessions can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"disconnectOnNoReply": {
				"title": "Disconnect On No Reply",
				"description": "If sync is enabled then this option dictates MinaConsumer if it should disconnect where there is no reply to send back.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"maximumPoolSize": {
				"title": "Maximum Pool Size",
				"description": "Number of worker threads in the worker pool for TCP and UDP",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 16
			},
			"orderedThreadPoolExecutor": {
				"title": "Ordered Thread Pool Executor",
				"description": "Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"transferExchange": {
				"title": "Transfer Exchange",
				"description": "Only used for TCP. You can transfer the exchange over the wire instead of just the body. The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level. Also make sure to configure objectCodecPattern to (star) to allow transferring java objects.",
				"type": "boolean",
				"$comment": "group:advanced",
				"deprecated": true
			},
			"allowDefaultCodec": {
				"title": "Allow Default Codec",
				"description": "The mina component installs a default codec if both, codec is null and textline is false. Setting allowDefaultCodec to false prevents the mina component from installing a default codec as the first element in the filter chain. This is useful in scenarios where another filter must be the first in the filter chain, like the SSL filter.",
				"type": "boolean",
				"$comment": "group:codec",
				"default": true
			},
			"codec": {
				"title": "Codec",
				"description": "To use a custom minda codec implementation.",
				"type": "string",
				"$comment": "group:codec",
				"format": "bean:org.apache.mina.filter.codec.ProtocolCodecFactory"
			},
			"decoderMaxLineLength": {
				"title": "Decoder Max Line Length",
				"description": "To set the textline protocol decoder max line length. By default the default value of Mina itself is used which are 1024.",
				"type": "integer",
				"$comment": "group:codec",
				"default": 1024
			},
			"encoderMaxLineLength": {
				"title": "Encoder Max Line Length",
				"description": "To set the textline protocol encoder max line length. By default the default value of Mina itself is used which are Integer.MAX_VALUE.",
				"type": "integer",
				"$comment": "group:codec",
				"default": -1
			},
			"encoding": {
				"title": "Encoding",
				"description": "You can configure the encoding (a charset name) to use for the TCP textline codec and the UDP protocol. If not provided, Camel will use the JVM default Charset",
				"type": "string",
				"$comment": "group:codec"
			},
			"filters": {
				"title": "Filters",
				"description": "You can set a list of Mina IoFilters to use.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:codec"
			},
			"objectCodecPattern": {
				"title": "Object Codec Pattern",
				"description": "Accept the wildcard specified classes for Object deserialization, unless they are otherwise rejected. Multiple patterns can be separated by comma.",
				"type": "string",
				"$comment": "group:codec"
			},
			"textline": {
				"title": "Textline",
				"description": "Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec; if not specified or the value is false, then Object Serialization is assumed over TCP.",
				"type": "boolean",
				"$comment": "group:codec"
			},
			"textlineDelimiter": {
				"title": "Textline Delimiter",
				"description": "Only used for TCP and if textline=true. Sets the text line delimiter to use. If none provided, Camel will use DEFAULT. This delimiter is used to mark the end of text.",
				"type": "string",
				"enum": [
					"DEFAULT",
					"AUTO",
					"UNIX",
					"WINDOWS",
					"MAC"
				],
				"$comment": "group:codec",
				"format": "bean:org.apache.camel.component.mina.MinaTextLineDelimiter"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure SSL security.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"protocol",
			"host",
			"port"
		]
	},
	"minio": {
		"properties": {
			"bucketName": {
				"title": "Bucket Name",
				"description": "Bucket name",
				"type": "string",
				"$comment": "group:common"
			},
			"autoCreateBucket": {
				"title": "Auto Create Bucket",
				"description": "Setting the autocreation of the bucket if bucket name not exist.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"endpoint": {
				"title": "Endpoint",
				"description": "Endpoint can be an URL, domain name, IPv4 address or IPv6 address.",
				"type": "string",
				"$comment": "group:common"
			},
			"minioClient": {
				"title": "Minio Client",
				"description": "Reference to a Minio Client object in the registry.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.minio.MinioClient"
			},
			"objectLock": {
				"title": "Object Lock",
				"description": "Set when creating new bucket.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"policy": {
				"title": "Policy",
				"description": "The policy for this queue to set in the method.",
				"type": "string",
				"$comment": "group:common"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "TCP/IP port number. 80 and 443 are used as defaults for HTTP and HTTPS.",
				"type": "integer",
				"$comment": "group:common"
			},
			"region": {
				"title": "Region",
				"description": "The region in which Minio client needs to work. When using this parameter, the configuration will expect the lowercase name of the region (for example ap-east-1). You'll need to use the name Region.EU_WEST_1.id()",
				"type": "string",
				"$comment": "group:common"
			},
			"secure": {
				"title": "Secure",
				"description": "Flag to indicate to use secure connection to minio service or not.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"autoCloseBody": {
				"title": "Auto Close Body",
				"description": "If this option is true and includeBody is true, then the MinioObject.close() method will be called on exchange completion. This option is strongly related to includeBody option. In case of setting includeBody to true and autocloseBody to false, it will be up to the caller to close the MinioObject stream. Setting autocloseBody to true, will close the MinioObject stream automatically.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bypassGovernanceMode": {
				"title": "Bypass Governance Mode",
				"description": "Set this flag if you want to bypassGovernanceMode when deleting a particular object.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"deleteAfterRead": {
				"title": "Delete After Read",
				"description": "Delete objects from Minio after they have been retrieved. The delete is only performed if the Exchange is committed. If a rollback occurs, the object is not deleted. If this option is false, then the same objects will be retrieve over and over again on the polls. Therefore you need to use the Idempotent Consumer EIP in the route to filter out duplicates. You can filter using the MinioConstants#BUCKET_NAME and MinioConstants#OBJECT_NAME headers, or only the MinioConstants#OBJECT_NAME header.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"delimiter": {
				"title": "Delimiter",
				"description": "The delimiter which is used in the ListObjectsRequest to only consume objects we are interested in.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"destinationBucketName": {
				"title": "Destination Bucket Name",
				"description": "Destination bucket name.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"destinationObjectName": {
				"title": "Destination Object Name",
				"description": "Destination object name.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"includeBody": {
				"title": "Include Body",
				"description": "If it is true, the exchange body will be set to a stream to the contents of the file. If false, the headers will be set with the Minio object metadata, but the body will be null. This option is strongly related to autocloseBody option. In case of setting includeBody to true and autocloseBody to false, it will be up to the caller to close the MinioObject stream. Setting autocloseBody to true, will close the MinioObject stream automatically.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"includeFolders": {
				"title": "Include Folders",
				"description": "The flag which is used in the ListObjectsRequest to set include folders.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"includeUserMetadata": {
				"title": "Include User Metadata",
				"description": "The flag which is used in the ListObjectsRequest to get objects with user meta data.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"includeVersions": {
				"title": "Include Versions",
				"description": "The flag which is used in the ListObjectsRequest to get objects with versioning.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"length": {
				"title": "Length",
				"description": "Number of bytes of object data from offset.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"matchETag": {
				"title": "Match ETag",
				"description": "Set match ETag parameter for get object(s).",
				"type": "string",
				"$comment": "group:consumer"
			},
			"maxConnections": {
				"title": "Max Connections",
				"description": "Set the maxConnections parameter in the minio client configuration",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 60
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Gets the maximum number of messages as a limit to poll at each polling. Gets the maximum number of messages as a limit to poll at each polling. The default value is 10. Use 0 or a negative number to set it as unlimited.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"modifiedSince": {
				"title": "Modified Since",
				"description": "Set modified since parameter for get object(s).",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:java.time.ZonedDateTime"
			},
			"moveAfterRead": {
				"title": "Move After Read",
				"description": "Move objects from bucket to a different bucket after they have been retrieved. To accomplish the operation the destinationBucket option must be set. The copy bucket operation is only performed if the Exchange is committed. If a rollback occurs, the object is not moved.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"notMatchETag": {
				"title": "Not Match ETag",
				"description": "Set not match ETag parameter for get object(s).",
				"type": "string",
				"$comment": "group:consumer"
			},
			"objectName": {
				"title": "Object Name",
				"description": "To get the object from the bucket with the given object name.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"offset": {
				"title": "Offset",
				"description": "Start byte position of object data.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"prefix": {
				"title": "Prefix",
				"description": "Object name starts with prefix.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"recursive": {
				"title": "Recursive",
				"description": "List recursively than directory structure emulation.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"startAfter": {
				"title": "Start After",
				"description": "list objects in bucket after this object name.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"unModifiedSince": {
				"title": "Un Modified Since",
				"description": "Set un modified since parameter for get object(s).",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:java.time.ZonedDateTime"
			},
			"useVersion1": {
				"title": "Use Version1",
				"description": "when true, version 1 of REST API is used.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"versionId": {
				"title": "Version Id",
				"description": "Set specific version_ID of a object when deleting the object.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"deleteAfterWrite": {
				"title": "Delete After Write",
				"description": "Delete file object after the Minio file has been uploaded.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"keyName": {
				"title": "Key Name",
				"description": "Setting the key name for an element in the bucket through endpoint parameter.",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do in case the user don't want to do only an upload.",
				"type": "string",
				"enum": [
					"copyObject",
					"listObjects",
					"deleteObject",
					"deleteObjects",
					"deleteBucket",
					"listBuckets",
					"getObject",
					"getObjectRange",
					"createDownloadLink",
					"createUploadLink"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.minio.MinioOperations"
			},
			"pojoRequest": {
				"title": "Pojo Request",
				"description": "If we want to use a POJO request as body or not.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"storageClass": {
				"title": "Storage Class",
				"description": "The storage class to set in the request.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"customHttpClient": {
				"title": "Custom Http Client",
				"description": "Set custom HTTP client for authenticated access.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:okhttp3.OkHttpClient"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Amazon AWS Secret Access Key or Minio Access Key. If not set camel will connect to service for anonymous access.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Amazon AWS Access Key Id or Minio Secret Key. If not set camel will connect to service for anonymous access.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"serverSideEncryption": {
				"title": "Server Side Encryption",
				"description": "Server-side encryption.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:io.minio.ServerSideEncryption"
			},
			"serverSideEncryptionCustomerKey": {
				"title": "Server Side Encryption Customer Key",
				"description": "Server-side encryption for source object while copy/move objects.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:io.minio.ServerSideEncryptionCustomerKey"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"bucketName"
		]
	},
	"mllp": {
		"properties": {
			"hostname": {
				"title": "Hostname",
				"description": "Hostname or IP for connection for the TCP connection. The default value is null, which means any local IP address",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port number for the TCP connection",
				"type": "integer",
				"$comment": "group:common"
			},
			"autoAck": {
				"title": "Auto Ack",
				"description": "Enable/Disable the automatic generation of a MLLP Acknowledgement MLLP Consumers only",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"charsetName": {
				"title": "Charset Name",
				"description": "Sets the default charset to use",
				"type": "string",
				"$comment": "group:common"
			},
			"hl7Headers": {
				"title": "Hl7 Headers",
				"description": "Enable/Disable the automatic generation of message headers from the HL7 Message MLLP Consumers only",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"requireEndOfData": {
				"title": "Require End Of Data",
				"description": "Enable/Disable strict compliance to the MLLP standard. The MLLP standard specifies START_OF_BLOCKhl7 payloadEND_OF_BLOCKEND_OF_DATA, however, some systems do not send the final END_OF_DATA byte. This setting controls whether or not the final END_OF_DATA byte is required or optional.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"stringPayload": {
				"title": "String Payload",
				"description": "Enable/Disable converting the payload to a String. If enabled, HL7 Payloads received from external systems will be validated converted to a String. If the charsetName property is set, that character set will be used for the conversion. If the charsetName property is not set, the value of MSH-18 will be used to determine th appropriate character set. If MSH-18 is not set, then the default ISO-8859-1 character set will be use.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"validatePayload": {
				"title": "Validate Payload",
				"description": "Enable/Disable the validation of HL7 Payloads If enabled, HL7 Payloads received from external systems will be validated (see Hl7Util.generateInvalidPayloadExceptionMessage for details on the validation). If and invalid payload is detected, a MllpInvalidMessageException (for consumers) or a MllpInvalidAcknowledgementException will be thrown.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"acceptTimeout": {
				"title": "Accept Timeout",
				"description": "Timeout (in milliseconds) while waiting for a TCP connection TCP Server Only",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 60000
			},
			"backlog": {
				"title": "Backlog",
				"description": "The maximum queue length for incoming connection indications (a request to connect) is set to the backlog parameter. If a connection indication arrives when the queue is full, the connection is refused.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "5"
			},
			"bindRetryInterval": {
				"title": "Bind Retry Interval",
				"description": "TCP Server Only - The number of milliseconds to wait between bind attempts",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 5000
			},
			"bindTimeout": {
				"title": "Bind Timeout",
				"description": "TCP Server Only - The number of milliseconds to retry binding to a server port",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 30000
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions occurred while the consumer is trying to receive incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. If disabled, the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions by logging them at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"lenientBind": {
				"title": "Lenient Bind",
				"description": "TCP Server Only - Allow the endpoint to start before the TCP ServerSocket is bound. In some environments, it may be desirable to allow the endpoint to start before the TCP ServerSocket is bound.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maxConcurrentConsumers": {
				"title": "Max Concurrent Consumers",
				"description": "The maximum number of concurrent MLLP Consumer connections that will be allowed. If a new connection is received and the maximum is number are already established, the new connection will be reset immediately.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 5
			},
			"reuseAddress": {
				"title": "Reuse Address",
				"description": "Enable/disable the SO_REUSEADDR socket option.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern",
				"default": "InOut"
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Timeout (in milliseconds) for establishing for a TCP connection TCP Client only",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"idleTimeoutStrategy": {
				"title": "Idle Timeout Strategy",
				"description": "decide what action to take when idle timeout occurs. Possible values are : RESET: set SO_LINGER to 0 and reset the socket CLOSE: close the socket gracefully default is RESET.",
				"type": "string",
				"enum": [
					"RESET",
					"CLOSE"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.mllp.MllpIdleTimeoutStrategy",
				"default": "RESET"
			},
			"keepAlive": {
				"title": "Keep Alive",
				"description": "Enable/disable the SO_KEEPALIVE socket option.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"tcpNoDelay": {
				"title": "Tcp No Delay",
				"description": "Enable/disable the TCP_NODELAY socket option.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"maxBufferSize": {
				"title": "Max Buffer Size",
				"description": "Maximum buffer size used when receiving or sending data over the wire.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1073741824
			},
			"minBufferSize": {
				"title": "Min Buffer Size",
				"description": "Minimum buffer size used when receiving or sending data over the wire.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 2048
			},
			"readTimeout": {
				"title": "Read Timeout",
				"description": "The SO_TIMEOUT value (in milliseconds) used after the start of an MLLP frame has been received",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 5000
			},
			"receiveBufferSize": {
				"title": "Receive Buffer Size",
				"description": "Sets the SO_RCVBUF option to the specified value (in bytes)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "8192"
			},
			"receiveTimeout": {
				"title": "Receive Timeout",
				"description": "The SO_TIMEOUT value (in milliseconds) used when waiting for the start of an MLLP frame",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 15000
			},
			"sendBufferSize": {
				"title": "Send Buffer Size",
				"description": "Sets the SO_SNDBUF option to the specified value (in bytes)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "8192"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "Sets the SSLContextParameters for securing TCP connections. If set, the MLLP component will use SSL/TLS for securing both producer and consumer TCP connections. This allows the configuration of trust stores, key stores, protocols, and other SSL/TLS settings. If not set, the MLLP component will use plain TCP communication.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"idleTimeout": {
				"title": "Idle Timeout",
				"description": "The approximate idle time allowed before the Client TCP Connection will be reset. A null value or a value less than or equal to zero will disable the idle timeout.",
				"type": "integer",
				"$comment": "group:tcp"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"hostname",
			"port"
		]
	},
	"mock": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of mock endpoint",
				"type": "string",
				"$comment": "group:producer"
			},
			"assertPeriod": {
				"title": "Assert Period",
				"description": "Sets a grace period after which the mock endpoint will re-assert to ensure the preliminary assertion is still valid. This is used, for example, to assert that exactly a number of messages arrive. For example, if the expected count was set to 5, then the assertion is satisfied when five or more messages arrive. To ensure that exactly 5 messages arrive, then you would need to wait a little period to ensure no further message arrives. This is what you can use this method for. By default, this period is disabled.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"expectedCount": {
				"title": "Expected Count",
				"description": "Specifies the expected number of message exchanges that should be received by this endpoint. Beware: If you want to expect that 0 messages, then take extra care, as 0 matches when the tests starts, so you need to set a assert period time to let the test run for a while to make sure there are still no messages arrived; for that use setAssertPeriod(long). An alternative is to use NotifyBuilder, and use the notifier to know when Camel is done routing some messages, before you call the assertIsSatisfied() method on the mocks. This allows you to not use a fixed assert period, to speedup testing times. If you want to assert that exactly nth message arrives to this mock endpoint, then see also the setAssertPeriod(long) method for further details.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"failFast": {
				"title": "Fail Fast",
				"description": "Sets whether assertIsSatisfied() should fail fast at the first detected failed expectation while it may otherwise wait for all expected messages to arrive before performing expectations verifications. Is by default true. Set to false to use behavior as in Camel 2.x.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"log": {
				"title": "Log",
				"description": "To turn on logging when the mock receives an incoming message. This will log only one time at INFO level for the incoming message. For more detailed logging then set the logger to DEBUG level for the org.apache.camel.component.mock.MockEndpoint class.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"reportGroup": {
				"title": "Report Group",
				"description": "A number that is used to turn on throughput logging based on groups of the size.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"resultMinimumWaitTime": {
				"title": "Result Minimum Wait Time",
				"description": "Sets the minimum expected amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"resultWaitTime": {
				"title": "Result Wait Time",
				"description": "Sets the maximum amount of time (in millis) the assertIsSatisfied() will wait on a latch until it is satisfied",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"retainFirst": {
				"title": "Retain First",
				"description": "Specifies to only retain the first nth number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the first 10 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the first 10 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"retainLast": {
				"title": "Retain Last",
				"description": "Specifies to only retain the last nth number of received Exchanges. This is used when testing with big data, to reduce memory consumption by not storing copies of every Exchange this mock endpoint receives. Important: When using this limitation, then the getReceivedCounter() will still return the actual number of received Exchanges. For example if we have received 5000 Exchanges, and have configured to only retain the last 20 Exchanges, then the getReceivedCounter() will still return 5000 but there is only the last 20 Exchanges in the getExchanges() and getReceivedExchanges() methods. When using this method, then some of the other expectation methods is not supported, for example the expectedBodiesReceived(Object...) sets a expectation on the first number of bodies received. You can configure both setRetainFirst(int) and setRetainLast(int) methods, to limit both the first and last received.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"sleepForEmptyTest": {
				"title": "Sleep For Empty Test",
				"description": "Allows a sleep to be specified to wait to check that this endpoint really is empty when expectedMessageCount(int) is called with zero",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"copyOnExchange": {
				"title": "Copy On Exchange",
				"description": "Sets whether to make a deep copy of the incoming Exchange when received at this mock endpoint. Is by default true.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"mongodb": {
		"properties": {
			"connectionBean": {
				"title": "Connection Bean",
				"description": "Sets the connection bean reference used to lookup a client for connecting to a database if no hosts parameter is present.",
				"type": "string",
				"$comment": "group:common"
			},
			"collection": {
				"title": "Collection",
				"description": "Sets the name of the MongoDB collection to bind to this endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"collectionIndex": {
				"title": "Collection Index",
				"description": "Sets the collection index (JSON FORMAT : { field1 : order1, field2 : order2})",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionUriString": {
				"title": "Connection Uri String",
				"description": "Set the whole Connection String/Uri for mongodb endpoint.",
				"type": "string",
				"$comment": "group:common"
			},
			"createCollection": {
				"title": "Create Collection",
				"description": "Create the collection during initialisation if it doesn't exist. Default is true.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"database": {
				"title": "Database",
				"description": "Sets the name of the MongoDB database to target",
				"type": "string",
				"$comment": "group:common"
			},
			"hosts": {
				"title": "Hosts",
				"description": "Host address of mongodb server in host:port format. It's possible to also use more than one address, as a comma separated list of hosts: host1:port1,host2:port2. If this parameter is specified, the provided connectionBean is ignored.",
				"type": "string",
				"$comment": "group:common"
			},
			"mongoConnection": {
				"title": "Mongo Connection",
				"description": "Sets the connection bean used as a client for connecting to a database.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.mongodb.client.MongoClient"
			},
			"operation": {
				"title": "Operation",
				"description": "Sets the operation this endpoint will execute against MongoDB.",
				"type": "string",
				"enum": [
					"findById",
					"findOneAndDelete",
					"findOneAndReplace",
					"findOneAndUpdate",
					"findOneByQuery",
					"findAll",
					"findDistinct",
					"insert",
					"save",
					"update",
					"remove",
					"bulkWrite",
					"aggregate",
					"getDbStats",
					"getColStats",
					"count",
					"command"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.mongodb.MongoDbOperation"
			},
			"outputType": {
				"title": "Output Type",
				"description": "Convert the output of the producer to the selected type: DocumentList Document or MongoIterable. DocumentList or MongoIterable applies to findAll and aggregate. Document applies to all other operations.",
				"type": "string",
				"enum": [
					"DocumentList",
					"Document",
					"MongoIterable"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.mongodb.MongoDbOutputType"
			},
			"consumerType": {
				"title": "Consumer Type",
				"description": "Consumer type.",
				"type": "string",
				"enum": [
					"tailable",
					"changeStreams"
				],
				"$comment": "group:consumer",
				"default": "tailable"
			},
			"fullDocument": {
				"title": "Full Document",
				"description": "Specifies whether changeStream consumer include a copy of the full document when modified by update operations. Possible values are default, updateLookup, required and whenAvailable.",
				"type": "string",
				"enum": [
					"default",
					"updateLookup",
					"required",
					"whenAvailable"
				],
				"$comment": "group:consumer",
				"format": "bean:com.mongodb.client.model.changestream.FullDocument",
				"default": "default"
			},
			"persistentId": {
				"title": "Persistent Id",
				"description": "One tail tracking collection can host many trackers for several tailable consumers. To keep them separate, each tracker should have its own unique persistentId.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"persistentTailTracking": {
				"title": "Persistent Tail Tracking",
				"description": "Enable persistent tail tracking, which is a mechanism to keep track of the last consumed message across system restarts. The next time the system is up, the endpoint will recover the cursor from the point where it last stopped slurping records.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"tailTrackCollection": {
				"title": "Tail Track Collection",
				"description": "Collection where tail tracking information will be persisted. If not specified, MongoDbTailTrackingConfig#DEFAULT_COLLECTION will be used by default.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"tailTrackDb": {
				"title": "Tail Track Db",
				"description": "Indicates what database the tail tracking mechanism will persist to. If not specified, the current database will be picked by default. Dynamicity will not be taken into account even if enabled, i.e., the tail tracking database will not vary past endpoint initialization.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"tailTrackField": {
				"title": "Tail Track Field",
				"description": "Field where the last tracked value will be placed. If not specified, MongoDbTailTrackingConfig#DEFAULT_FIELD will be used by default.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"tailTrackIncreasingField": {
				"title": "Tail Track Increasing Field",
				"description": "Correlation field in the incoming record which is of increasing nature and will be used to position the tailing cursor every time it is generated. The cursor will be (re)created with a query of type: tailTrackIncreasingField greater than lastValue (possibly recovered from persistent tail tracking). Can be of type Integer, Date, String, etc. NOTE: No support for dot notation at the current time, so the field should be at the top level of the document.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"appName": {
				"title": "App Name",
				"description": "Sets the logical name of the application. The application name may be used by the client to identify the application to the server, for use in server logs, slow query logs, and profile collection. Default: null",
				"type": "string",
				"$comment": "group:advanced"
			},
			"compressors": {
				"title": "Compressors",
				"description": "Specifies one or more compression algorithms that the driver will attempt to use to compress requests sent to the connected MongoDB instance. Possible values include: zlib, snappy, and zstd. Default: null",
				"type": "string",
				"$comment": "group:advanced"
			},
			"connectTimeoutMS": {
				"title": "Connect Timeout MS",
				"description": "Specifies the maximum amount of time, in milliseconds, the Java driver waits for a connection to open before timing out. A value of 0 instructs the driver to never time out while waiting for a connection to open. Default: 10000 (10 seconds)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "10000"
			},
			"cursorRegenerationDelay": {
				"title": "Cursor Regeneration Delay",
				"description": "MongoDB tailable cursors will block until new data arrives. If no new data is inserted, after some time the cursor will be automatically freed and closed by the MongoDB server. The client is expected to regenerate the cursor if needed. This value specifies the time to wait before attempting to fetch a new cursor, and if the attempt fails, how long before the next attempt is made. Default value is 1000ms.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"directConnection": {
				"title": "Direct Connection",
				"description": "Specifies that the driver must connect to the host directly. Default: false",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"dynamicity": {
				"title": "Dynamicity",
				"description": "Sets whether this endpoint will attempt to dynamically resolve the target database and collection from the incoming Exchange properties. Can be used to override at runtime the database and collection specified on the otherwise static endpoint URI. It is disabled by default to boost performance. Enabling it will take a minimal performance hit.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"heartbeatFrequencyMS": {
				"title": "Heartbeat Frequency MS",
				"description": "heartbeatFrequencyMS controls when the driver checks the state of the MongoDB deployment. Specify the interval (in milliseconds) between checks, counted from the end of the previous check until the beginning of the next one. Default: Single-threaded drivers: 60 seconds. Multithreaded drivers: 10 seconds.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"loadBalanced": {
				"title": "Load Balanced",
				"description": "If true the driver will assume that it's connecting to MongoDB through a load balancer.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"localThresholdMS": {
				"title": "Local Threshold MS",
				"description": "The size (in milliseconds) of the latency window for selecting among multiple suitable MongoDB instances. Default: 15 milliseconds.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "15"
			},
			"maxConnecting": {
				"title": "Max Connecting",
				"description": "Specifies the maximum number of connections a pool may be establishing concurrently. Default: 2",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "2"
			},
			"maxIdleTimeMS": {
				"title": "Max Idle Time MS",
				"description": "Specifies the maximum amount of time, in milliseconds, the Java driver will allow a pooled connection to idle before closing the connection. A value of 0 indicates that there is no upper bound on how long the driver can allow a pooled collection to be idle. Default: 0",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "0"
			},
			"maxLifeTimeMS": {
				"title": "Max Life Time MS",
				"description": "Specifies the maximum amount of time, in milliseconds, the Java driver will continue to use a pooled connection before closing the connection. A value of 0 indicates that there is no upper bound on how long the driver can keep a pooled connection open. Default: 0",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "0"
			},
			"maxPoolSize": {
				"title": "Max Pool Size",
				"description": "The maximum number of connections in the connection pool. The default value is 100.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "100"
			},
			"maxStalenessSeconds": {
				"title": "Max Staleness Seconds",
				"description": "Specifies, in seconds, how stale a secondary can be before the driver stops communicating with that secondary. The minimum value is either 90 seconds or the heartbeat frequency plus 10 seconds, whichever is greater. For more information, see the server documentation for the maxStalenessSeconds option. Not providing a parameter or explicitly specifying -1 indicates that there should be no staleness check for secondaries. Default: -1",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "-1"
			},
			"minPoolSize": {
				"title": "Min Pool Size",
				"description": "Specifies the minimum number of connections that must exist at any moment in a single connection pool. Default: 0",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "0"
			},
			"readPreference": {
				"title": "Read Preference",
				"description": "Configure how MongoDB clients route read operations to the members of a replica set. Possible values are PRIMARY, PRIMARY_PREFERRED, SECONDARY, SECONDARY_PREFERRED or NEAREST",
				"type": "string",
				"enum": [
					"PRIMARY",
					"PRIMARY_PREFERRED",
					"SECONDARY",
					"SECONDARY_PREFERRED",
					"NEAREST"
				],
				"$comment": "group:advanced",
				"default": "PRIMARY"
			},
			"readPreferenceTags": {
				"title": "Read Preference Tags",
				"description": "A representation of a tag set as a comma-separated list of colon-separated key-value pairs, e.g. dc:ny,rack:1. Spaces are stripped from the beginning and end of all keys and values. To specify a list of tag sets, using multiple readPreferenceTags, e.g., readPreferenceTags=dc:ny,rack:1;readPreferenceTags=dc:ny;readPreferenceTags= Note the empty value for the last one, which means match any secondary as a last resort. Order matters when using multiple readPreferenceTags.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"replicaSet": {
				"title": "Replica Set",
				"description": "Specifies that the connection string provided includes multiple hosts. When specified, the driver attempts to find all members of that set.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"retryReads": {
				"title": "Retry Reads",
				"description": "Specifies that the driver must retry supported read operations if they fail due to a network error. Default: true",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"retryWrites": {
				"title": "Retry Writes",
				"description": "Specifies that the driver must retry supported write operations if they fail due to a network error. Default: true",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"serverSelectionTimeoutMS": {
				"title": "Server Selection Timeout MS",
				"description": "Specifies how long (in milliseconds) to block for server selection before throwing an exception. Default: 30,000 milliseconds.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "30000"
			},
			"socketTimeoutMS": {
				"title": "Socket Timeout MS",
				"description": "Specifies the maximum amount of time, in milliseconds, the Java driver will wait to send or receive a request before timing out. A value of 0 instructs the driver to never time out while waiting to send or receive a request. Default: 0",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "0"
			},
			"srvMaxHosts": {
				"title": "Srv Max Hosts",
				"description": "The maximum number of hosts from the SRV record to connect to.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"srvServiceName": {
				"title": "Srv Service Name",
				"description": "Specifies the service name of the SRV resource recordsthe driver retrieves to construct your seed list. You must use the DNS Seed List Connection Format in your connection URI to use this option. Default: mongodb",
				"type": "string",
				"$comment": "group:advanced",
				"default": "mongodb"
			},
			"waitQueueTimeoutMS": {
				"title": "Wait Queue Timeout MS",
				"description": "Specifies the maximum amount of time, in milliseconds that a thread may wait for a connection to become available. Default: 120000 (120 seconds)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "120000"
			},
			"writeConcern": {
				"title": "Write Concern",
				"description": "Configure the connection bean with the level of acknowledgment requested from MongoDB for write operations to a standalone mongod, replicaset or cluster. Possible values are ACKNOWLEDGED, W1, W2, W3, UNACKNOWLEDGED, JOURNALED or MAJORITY.",
				"type": "string",
				"enum": [
					"ACKNOWLEDGED",
					"W1",
					"W2",
					"W3",
					"UNACKNOWLEDGED",
					"JOURNALED",
					"MAJORITY"
				],
				"$comment": "group:advanced",
				"default": "ACKNOWLEDGED"
			},
			"writeResultAsHeader": {
				"title": "Write Result As Header",
				"description": "In write operations, it determines whether instead of returning WriteResult as the body of the OUT message, we transfer the IN message to the OUT and attach the WriteResult as a header.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"zlibCompressionLevel": {
				"title": "Zlib Compression Level",
				"description": "Specifies the degree of compression that Zlib should use to decrease the size of requests to the connected MongoDB instance. The level can range from -1 to 9, with lower values compressing faster (but resulting in larger requests) and larger values compressing slower (but resulting in smaller requests). Default: null",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"streamFilter": {
				"title": "Stream Filter",
				"description": "Filter condition for change streams consumer.",
				"type": "string",
				"$comment": "group:changeStream"
			},
			"authSource": {
				"title": "Auth Source",
				"description": "The database name associated with the user's credentials.",
				"type": "string",
				"$comment": "group:security"
			},
			"password": {
				"title": "Password",
				"description": "User password for mongodb connection",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"tls": {
				"title": "Tls",
				"description": "Specifies that all communication with MongoDB instances should use TLS. Supersedes the ssl option. Default: false",
				"type": "boolean",
				"$comment": "group:security"
			},
			"tlsAllowInvalidHostnames": {
				"title": "Tls Allow Invalid Hostnames",
				"description": "Specifies that the driver should allow invalid hostnames in the certificate for TLS connections. Supersedes sslInvalidHostNameAllowed. Has the same effect as tlsInsecure by setting tlsAllowInvalidHostnames to true. Default: false",
				"type": "boolean",
				"$comment": "group:security"
			},
			"username": {
				"title": "Username",
				"description": "Username for mongodb connection",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"connectionBean"
		]
	},
	"mongodb-gridfs": {
		"properties": {
			"connectionBean": {
				"title": "Connection Bean",
				"description": "Name of com.mongodb.client.MongoClient to use.",
				"type": "string",
				"$comment": "group:common"
			},
			"bucket": {
				"title": "Bucket",
				"description": "Sets the name of the GridFS bucket within the database. Default is fs.",
				"type": "string",
				"$comment": "group:common",
				"default": "fs"
			},
			"database": {
				"title": "Database",
				"description": "Sets the name of the MongoDB database to target",
				"type": "string",
				"$comment": "group:common"
			},
			"readPreference": {
				"title": "Read Preference",
				"description": "Sets a MongoDB ReadPreference on the Mongo connection. Read preferences set directly on the connection will be overridden by this setting. The com.mongodb.ReadPreference#valueOf(String) utility method is used to resolve the passed readPreference value. Some examples for the possible values are nearest, primary or secondary etc.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.mongodb.ReadPreference"
			},
			"writeConcern": {
				"title": "Write Concern",
				"description": "Set the WriteConcern for write operations on MongoDB using the standard ones. Resolved from the fields of the WriteConcern class by calling the WriteConcern#valueOf(String) method.",
				"type": "string",
				"enum": [
					"ACKNOWLEDGED",
					"W1",
					"W2",
					"W3",
					"UNACKNOWLEDGED",
					"JOURNALED",
					"MAJORITY"
				],
				"$comment": "group:common",
				"format": "bean:com.mongodb.WriteConcern"
			},
			"delay": {
				"title": "Delay",
				"description": "Sets the delay between polls within the Consumer. Default is 500ms",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "500"
			},
			"fileAttributeName": {
				"title": "File Attribute Name",
				"description": "If the QueryType uses a FileAttribute, this sets the name of the attribute that is used. Default is camel-processed.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "camel-processed"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Sets the initialDelay before the consumer will start polling. Default is 1000ms",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "1000"
			},
			"persistentTSCollection": {
				"title": "Persistent TSCollection",
				"description": "If the QueryType uses a persistent timestamp, this sets the name of the collection within the DB to store the timestamp.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "camel-timestamps"
			},
			"persistentTSObject": {
				"title": "Persistent TSObject",
				"description": "If the QueryType uses a persistent timestamp, this is the ID of the object in the collection to store the timestamp.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "camel-timestamp"
			},
			"query": {
				"title": "Query",
				"description": "Additional query parameters (in JSON) that are used to configure the query used for finding files in the GridFsConsumer",
				"type": "string",
				"$comment": "group:consumer"
			},
			"queryStrategy": {
				"title": "Query Strategy",
				"description": "Sets the QueryStrategy that is used for polling for new files. Default is Timestamp",
				"type": "string",
				"enum": [
					"TimeStamp",
					"PersistentTimestamp",
					"FileAttribute",
					"TimeStampAndFileAttribute",
					"PersistentTimestampAndFileAttribute"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.mongodb.gridfs.QueryStrategy",
				"default": "TimeStamp"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Sets the operation this endpoint will execute against GridFs.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"connectionBean",
			"database"
		]
	},
	"mustache": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"encoding": {
				"title": "Encoding",
				"description": "Character encoding of the resource content.",
				"type": "string",
				"$comment": "group:producer"
			},
			"endDelimiter": {
				"title": "End Delimiter",
				"description": "Characters used to mark template code end.",
				"type": "string",
				"$comment": "group:producer",
				"default": "}}"
			},
			"startDelimiter": {
				"title": "Start Delimiter",
				"description": "Characters used to mark template code beginning.",
				"type": "string",
				"$comment": "group:producer",
				"default": "{{"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"mvel": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"encoding": {
				"title": "Encoding",
				"description": "Character encoding of the resource content.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"mybatis": {
		"properties": {
			"statement": {
				"title": "Statement",
				"description": "The statement name in the MyBatis XML mapping file which maps to the query, insert, update or delete operation you wish to evaluate.",
				"type": "string",
				"$comment": "group:common"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "This option is intended to split results returned by the database pool into the batches and deliver them in multiple exchanges. This integer defines the maximum messages to deliver in single exchange. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disable it.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 0
			},
			"onConsume": {
				"title": "On Consume",
				"description": "Statement to run after data has been processed in the route",
				"type": "string",
				"$comment": "group:consumer"
			},
			"routeEmptyResultSet": {
				"title": "Route Empty Result Set",
				"description": "Whether allow empty resultset to be routed to the next hop",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"transacted": {
				"title": "Transacted",
				"description": "Enables or disables transaction. If enabled then if processing an exchange failed then the consumer breaks out processing any further exchanges to cause a rollback eager.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"useIterator": {
				"title": "Use Iterator",
				"description": "Process resultset individually or as a list",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"processingStrategy": {
				"title": "Processing Strategy",
				"description": "To use a custom MyBatisProcessingStrategy",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mybatis.MyBatisProcessingStrategy"
			},
			"executorType": {
				"title": "Executor Type",
				"description": "The executor type to be used while executing statements. simple - executor does nothing special. reuse - executor reuses prepared statements. batch - executor reuses statements and batches updates.",
				"type": "string",
				"enum": [
					"SIMPLE",
					"REUSE",
					"BATCH"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.ibatis.session.ExecutorType",
				"default": "SIMPLE"
			},
			"inputHeader": {
				"title": "Input Header",
				"description": "User the header value for input parameters instead of the message body. By default, inputHeader == null and the input parameters are taken from the message body. If outputHeader is set, the value is used and query parameters will be taken from the header instead of the body.",
				"type": "string",
				"$comment": "group:producer"
			},
			"outputHeader": {
				"title": "Output Header",
				"description": "Store the query result in a header instead of the message body. By default, outputHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved. Setting outputHeader will also omit populating the default CamelMyBatisResult header since it would be the same as outputHeader all the time.",
				"type": "string",
				"$comment": "group:producer"
			},
			"statementType": {
				"title": "Statement Type",
				"description": "Mandatory to specify for the producer to control which kind of operation to invoke.",
				"type": "string",
				"enum": [
					"SelectOne",
					"SelectList",
					"Insert",
					"InsertList",
					"Update",
					"UpdateList",
					"Delete",
					"DeleteList"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.mybatis.StatementType"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"statement"
		]
	},
	"mybatis-bean": {
		"properties": {
			"beanName": {
				"title": "Bean Name",
				"description": "Name of the bean with the MyBatis annotations. This can either by a type alias or a FQN class name.",
				"type": "string",
				"$comment": "group:producer"
			},
			"methodName": {
				"title": "Method Name",
				"description": "Name of the method on the bean that has the SQL query to be executed.",
				"type": "string",
				"$comment": "group:producer"
			},
			"executorType": {
				"title": "Executor Type",
				"description": "The executor type to be used while executing statements. simple - executor does nothing special. reuse - executor reuses prepared statements. batch - executor reuses statements and batches updates.",
				"type": "string",
				"enum": [
					"SIMPLE",
					"REUSE",
					"BATCH"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.ibatis.session.ExecutorType",
				"default": "SIMPLE"
			},
			"inputHeader": {
				"title": "Input Header",
				"description": "User the header value for input parameters instead of the message body. By default, inputHeader == null and the input parameters are taken from the message body. If outputHeader is set, the value is used and query parameters will be taken from the header instead of the body.",
				"type": "string",
				"$comment": "group:producer"
			},
			"outputHeader": {
				"title": "Output Header",
				"description": "Store the query result in a header instead of the message body. By default, outputHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved. Setting outputHeader will also omit populating the default CamelMyBatisResult header since it would be the same as outputHeader all the time.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"beanName",
			"methodName"
		]
	},
	"nats": {
		"properties": {
			"topic": {
				"title": "Topic",
				"description": "The name of topic we want to use",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Timeout for connection attempts. (in milliseconds)",
				"type": "integer",
				"$comment": "group:common",
				"default": 2000
			},
			"flushConnection": {
				"title": "Flush Connection",
				"description": "Define if we want to flush connection when stopping or not",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"flushTimeout": {
				"title": "Flush Timeout",
				"description": "Set the flush timeout (in milliseconds)",
				"type": "integer",
				"$comment": "group:common",
				"default": 1000
			},
			"maxPingsOut": {
				"title": "Max Pings Out",
				"description": "maximum number of pings have not received a response allowed by the client",
				"type": "integer",
				"$comment": "group:common",
				"default": 2
			},
			"maxReconnectAttempts": {
				"title": "Max Reconnect Attempts",
				"description": "Max reconnection attempts",
				"type": "integer",
				"$comment": "group:common",
				"default": 60
			},
			"noEcho": {
				"title": "No Echo",
				"description": "Turn off echo. If supported by the gnatsd version you are connecting to this flag will prevent the server from echoing messages back to the connection if it has subscriptions on the subject being published to.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"noRandomizeServers": {
				"title": "No Randomize Servers",
				"description": "Whether or not randomizing the order of servers for the connection attempts",
				"type": "boolean",
				"$comment": "group:common"
			},
			"pedantic": {
				"title": "Pedantic",
				"description": "Whether or not running in pedantic mode (this affects performance)",
				"type": "boolean",
				"$comment": "group:common"
			},
			"pingInterval": {
				"title": "Ping Interval",
				"description": "Ping interval to be aware if connection is still alive (in milliseconds)",
				"type": "integer",
				"$comment": "group:common",
				"default": 120000
			},
			"reconnect": {
				"title": "Reconnect",
				"description": "Whether or not using reconnection feature",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"reconnectTimeWait": {
				"title": "Reconnect Time Wait",
				"description": "Waiting time before attempts reconnection (in milliseconds)",
				"type": "integer",
				"$comment": "group:common",
				"default": 2000
			},
			"requestCleanupInterval": {
				"title": "Request Cleanup Interval",
				"description": "Interval to clean up cancelled/timed out requests.",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"servers": {
				"title": "Servers",
				"description": "URLs to one or more NAT servers. Use comma to separate URLs when specifying multiple servers.",
				"type": "string",
				"$comment": "group:common"
			},
			"verbose": {
				"title": "Verbose",
				"description": "Whether or not running in verbose mode",
				"type": "boolean",
				"$comment": "group:common"
			},
			"maxMessages": {
				"title": "Max Messages",
				"description": "Stop receiving messages from a topic we are subscribing to after maxMessages",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "Consumer thread pool size (default is 10)",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"queueName": {
				"title": "Queue Name",
				"description": "The Queue name if we are using nats for a queue configuration",
				"type": "string",
				"$comment": "group:consumer"
			},
			"replyToDisabled": {
				"title": "Reply To Disabled",
				"description": "Can be used to turn off sending back reply message in the consumer.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"replySubject": {
				"title": "Reply Subject",
				"description": "the subject to which subscribers should send response",
				"type": "string",
				"$comment": "group:producer"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "Request timeout in milliseconds",
				"type": "integer",
				"$comment": "group:producer",
				"default": 20000
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connection": {
				"title": "Connection",
				"description": "Reference an already instantiated connection to Nats server",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.nats.client.Connection"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "Define the header filtering strategy",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"traceConnection": {
				"title": "Trace Connection",
				"description": "Whether or not connection trace messages should be printed to standard out for fine grained debugging of connection issues.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"credentialsFilePath": {
				"title": "Credentials File Path",
				"description": "If we use useCredentialsFile to true we'll need to set the credentialsFilePath option. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:security"
			},
			"secure": {
				"title": "Secure",
				"description": "Set secure option indicating TLS is required",
				"type": "boolean",
				"$comment": "group:security"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"topic"
		]
	},
	"neo4j": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The database name",
				"type": "string",
				"$comment": "group:producer"
			},
			"alias": {
				"title": "Alias",
				"description": "Node alias",
				"type": "string",
				"$comment": "group:producer"
			},
			"databaseUrl": {
				"title": "Database Url",
				"description": "Url for connecting to Neo database",
				"type": "string",
				"$comment": "group:producer"
			},
			"detachRelationship": {
				"title": "Detach Relationship",
				"description": "Detach a relationship - set true if want to delete a node and detach its relationships to other nodes at same time",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"dimension": {
				"title": "Dimension",
				"description": "Dimension of Vector Index",
				"type": "integer",
				"$comment": "group:producer"
			},
			"label": {
				"title": "Label",
				"description": "Node Label",
				"type": "string",
				"$comment": "group:producer"
			},
			"maxResults": {
				"title": "Max Results",
				"description": "Maximum results for Vector Similarity search",
				"type": "integer",
				"$comment": "group:producer",
				"default": 3
			},
			"minScore": {
				"title": "Min Score",
				"description": "Minimum score for Vector Similarity search",
				"type": "number",
				"$comment": "group:producer",
				"default": "0.0"
			},
			"query": {
				"title": "Query",
				"description": "Cypher Query",
				"type": "string",
				"$comment": "group:producer"
			},
			"similarityFunction": {
				"title": "Similarity Function",
				"description": "Similarity Function of Vector Index",
				"type": "string",
				"enum": [
					"cosine",
					"euclidean"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.neo4j.Neo4jSimilarityFunction",
				"default": "cosine"
			},
			"vectorIndexName": {
				"title": "Vector Index Name",
				"description": "Vector Index Name",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"driver": {
				"title": "Driver",
				"description": "Advanced - Driver",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.neo4j.driver.Driver"
			},
			"kerberosAuthTicket": {
				"title": "Encoded base64 ticket",
				"description": "Kerberos Authentication encoded base64 ticket",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Database password",
				"description": "Basic authentication database password",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"realm": {
				"title": "Database realm",
				"description": "Basic authentication database realm",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"token": {
				"title": "Realm",
				"description": "Bearer authentication database realm",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Database user",
				"description": "Basic authentication database user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"netty": {
		"properties": {
			"protocol": {
				"title": "Protocol",
				"description": "The protocol to use which can be tcp or udp.",
				"type": "string",
				"enum": [
					"tcp",
					"udp"
				],
				"$comment": "group:common"
			},
			"host": {
				"title": "Host",
				"description": "The hostname. For the consumer the hostname is localhost or 0.0.0.0. For the producer the hostname is the remote host to connect to",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The host port number",
				"type": "integer",
				"$comment": "group:common"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether or not to disconnect(close) from Netty Channel right after use. Can be used for both consumer and producer.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"keepAlive": {
				"title": "Keep Alive",
				"description": "Setting to ensure socket is not closed due to inactivity",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"reuseAddress": {
				"title": "Reuse Address",
				"description": "Setting to facilitate socket multiplexing",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"reuseChannel": {
				"title": "Reuse Channel",
				"description": "This option allows producers and consumers (in client mode) to reuse the same Netty Channel for the lifecycle of processing the Exchange. This is useful if you need to call a server multiple times in a Camel route and want to use the same network connection. When using this, the channel is not returned to the connection pool until the Exchange is done; or disconnected if the disconnect option is set to true. The reused Channel is stored on the Exchange as an exchange property with the key NettyConstants#NETTY_CHANNEL which allows you to obtain the channel during routing and use it as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"sync": {
				"title": "Sync",
				"description": "Setting to set endpoint as one-way or request-response",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"tcpNoDelay": {
				"title": "Tcp No Delay",
				"description": "Setting to improve TCP protocol performance",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"broadcast": {
				"title": "Broadcast",
				"description": "Setting to choose Multicast over UDP",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"clientMode": {
				"title": "Client Mode",
				"description": "If the clientMode is true, netty consumer will connect the address as a TCP client.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"reconnect": {
				"title": "Reconnect",
				"description": "Used only in clientMode in consumer, the consumer will attempt to reconnect on disconnection if this is enabled",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"reconnectInterval": {
				"title": "Reconnect Interval",
				"description": "Used if reconnect and clientMode is enabled. The interval in milli seconds to attempt reconnection",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10000
			},
			"backlog": {
				"title": "Backlog",
				"description": "Allows to configure a backlog for netty consumer (server). Note the backlog is just a best effort depending on the OS. Setting this option to a value such as 200, 500 or 1000, tells the TCP stack how long the accept queue can be If this option is not configured, then the backlog depends on OS setting.",
				"type": "integer",
				"$comment": "group:consumer (advanced)"
			},
			"bossCount": {
				"title": "Boss Count",
				"description": "When netty works on nio mode, it uses default bossCount parameter from Netty, which is 1. User can use this option to override the default bossCount from Netty",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": 1
			},
			"bossGroup": {
				"title": "Boss Group",
				"description": "Set the BossGroup which could be used for handling the new connection of the server side across the NettyEndpoint",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:io.netty.channel.EventLoopGroup"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"disconnectOnNoReply": {
				"title": "Disconnect On No Reply",
				"description": "If sync is enabled then this option dictates NettyConsumer if it should disconnect where there is no reply to send back.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"nettyServerBootstrapFactory": {
				"title": "Netty Server Bootstrap Factory",
				"description": "To use a custom NettyServerBootstrapFactory",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.netty.NettyServerBootstrapFactory"
			},
			"networkInterface": {
				"title": "Network Interface",
				"description": "When using UDP then this option can be used to specify a network interface by its name, such as eth0 to join a multicast group.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"noReplyLogLevel": {
				"title": "No Reply Log Level",
				"description": "If sync is enabled this option dictates NettyConsumer which logging level to use when logging a there is no reply to send back.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"serverClosedChannelExceptionCaughtLogLevel": {
				"title": "Server Closed Channel Exception Caught Log Level",
				"description": "If the server (NettyConsumer) catches an java.nio.channels.ClosedChannelException then its logged using this logging level. This is used to avoid logging the closed channel exceptions, as clients can disconnect abruptly and then cause a flood of closed exceptions in the Netty server.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"serverExceptionCaughtLogLevel": {
				"title": "Server Exception Caught Log Level",
				"description": "If the server (NettyConsumer) catches an exception then its logged using this logging level.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"serverInitializerFactory": {
				"title": "Server Initializer Factory",
				"description": "To use a custom ServerInitializerFactory",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.netty.ServerInitializerFactory"
			},
			"usingExecutorService": {
				"title": "Using Executor Service",
				"description": "Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Time to wait for a socket connection to be available. Value is in milliseconds.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 10000
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "Allows to use a timeout for the Netty producer when calling a remote server. By default no timeout is in use. The value is in milli seconds, so eg 30000 is 30 seconds. The requestTimeout is using Netty's ReadTimeoutHandler to trigger the timeout.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"clientInitializerFactory": {
				"title": "Client Initializer Factory",
				"description": "To use a custom ClientInitializerFactory",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.netty.ClientInitializerFactory"
			},
			"correlationManager": {
				"title": "Correlation Manager",
				"description": "To use a custom correlation manager to manage how request and reply messages are mapped when using request/reply with the netty producer. This should only be used if you have a way to map requests together with replies such as if there is correlation ids in both the request and reply messages. This can be used if you want to multiplex concurrent messages on the same channel (aka connection) in netty. When doing this you must have a way to correlate the request and reply messages so you can store the right reply on the inflight Camel Exchange before its continued routed. We recommend extending the TimeoutCorrelationManagerSupport when you build custom correlation managers. This provides support for timeout and other complexities you otherwise would need to implement as well. See also the producerPoolEnabled option for more details.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.netty.NettyCamelStateCorrelationManager"
			},
			"lazyChannelCreation": {
				"title": "Lazy Channel Creation",
				"description": "Channels can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"producerPoolBlockWhenExhausted": {
				"title": "Producer Pool Block When Exhausted",
				"description": "Sets the value for the blockWhenExhausted configuration attribute. It determines whether to block when the borrowObject() method is invoked when the pool is exhausted (the maximum number of active objects has been reached).",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"producerPoolEnabled": {
				"title": "Producer Pool Enabled",
				"description": "Whether producer pool is enabled or not. Important: If you turn this off then a single shared connection is used for the producer, also if you are doing request/reply. That means there is a potential issue with interleaved responses if replies comes back out-of-order. Therefore you need to have a correlation id in both the request and reply messages so you can properly correlate the replies to the Camel callback that is responsible for continue processing the message in Camel. To do this you need to implement NettyCamelStateCorrelationManager as correlation manager and configure it via the correlationManager option. See also the correlationManager option for more details.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"producerPoolMaxIdle": {
				"title": "Producer Pool Max Idle",
				"description": "Sets the cap on the number of idle instances in the pool.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": 100
			},
			"producerPoolMaxTotal": {
				"title": "Producer Pool Max Total",
				"description": "Sets the cap on the number of objects that can be allocated by the pool (checked out to clients, or idle awaiting checkout) at a given time. Use a negative value for no limit. Be careful to not set this value too low (such as 1) as the pool must have space to create a producer such as when performing retries. Be mindful that the option producerPoolBlockWhenExhausted is default true, and the pool will then block when there is no space, which can lead to the application to hang.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": -1
			},
			"producerPoolMaxWait": {
				"title": "Producer Pool Max Wait",
				"description": "Sets the maximum duration (value in millis) the borrowObject() method should block before throwing an exception when the pool is exhausted and producerPoolBlockWhenExhausted is true. When less than 0, the borrowObject() method may block indefinitely.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": -1
			},
			"producerPoolMinEvictableIdle": {
				"title": "Producer Pool Min Evictable Idle",
				"description": "Sets the minimum amount of time (value in millis) an object may sit idle in the pool before it is eligible for eviction by the idle object evictor.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": 300000
			},
			"producerPoolMinIdle": {
				"title": "Producer Pool Min Idle",
				"description": "Sets the minimum number of instances allowed in the producer pool before the evictor thread (if active) spawns new objects.",
				"type": "integer",
				"$comment": "group:producer (advanced)"
			},
			"udpConnectionlessSending": {
				"title": "Udp Connectionless Sending",
				"description": "This option supports connection less udp sending which is a real fire and forget. A connected udp send receive the PortUnreachableException if no one is listen on the receiving port.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"useByteBuf": {
				"title": "Use Byte Buf",
				"description": "If the useByteBuf is true, netty producer will turn the message body into ByteBuf before sending it out.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"allowSerializedHeaders": {
				"title": "Allow Serialized Headers",
				"description": "Only used for TCP when transferExchange is true. When set to true, serializable objects in headers and properties will be added to the exchange. Otherwise Camel will exclude any non-serializable objects and log it at WARN level.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"channelGroup": {
				"title": "Channel Group",
				"description": "To use a explicit ChannelGroup.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.netty.channel.group.ChannelGroup"
			},
			"nativeTransport": {
				"title": "Native Transport",
				"description": "Whether to use native transport instead of NIO. Native transport takes advantage of the host operating system and is only supported on some platforms. You need to add the netty JAR for the host operating system you are using. See more details at: http://netty.io/wiki/native-transports.html",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"options": {
				"title": "Options",
				"description": "Allows to configure additional netty options using option. as prefix. For example option.child.keepAlive=false to set the netty option child.keepAlive=false. See the Netty documentation for possible options that can be used.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"receiveBufferSize": {
				"title": "Receive Buffer Size",
				"description": "The TCP/UDP buffer sizes to be used during inbound communication. Size is bytes.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 65536
			},
			"receiveBufferSizePredictor": {
				"title": "Receive Buffer Size Predictor",
				"description": "Configures the buffer size predictor. See details at Jetty documentation and this mail thread.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"sendBufferSize": {
				"title": "Send Buffer Size",
				"description": "The TCP/UDP buffer sizes to be used during outbound communication. Size is bytes.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 65536
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transferExchange": {
				"title": "Transfer Exchange",
				"description": "Only used for TCP. You can transfer the exchange over the wire instead of just the body. The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"udpByteArrayCodec": {
				"title": "Udp Byte Array Codec",
				"description": "For UDP only. If enabled the using byte array codec instead of Java serialization protocol.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"unixDomainSocketPath": {
				"title": "Unix Domain Socket Path",
				"description": "Path to unix domain socket to use instead of inet socket. Host and port parameters will not be used, however required. It is ok to set dummy values for them. Must be used with nativeTransport=true and clientMode=false.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"workerCount": {
				"title": "Worker Count",
				"description": "When netty works on nio mode, it uses default workerCount parameter from Netty (which is cpu_core_threads x 2). User can use this option to override the default workerCount from Netty.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"workerGroup": {
				"title": "Worker Group",
				"description": "To use a explicit EventLoopGroup as the boss thread pool. For example to share a thread pool with multiple consumers or producers. By default each consumer or producer has their own worker pool with 2 x cpu count core threads.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.netty.channel.EventLoopGroup"
			},
			"allowDefaultCodec": {
				"title": "Allow Default Codec",
				"description": "The netty component installs a default codec if both, encoder/decoder is null and textline is false. Setting allowDefaultCodec to false prevents the netty component from installing a default codec as the first element in the filter chain.",
				"type": "boolean",
				"$comment": "group:codec",
				"default": true
			},
			"autoAppendDelimiter": {
				"title": "Auto Append Delimiter",
				"description": "Whether or not to auto append missing end delimiter when sending using the textline codec.",
				"type": "boolean",
				"$comment": "group:codec",
				"default": true
			},
			"decoderMaxLineLength": {
				"title": "Decoder Max Line Length",
				"description": "The max line length to use for the textline codec.",
				"type": "integer",
				"$comment": "group:codec",
				"default": 1024
			},
			"decoders": {
				"title": "Decoders",
				"description": "A list of decoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry. Just remember to prefix the value with # so Camel knows it should lookup.",
				"type": "string",
				"$comment": "group:codec"
			},
			"delimiter": {
				"title": "Delimiter",
				"description": "The delimiter to use for the textline codec. Possible values are LINE and NULL.",
				"type": "string",
				"enum": [
					"LINE",
					"NULL"
				],
				"$comment": "group:codec",
				"format": "bean:org.apache.camel.component.netty.TextLineDelimiter",
				"default": "LINE"
			},
			"encoders": {
				"title": "Encoders",
				"description": "A list of encoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry. Just remember to prefix the value with # so Camel knows it should lookup.",
				"type": "string",
				"$comment": "group:codec"
			},
			"encoding": {
				"title": "Encoding",
				"description": "The encoding (a charset name) to use for the textline codec. If not provided, Camel will use the JVM default Charset.",
				"type": "string",
				"$comment": "group:codec"
			},
			"textline": {
				"title": "Textline",
				"description": "Only used for TCP. If no codec is specified, you can use this flag to indicate a text line based codec; if not specified or the value is false, then Object Serialization is assumed over TCP - however only Strings are allowed to be serialized by default.",
				"type": "boolean",
				"$comment": "group:codec"
			},
			"enabledProtocols": {
				"title": "Enabled Protocols",
				"description": "Which protocols to enable when using SSL",
				"type": "string",
				"$comment": "group:security",
				"default": "TLSv1.2,TLSv1.3"
			},
			"hostnameVerification": {
				"title": "Hostname Verification",
				"description": "To enable/disable hostname verification on SSLEngine",
				"type": "boolean",
				"$comment": "group:security"
			},
			"keyStoreFile": {
				"title": "Key Store File",
				"description": "Client side certificate keystore to be used for encryption",
				"type": "string",
				"$comment": "group:security"
			},
			"keyStoreFormat": {
				"title": "Key Store Format",
				"description": "Keystore format to be used for payload encryption. Defaults to JKS if not set",
				"type": "string",
				"$comment": "group:security"
			},
			"keyStoreResource": {
				"title": "Key Store Resource",
				"description": "Client side certificate keystore to be used for encryption. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:security"
			},
			"needClientAuth": {
				"title": "Need Client Auth",
				"description": "Configures whether the server needs client authentication when using SSL.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"passphrase": {
				"title": "Passphrase",
				"description": "Password setting to use in order to encrypt/decrypt payloads sent using SSH",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"securityProvider": {
				"title": "Security Provider",
				"description": "Security provider to be used for payload encryption. Defaults to SunX509 if not set.",
				"type": "string",
				"$comment": "group:security"
			},
			"ssl": {
				"title": "Ssl",
				"description": "Setting to specify whether SSL encryption is applied to this endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"sslClientCertHeaders": {
				"title": "Ssl Client Cert Headers",
				"description": "When enabled and in SSL mode, then the Netty consumer will enrich the Camel Message with headers having information about the client certificate such as subject name, issuer name, serial number, and the valid date range.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"sslHandler": {
				"title": "Ssl Handler",
				"description": "Reference to a class that could be used to return an SSL Handler",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:io.netty.handler.ssl.SslHandler"
			},
			"trustStoreFile": {
				"title": "Trust Store File",
				"description": "Server side certificate keystore to be used for encryption",
				"type": "string",
				"$comment": "group:security"
			},
			"trustStoreResource": {
				"title": "Trust Store Resource",
				"description": "Server side certificate keystore to be used for encryption. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"protocol",
			"host",
			"port"
		]
	},
	"netty-http": {
		"properties": {
			"protocol": {
				"title": "Protocol",
				"description": "The protocol to use which is either http, https or proxy (consumer only).",
				"type": "string",
				"enum": [
					"http",
					"https",
					"proxy"
				],
				"$comment": "group:common"
			},
			"host": {
				"title": "Host",
				"description": "The local hostname such as localhost, or 0.0.0.0 when being a consumer. The remote HTTP server hostname when using producer.",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The host port number",
				"type": "integer",
				"$comment": "group:common"
			},
			"path": {
				"title": "Path",
				"description": "Resource path",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeEndpoint": {
				"title": "Bridge Endpoint",
				"description": "If the option is true, the producer will ignore the NettyHttpConstants.HTTP_URI header, and use the endpoint's URI for request. You may also set the throwExceptionOnFailure to be false to let the producer send all the fault response back. The consumer working in the bridge mode will skip the gzip compression and WWW URL form encoding (by adding the Exchange.SKIP_GZIP_ENCODING and Exchange.SKIP_WWW_FORM_URLENCODED headers to the consumed exchange).",
				"type": "boolean",
				"$comment": "group:common"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether or not to disconnect(close) from Netty Channel right after use. Can be used for both consumer and producer.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"keepAlive": {
				"title": "Keep Alive",
				"description": "Setting to ensure socket is not closed due to inactivity",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"reuseAddress": {
				"title": "Reuse Address",
				"description": "Setting to facilitate socket multiplexing",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"reuseChannel": {
				"title": "Reuse Channel",
				"description": "This option allows producers and consumers (in client mode) to reuse the same Netty Channel for the lifecycle of processing the Exchange. This is useful if you need to call a server multiple times in a Camel route and want to use the same network connection. When using this, the channel is not returned to the connection pool until the Exchange is done; or disconnected if the disconnect option is set to true. The reused Channel is stored on the Exchange as an exchange property with the key NettyConstants#NETTY_CHANNEL which allows you to obtain the channel during routing and use it as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"sync": {
				"title": "Sync",
				"description": "Setting to set endpoint as one-way or request-response",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"tcpNoDelay": {
				"title": "Tcp No Delay",
				"description": "Setting to improve TCP protocol performance",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"matchOnUriPrefix": {
				"title": "Match On Uri Prefix",
				"description": "Whether or not Camel should try to find a target consumer by matching the URI prefix if no exact match is found.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"muteException": {
				"title": "Mute Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"send503whenSuspended": {
				"title": "Send503when Suspended",
				"description": "Whether to send back HTTP status code 503 when the consumer has been suspended. If the option is false then the Netty Acceptor is unbound when the consumer is suspended, so clients cannot connect anymore.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"backlog": {
				"title": "Backlog",
				"description": "Allows to configure a backlog for netty consumer (server). Note the backlog is just a best effort depending on the OS. Setting this option to a value such as 200, 500 or 1000, tells the TCP stack how long the accept queue can be If this option is not configured, then the backlog depends on OS setting.",
				"type": "integer",
				"$comment": "group:consumer (advanced)"
			},
			"bossCount": {
				"title": "Boss Count",
				"description": "When netty works on nio mode, it uses default bossCount parameter from Netty, which is 1. User can use this option to override the default bossCount from Netty",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": 1
			},
			"bossGroup": {
				"title": "Boss Group",
				"description": "Set the BossGroup which could be used for handling the new connection of the server side across the NettyEndpoint",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:io.netty.channel.EventLoopGroup"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"chunkedMaxContentLength": {
				"title": "Chunked Max Content Length",
				"description": "Value in bytes the max content length per chunked frame received on the Netty HTTP server.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": 1048576
			},
			"compression": {
				"title": "Compression",
				"description": "Allow using gzip/deflate for compression on the Netty HTTP server if the client supports it from the HTTP headers.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"disconnectOnNoReply": {
				"title": "Disconnect On No Reply",
				"description": "If sync is enabled then this option dictates NettyConsumer if it should disconnect where there is no reply to send back.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"httpMethodRestrict": {
				"title": "Http Method Restrict",
				"description": "To disable HTTP methods on the Netty HTTP consumer. You can specify multiple separated by comma.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"logWarnOnBadRequest": {
				"title": "Log Warn On Bad Request",
				"description": "Whether Netty HTTP server should log a WARN if decoding the HTTP request failed and a HTTP Status 400 (bad request) is returned.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"mapHeaders": {
				"title": "Map Headers",
				"description": "If this option is enabled, then during binding from Netty to Camel Message then the headers will be mapped as well (eg added as header to the Camel Message as well). You can turn off this option to disable this. The headers can still be accessed from the org.apache.camel.component.netty.http.NettyHttpMessage message with the method getHttpRequest() that returns the Netty HTTP request io.netty.handler.codec.http.HttpRequest instance.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"maxChunkSize": {
				"title": "Max Chunk Size",
				"description": "The maximum length of the content or each chunk. If the content length (or the length of each chunk) exceeds this value, the content or chunk will be split into multiple io.netty.handler.codec.http.HttpContents whose length is maxChunkSize at maximum. See io.netty.handler.codec.http.HttpObjectDecoder",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": 8192
			},
			"maxHeaderSize": {
				"title": "Max Header Size",
				"description": "The maximum length of all headers. If the sum of the length of each header exceeds this value, a io.netty.handler.codec.TooLongFrameException will be raised.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": 8192
			},
			"maxInitialLineLength": {
				"title": "Max Initial Line Length",
				"description": "The maximum length of the initial line (e.g. {code GET / HTTP/1.0} or {code HTTP/1.0 200 OK}) If the length of the initial line exceeds this value, a TooLongFrameException will be raised. See io.netty.handler.codec.http.HttpObjectDecoder",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": 4096
			},
			"nettyServerBootstrapFactory": {
				"title": "Netty Server Bootstrap Factory",
				"description": "To use a custom NettyServerBootstrapFactory",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.netty.NettyServerBootstrapFactory"
			},
			"nettySharedHttpServer": {
				"title": "Netty Shared Http Server",
				"description": "To use a shared Netty HTTP server. See Netty HTTP Server Example for more details.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.netty.http.NettySharedHttpServer"
			},
			"noReplyLogLevel": {
				"title": "No Reply Log Level",
				"description": "If sync is enabled this option dictates NettyConsumer which logging level to use when logging a there is no reply to send back.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"serverClosedChannelExceptionCaughtLogLevel": {
				"title": "Server Closed Channel Exception Caught Log Level",
				"description": "If the server (NettyConsumer) catches an java.nio.channels.ClosedChannelException then its logged using this logging level. This is used to avoid logging the closed channel exceptions, as clients can disconnect abruptly and then cause a flood of closed exceptions in the Netty server.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"serverExceptionCaughtLogLevel": {
				"title": "Server Exception Caught Log Level",
				"description": "If the server (NettyConsumer) catches an exception then its logged using this logging level.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"serverInitializerFactory": {
				"title": "Server Initializer Factory",
				"description": "To use a custom ServerInitializerFactory",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.netty.ServerInitializerFactory"
			},
			"traceEnabled": {
				"title": "Trace Enabled",
				"description": "Specifies whether to enable HTTP TRACE for this Netty HTTP consumer. By default TRACE is turned off.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"urlDecodeHeaders": {
				"title": "Url Decode Headers",
				"description": "If this option is enabled, then during binding from Netty to Camel Message then the header values will be URL decoded (eg %20 will be a space character. Notice this option is used by the default org.apache.camel.component.netty.http.NettyHttpBinding and therefore if you implement a custom org.apache.camel.component.netty.http.NettyHttpBinding then you would need to decode the headers accordingly to this option.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"usingExecutorService": {
				"title": "Using Executor Service",
				"description": "Whether to use ordered thread pool, to ensure events are processed orderly on the same channel.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Time to wait for a socket connection to be available. Value is in milliseconds.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 10000
			},
			"cookieHandler": {
				"title": "Cookie Handler",
				"description": "Configure a cookie handler to maintain a HTTP session",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.http.base.cookie.CookieHandler"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "Allows to use a timeout for the Netty producer when calling a remote server. By default no timeout is in use. The value is in milli seconds, so eg 30000 is 30 seconds. The requestTimeout is using Netty's ReadTimeoutHandler to trigger the timeout.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"throwExceptionOnFailure": {
				"title": "Throw Exception On Failure",
				"description": "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"clientInitializerFactory": {
				"title": "Client Initializer Factory",
				"description": "To use a custom ClientInitializerFactory",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.netty.ClientInitializerFactory"
			},
			"lazyChannelCreation": {
				"title": "Lazy Channel Creation",
				"description": "Channels can be lazily created to avoid exceptions, if the remote server is not up and running when the Camel producer is started.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"okStatusCodeRange": {
				"title": "Ok Status Code Range",
				"description": "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included. The default range is 200-299",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"default": "200-299"
			},
			"producerPoolBlockWhenExhausted": {
				"title": "Producer Pool Block When Exhausted",
				"description": "Sets the value for the blockWhenExhausted configuration attribute. It determines whether to block when the borrowObject() method is invoked when the pool is exhausted (the maximum number of active objects has been reached).",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"producerPoolEnabled": {
				"title": "Producer Pool Enabled",
				"description": "Whether producer pool is enabled or not. Important: If you turn this off then a single shared connection is used for the producer, also if you are doing request/reply. That means there is a potential issue with interleaved responses if replies comes back out-of-order. Therefore you need to have a correlation id in both the request and reply messages so you can properly correlate the replies to the Camel callback that is responsible for continue processing the message in Camel. To do this you need to implement NettyCamelStateCorrelationManager as correlation manager and configure it via the correlationManager option. See also the correlationManager option for more details.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"producerPoolMaxIdle": {
				"title": "Producer Pool Max Idle",
				"description": "Sets the cap on the number of idle instances in the pool.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": 100
			},
			"producerPoolMaxTotal": {
				"title": "Producer Pool Max Total",
				"description": "Sets the cap on the number of objects that can be allocated by the pool (checked out to clients, or idle awaiting checkout) at a given time. Use a negative value for no limit. Be careful to not set this value too low (such as 1) as the pool must have space to create a producer such as when performing retries. Be mindful that the option producerPoolBlockWhenExhausted is default true, and the pool will then block when there is no space, which can lead to the application to hang.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": -1
			},
			"producerPoolMaxWait": {
				"title": "Producer Pool Max Wait",
				"description": "Sets the maximum duration (value in millis) the borrowObject() method should block before throwing an exception when the pool is exhausted and producerPoolBlockWhenExhausted is true. When less than 0, the borrowObject() method may block indefinitely.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": -1
			},
			"producerPoolMinEvictableIdle": {
				"title": "Producer Pool Min Evictable Idle",
				"description": "Sets the minimum amount of time (value in millis) an object may sit idle in the pool before it is eligible for eviction by the idle object evictor.",
				"type": "integer",
				"$comment": "group:producer (advanced)",
				"default": 300000
			},
			"producerPoolMinIdle": {
				"title": "Producer Pool Min Idle",
				"description": "Sets the minimum number of instances allowed in the producer pool before the evictor thread (if active) spawns new objects.",
				"type": "integer",
				"$comment": "group:producer (advanced)"
			},
			"useRelativePath": {
				"title": "Use Relative Path",
				"description": "Sets whether to use a relative path in HTTP requests.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"allowSerializedHeaders": {
				"title": "Allow Serialized Headers",
				"description": "Only used for TCP when transferExchange is true. When set to true, serializable objects in headers and properties will be added to the exchange. Otherwise Camel will exclude any non-serializable objects and log it at WARN level.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"channelGroup": {
				"title": "Channel Group",
				"description": "To use a explicit ChannelGroup.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.netty.channel.group.ChannelGroup"
			},
			"configuration": {
				"title": "Configuration",
				"description": "To use a custom configured NettyHttpConfiguration for configuring this endpoint.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.netty.http.NettyHttpConfiguration"
			},
			"disableStreamCache": {
				"title": "Disable Stream Cache",
				"description": "Determines whether or not the raw input stream from Netty HttpRequest#getContent() or HttpResponset#getContent() is cached or not (Camel will read the stream into a in light-weight memory based Stream caching) cache. By default Camel will cache the Netty input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. Mind that if you enable this option, then you cannot read the Netty stream multiple times out of the box, and you would need manually to reset the reader index on the Netty raw stream. Also Netty will auto-close the Netty stream when the Netty HTTP server/HTTP client is done processing, which means that if the asynchronous routing engine is in use then any asynchronous thread that may continue routing the org.apache.camel.Exchange may not be able to read the Netty stream, because Netty has closed it.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"nativeTransport": {
				"title": "Native Transport",
				"description": "Whether to use native transport instead of NIO. Native transport takes advantage of the host operating system and is only supported on some platforms. You need to add the netty JAR for the host operating system you are using. See more details at: http://netty.io/wiki/native-transports.html",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"nettyHttpBinding": {
				"title": "Netty Http Binding",
				"description": "To use a custom org.apache.camel.component.netty.http.NettyHttpBinding for binding to/from Netty and Camel Message API.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.netty.http.NettyHttpBinding"
			},
			"options": {
				"title": "Options",
				"description": "Allows to configure additional netty options using option. as prefix. For example option.child.keepAlive=false to set the netty option child.keepAlive=false. See the Netty documentation for possible options that can be used.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"receiveBufferSize": {
				"title": "Receive Buffer Size",
				"description": "The TCP/UDP buffer sizes to be used during inbound communication. Size is bytes.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 65536
			},
			"receiveBufferSizePredictor": {
				"title": "Receive Buffer Size Predictor",
				"description": "Configures the buffer size predictor. See details at Jetty documentation and this mail thread.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"sendBufferSize": {
				"title": "Send Buffer Size",
				"description": "The TCP/UDP buffer sizes to be used during outbound communication. Size is bytes.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 65536
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transferExchange": {
				"title": "Transfer Exchange",
				"description": "Only used for TCP. You can transfer the exchange over the wire instead of just the body. The following fields are transferred: In body, Out body, fault body, In headers, Out headers, fault headers, exchange properties, exchange exception. This requires that the objects are serializable. Camel will exclude any non-serializable objects and log it at WARN level.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"unixDomainSocketPath": {
				"title": "Unix Domain Socket Path",
				"description": "Path to unix domain socket to use instead of inet socket. Host and port parameters will not be used, however required. It is ok to set dummy values for them. Must be used with nativeTransport=true and clientMode=false.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"workerCount": {
				"title": "Worker Count",
				"description": "When netty works on nio mode, it uses default workerCount parameter from Netty (which is cpu_core_threads x 2). User can use this option to override the default workerCount from Netty.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"workerGroup": {
				"title": "Worker Group",
				"description": "To use a explicit EventLoopGroup as the boss thread pool. For example to share a thread pool with multiple consumers or producers. By default each consumer or producer has their own worker pool with 2 x cpu count core threads.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.netty.channel.EventLoopGroup"
			},
			"decoders": {
				"title": "Decoders",
				"description": "A list of decoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry. Just remember to prefix the value with # so Camel knows it should lookup.",
				"type": "string",
				"$comment": "group:codec"
			},
			"encoders": {
				"title": "Encoders",
				"description": "A list of encoders to be used. You can use a String which have values separated by comma, and have the values be looked up in the Registry. Just remember to prefix the value with # so Camel knows it should lookup.",
				"type": "string",
				"$comment": "group:codec"
			},
			"enabledProtocols": {
				"title": "Enabled Protocols",
				"description": "Which protocols to enable when using SSL",
				"type": "string",
				"$comment": "group:security",
				"default": "TLSv1.2,TLSv1.3"
			},
			"hostnameVerification": {
				"title": "Hostname Verification",
				"description": "To enable/disable hostname verification on SSLEngine",
				"type": "boolean",
				"$comment": "group:security"
			},
			"keyStoreFile": {
				"title": "Key Store File",
				"description": "Client side certificate keystore to be used for encryption",
				"type": "string",
				"$comment": "group:security"
			},
			"keyStoreFormat": {
				"title": "Key Store Format",
				"description": "Keystore format to be used for payload encryption. Defaults to JKS if not set",
				"type": "string",
				"$comment": "group:security"
			},
			"keyStoreResource": {
				"title": "Key Store Resource",
				"description": "Client side certificate keystore to be used for encryption. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:security"
			},
			"needClientAuth": {
				"title": "Need Client Auth",
				"description": "Configures whether the server needs client authentication when using SSL.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"passphrase": {
				"title": "Passphrase",
				"description": "Password setting to use in order to encrypt/decrypt payloads sent using SSH",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"securityConfiguration": {
				"title": "Security Configuration",
				"description": "Refers to a org.apache.camel.component.netty.http.NettyHttpSecurityConfiguration for configuring secure web resources.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.netty.http.NettyHttpSecurityConfiguration"
			},
			"securityOptions": {
				"title": "Security Options",
				"description": "To configure NettyHttpSecurityConfiguration using key/value pairs from the map",
				"type": "object",
				"$comment": "group:security"
			},
			"securityProvider": {
				"title": "Security Provider",
				"description": "Security provider to be used for payload encryption. Defaults to SunX509 if not set.",
				"type": "string",
				"$comment": "group:security"
			},
			"ssl": {
				"title": "Ssl",
				"description": "Setting to specify whether SSL encryption is applied to this endpoint",
				"type": "boolean",
				"$comment": "group:security"
			},
			"sslClientCertHeaders": {
				"title": "Ssl Client Cert Headers",
				"description": "When enabled and in SSL mode, then the Netty consumer will enrich the Camel Message with headers having information about the client certificate such as subject name, issuer name, serial number, and the valid date range.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"sslHandler": {
				"title": "Ssl Handler",
				"description": "Reference to a class that could be used to return an SSL Handler",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:io.netty.handler.ssl.SslHandler"
			},
			"trustStoreFile": {
				"title": "Trust Store File",
				"description": "Server side certificate keystore to be used for encryption",
				"type": "string",
				"$comment": "group:security"
			},
			"trustStoreResource": {
				"title": "Trust Store Resource",
				"description": "Server side certificate keystore to be used for encryption. Is loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"protocol",
			"host"
		]
	},
	"nitrite": {
		"properties": {
			"database": {
				"title": "Database",
				"description": "Path to database file. Will be created if not exists.",
				"type": "string",
				"$comment": "group:common"
			},
			"collection": {
				"title": "Collection",
				"description": "Name of Nitrite collection. Cannot be used in combination with repositoryClass option.",
				"type": "string",
				"$comment": "group:common"
			},
			"repositoryClass": {
				"title": "Repository Class",
				"description": "Class of Nitrite ObjectRepository. Cannot be used in combination with collection option.",
				"type": "string",
				"$comment": "group:common"
			},
			"repositoryName": {
				"title": "Repository Name",
				"description": "Optional name of ObjectRepository. Can be only used in combination with repositoryClass, otherwise have no effect",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"password": {
				"title": "Password",
				"description": "Password for Nitrite database. Required, if option username specified.",
				"type": "string",
				"$comment": "group:security"
			},
			"username": {
				"title": "Username",
				"description": "Username for Nitrite database. Database is not secured if option not specified.",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"database"
		]
	},
	"oaipmh": {
		"properties": {
			"baseUrl": {
				"title": "Base Url",
				"description": "Base URL of the repository to which the request is made through the OAI-PMH protocol",
				"type": "string",
				"$comment": "group:common"
			},
			"from": {
				"title": "From",
				"description": "Specifies a lower bound for datestamp-based selective harvesting. UTC DateTime value",
				"type": "string",
				"$comment": "group:common"
			},
			"identifier": {
				"title": "Identifier",
				"description": "Identifier of the requested resources. Applicable only with certain verbs",
				"type": "string",
				"$comment": "group:common"
			},
			"metadataPrefix": {
				"title": "Metadata Prefix",
				"description": "Specifies the metadataPrefix of the format that should be included in the metadata part of the returned records.",
				"type": "string",
				"$comment": "group:common",
				"default": "oai_dc"
			},
			"set": {
				"title": "Set",
				"description": "Specifies membership as a criteria for set-based selective harvesting",
				"type": "string",
				"$comment": "group:common"
			},
			"until": {
				"title": "Until",
				"description": "Specifies an upper bound for datestamp-based selective harvesting. UTC DateTime value.",
				"type": "string",
				"$comment": "group:common"
			},
			"verb": {
				"title": "Verb",
				"description": "Request name supported by OAI-PMh protocol",
				"type": "string",
				"$comment": "group:common",
				"default": "ListRecords"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"onlyFirst": {
				"title": "Only First",
				"description": "Returns the response of a single request. Otherwise it will make requests until there is no more data to return.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"ignoreSSLWarnings": {
				"title": "Ignore SSLWarnings",
				"description": "Ignore SSL certificate warnings",
				"type": "boolean",
				"$comment": "group:security"
			},
			"ssl": {
				"title": "Ssl",
				"description": "Causes the defined url to make an https request",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"baseUrl"
		]
	},
	"olingo2": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"DEFAULT"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.olingo2.internal.Olingo2ApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"$comment": "group:common"
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "HTTP connection creation timeout in milliseconds, defaults to 30,000 (30 seconds)",
				"type": "integer",
				"$comment": "group:common",
				"default": 30000
			},
			"contentType": {
				"title": "Content Type",
				"description": "Content-Type header value can be used to specify JSON or XML message format, defaults to application/json;charset=utf-8",
				"type": "string",
				"$comment": "group:common",
				"default": "application/json;charset=utf-8"
			},
			"entityProviderReadProperties": {
				"title": "Entity Provider Read Properties",
				"description": "Custom entity provider read properties applied to all read operations.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.olingo.odata2.api.ep.EntityProviderReadProperties"
			},
			"entityProviderWriteProperties": {
				"title": "Entity Provider Write Properties",
				"description": "Custom entity provider write properties applied to create, update, patch, batch and merge operations. For instance users can skip the Json object wrapper or enable content only mode when sending request data. A service URI set in the properties will always be overwritten by the serviceUri configuration parameter. Please consider to using the serviceUri configuration parameter instead of setting the respective write property here.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.olingo.odata2.api.ep.EntityProviderWriteProperties"
			},
			"filterAlreadySeen": {
				"title": "Filter Already Seen",
				"description": "Set this to true to filter out results that have already been communicated by this component.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"httpHeaders": {
				"title": "Http Headers",
				"description": "Custom HTTP headers to inject into every request, this could include OAuth tokens, etc.",
				"type": "object",
				"$comment": "group:common"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"proxy": {
				"title": "Proxy",
				"description": "HTTP proxy server configuration",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.http.HttpHost"
			},
			"serviceUri": {
				"title": "Service Uri",
				"description": "Target OData service base URI, e.g. http://services.odata.org/OData/OData.svc",
				"type": "string",
				"$comment": "group:common"
			},
			"socketTimeout": {
				"title": "Socket Timeout",
				"description": "HTTP request timeout in milliseconds, defaults to 30,000 (30 seconds)",
				"type": "integer",
				"$comment": "group:common",
				"default": 30000
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"splitResult": {
				"title": "Split Result",
				"description": "For endpoints that return an array or collection, a consumer endpoint will map every element to distinct messages, unless splitResult is set to false.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"httpAsyncClientBuilder": {
				"title": "Http Async Client Builder",
				"description": "Custom HTTP async client builder for more complex HTTP client configuration, overrides connectionTimeout, socketTimeout, proxy and sslContext. Note that a socketTimeout MUST be specified in the builder, otherwise OData requests could block indefinitely",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.http.impl.nio.client.HttpAsyncClientBuilder"
			},
			"httpClientBuilder": {
				"title": "Http Client Builder",
				"description": "Custom HTTP client builder for more complex HTTP client configuration, overrides connectionTimeout, socketTimeout, proxy and sslContext. Note that a socketTimeout MUST be specified in the builder, otherwise OData requests could block indefinitely",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.http.impl.client.HttpClientBuilder"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"olingo4": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"DEFAULT"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.olingo4.internal.Olingo4ApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"$comment": "group:common"
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "HTTP connection creation timeout in milliseconds, defaults to 30,000 (30 seconds)",
				"type": "integer",
				"$comment": "group:common",
				"default": 30000
			},
			"contentType": {
				"title": "Content Type",
				"description": "Content-Type header value can be used to specify JSON or XML message format, defaults to application/json;charset=utf-8",
				"type": "string",
				"$comment": "group:common",
				"default": "application/json;charset=utf-8"
			},
			"filterAlreadySeen": {
				"title": "Filter Already Seen",
				"description": "Set this to true to filter out results that have already been communicated by this component.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"httpHeaders": {
				"title": "Http Headers",
				"description": "Custom HTTP headers to inject into every request, this could include OAuth tokens, etc.",
				"type": "object",
				"$comment": "group:common"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"proxy": {
				"title": "Proxy",
				"description": "HTTP proxy server configuration",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.http.HttpHost"
			},
			"serviceUri": {
				"title": "Service Uri",
				"description": "Target OData service base URI, e.g. http://services.odata.org/OData/OData.svc",
				"type": "string",
				"$comment": "group:common"
			},
			"socketTimeout": {
				"title": "Socket Timeout",
				"description": "HTTP request timeout in milliseconds, defaults to 30,000 (30 seconds)",
				"type": "integer",
				"$comment": "group:common",
				"default": 30000
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"splitResult": {
				"title": "Split Result",
				"description": "For endpoints that return an array or collection, a consumer endpoint will map every element to distinct messages, unless splitResult is set to false.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"httpAsyncClientBuilder": {
				"title": "Http Async Client Builder",
				"description": "Custom HTTP async client builder for more complex HTTP client configuration, overrides connectionTimeout, socketTimeout, proxy and sslContext. Note that a socketTimeout MUST be specified in the builder, otherwise OData requests could block indefinitely",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.http.impl.nio.client.HttpAsyncClientBuilder"
			},
			"httpClientBuilder": {
				"title": "Http Client Builder",
				"description": "Custom HTTP client builder for more complex HTTP client configuration, overrides connectionTimeout, socketTimeout, proxy and sslContext. Note that a socketTimeout MUST be specified in the builder, otherwise OData requests could block indefinitely",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.http.impl.client.HttpClientBuilder"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"opensearch": {
		"properties": {
			"clusterName": {
				"title": "Cluster Name",
				"description": "Name of the cluster",
				"type": "string",
				"$comment": "group:producer"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "The time in ms to wait before connection will time out.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Disconnect after it finish calling the producer",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"from": {
				"title": "From",
				"description": "Starting index of the response.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"hostAddresses": {
				"title": "Host Addresses",
				"description": "Comma separated list with ip:port formatted remote transport addresses to use.",
				"type": "string",
				"$comment": "group:producer"
			},
			"indexName": {
				"title": "Index Name",
				"description": "The name of the index to act against",
				"type": "string",
				"$comment": "group:producer"
			},
			"maxRetryTimeout": {
				"title": "Max Retry Timeout",
				"description": "The time in ms before retry",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"operation": {
				"title": "Operation",
				"description": "What operation to perform",
				"type": "string",
				"enum": [
					"Index",
					"Update",
					"Bulk",
					"GetById",
					"MultiGet",
					"MultiSearch",
					"Delete",
					"DeleteIndex",
					"Search",
					"Exists",
					"Ping"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.opensearch.OpensearchOperation"
			},
			"scrollKeepAliveMs": {
				"title": "Scroll Keep Alive Ms",
				"description": "Time in ms during which OpenSearch will keep search context alive",
				"type": "integer",
				"$comment": "group:producer",
				"default": 60000
			},
			"size": {
				"title": "Size",
				"description": "Size of the response.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"socketTimeout": {
				"title": "Socket Timeout",
				"description": "The timeout in ms to wait before the socket will time out.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"useScroll": {
				"title": "Use Scroll",
				"description": "Enable scroll usage",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"waitForActiveShards": {
				"title": "Wait For Active Shards",
				"description": "Index creation waits for the write consistency number of shards to be available",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"documentClass": {
				"title": "Document Class",
				"description": "The class to use when deserializing the documents.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "ObjectNode"
			},
			"enableSniffer": {
				"title": "Enable Sniffer",
				"description": "Enable automatically discover nodes from a running OpenSearch cluster. If this option is used in conjunction with Spring Boot, then it's managed by the Spring Boot configuration (see: Disable Sniffer in Spring Boot).",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"hostnameVerifier": {
				"title": "Hostname Verifier",
				"description": "The class to use as HostnameVerifier. By default there is no HostnameVerifier.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.net.ssl.HostnameVerifier"
			},
			"sniffAfterFailureDelay": {
				"title": "Sniff After Failure Delay",
				"description": "The delay of a sniff execution scheduled after a failure (in milliseconds)",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 60000
			},
			"snifferInterval": {
				"title": "Sniffer Interval",
				"description": "The interval between consecutive ordinary sniff executions in milliseconds. Will be honoured when sniffOnFailure is disabled or when there are no failures between consecutive sniff executions",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 300000
			},
			"certificatePath": {
				"title": "Certificate Path",
				"description": "The certificate that can be used to access the ES Cluster. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:security"
			},
			"enableSSL": {
				"title": "Enable SSL",
				"description": "Enable SSL",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"clusterName"
		]
	},
	"openshift-build-configs": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer",
				"default": "tcp"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"openshift-builds": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:producer",
				"default": "tcp"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"openshift-deploymentconfigs": {
		"properties": {
			"masterUrl": {
				"title": "Master Url",
				"description": "URL to a remote Kubernetes API server. This should only be used when your Camel application is connecting from outside Kubernetes. If you run your Camel application inside Kubernetes, then you can use local or client as the URL to tell Camel to run in local mode. If you connect remotely to Kubernetes, then you may also need some of the many other configuration options for secured connection with certificates, etc.",
				"type": "string",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Kubernetes API Version to use",
				"type": "string",
				"$comment": "group:common"
			},
			"dnsDomain": {
				"title": "Dns Domain",
				"description": "The dns domain, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"kubernetesClient": {
				"title": "Kubernetes Client",
				"description": "Default KubernetesClient to use if provided",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:io.fabric8.kubernetes.client.KubernetesClient"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"portName": {
				"title": "Port Name",
				"description": "The port name, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common"
			},
			"portProtocol": {
				"title": "Port Protocol",
				"description": "The port protocol, used for ServiceCall EIP",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp"
			},
			"crdGroup": {
				"title": "Crd Group",
				"description": "The Consumer CRD Resource Group we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdName": {
				"title": "Crd Name",
				"description": "The Consumer CRD Resource name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdPlural": {
				"title": "Crd Plural",
				"description": "The Consumer CRD Resource Plural we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdScope": {
				"title": "Crd Scope",
				"description": "The Consumer CRD Resource Scope we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"crdVersion": {
				"title": "Crd Version",
				"description": "The Consumer CRD Resource Version we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelKey": {
				"title": "Label Key",
				"description": "The Consumer Label key when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"labelValue": {
				"title": "Label Value",
				"description": "The Consumer Label value when watching at some resources",
				"type": "string",
				"$comment": "group:consumer"
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Consumer pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"resourceName": {
				"title": "Resource Name",
				"description": "The Consumer Resource Name we would like to watch",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "Producer operation to do on Kubernetes",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Connection timeout in milliseconds to use when making requests to the Kubernetes API server.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"caCertData": {
				"title": "Ca Cert Data",
				"description": "The CA Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"caCertFile": {
				"title": "Ca Cert File",
				"description": "The CA Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertData": {
				"title": "Client Cert Data",
				"description": "The Client Cert Data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientCertFile": {
				"title": "Client Cert File",
				"description": "The Client Cert File",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyAlgo": {
				"title": "Client Key Algo",
				"description": "The Key Algorithm used by the client",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyData": {
				"title": "Client Key Data",
				"description": "The Client Key data",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyFile": {
				"title": "Client Key File",
				"description": "The Client Key file",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientKeyPassphrase": {
				"title": "Client Key Passphrase",
				"description": "The Client Key Passphrase",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The Auth Token",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"trustCerts": {
				"title": "Trust Certs",
				"description": "Define if the certs we used are trusted anyway or not",
				"type": "boolean",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to connect to Kubernetes",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"masterUrl"
		]
	},
	"openstack-cinder": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "OpenStack host url",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "OpenStack API version",
				"type": "string",
				"enum": [
					"V2",
					"V3"
				],
				"$comment": "group:producer",
				"default": "V3"
			},
			"config": {
				"title": "Config",
				"description": "OpenStack configuration",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.openstack4j.core.transport.Config"
			},
			"domain": {
				"title": "Domain",
				"description": "Authentication domain",
				"type": "string",
				"$comment": "group:producer",
				"default": "default"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do",
				"type": "string",
				"$comment": "group:producer"
			},
			"password": {
				"title": "Password",
				"description": "OpenStack password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"project": {
				"title": "Project",
				"description": "The project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"subsystem": {
				"title": "Subsystem",
				"description": "OpenStack Cinder subsystem",
				"type": "string",
				"enum": [
					"snapshots",
					"volumes"
				],
				"$comment": "group:producer"
			},
			"username": {
				"title": "Username",
				"description": "OpenStack username",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"password",
			"project",
			"subsystem",
			"username"
		]
	},
	"openstack-glance": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "OpenStack host url",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "OpenStack API version",
				"type": "string",
				"enum": [
					"V2",
					"V3"
				],
				"$comment": "group:producer",
				"default": "V3"
			},
			"config": {
				"title": "Config",
				"description": "OpenStack configuration",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.openstack4j.core.transport.Config"
			},
			"domain": {
				"title": "Domain",
				"description": "Authentication domain",
				"type": "string",
				"$comment": "group:producer",
				"default": "default"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do",
				"type": "string",
				"$comment": "group:producer"
			},
			"password": {
				"title": "Password",
				"description": "OpenStack password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"project": {
				"title": "Project",
				"description": "The project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"username": {
				"title": "Username",
				"description": "OpenStack username",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"password",
			"project",
			"username"
		]
	},
	"openstack-keystone": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "OpenStack host url",
				"type": "string",
				"$comment": "group:producer"
			},
			"config": {
				"title": "Config",
				"description": "OpenStack configuration",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.openstack4j.core.transport.Config"
			},
			"domain": {
				"title": "Domain",
				"description": "Authentication domain",
				"type": "string",
				"$comment": "group:producer",
				"default": "default"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do",
				"type": "string",
				"$comment": "group:producer"
			},
			"password": {
				"title": "Password",
				"description": "OpenStack password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"project": {
				"title": "Project",
				"description": "The project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"subsystem": {
				"title": "Subsystem",
				"description": "OpenStack Keystone subsystem",
				"type": "string",
				"enum": [
					"regions",
					"domains",
					"projects",
					"users",
					"groups"
				],
				"$comment": "group:producer"
			},
			"username": {
				"title": "Username",
				"description": "OpenStack username",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"password",
			"project",
			"subsystem",
			"username"
		]
	},
	"openstack-neutron": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "OpenStack host url",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "OpenStack API version",
				"type": "string",
				"enum": [
					"V2",
					"V3"
				],
				"$comment": "group:producer",
				"default": "V3"
			},
			"config": {
				"title": "Config",
				"description": "OpenStack configuration",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.openstack4j.core.transport.Config"
			},
			"domain": {
				"title": "Domain",
				"description": "Authentication domain",
				"type": "string",
				"$comment": "group:producer",
				"default": "default"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do",
				"type": "string",
				"$comment": "group:producer"
			},
			"password": {
				"title": "Password",
				"description": "OpenStack password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"project": {
				"title": "Project",
				"description": "The project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"subsystem": {
				"title": "Subsystem",
				"description": "OpenStack Neutron subsystem",
				"type": "string",
				"enum": [
					"networks",
					"subnets",
					"ports",
					"routers"
				],
				"$comment": "group:producer"
			},
			"username": {
				"title": "Username",
				"description": "OpenStack username",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"password",
			"project",
			"subsystem",
			"username"
		]
	},
	"openstack-nova": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "OpenStack host url",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "OpenStack API version",
				"type": "string",
				"enum": [
					"V2",
					"V3"
				],
				"$comment": "group:producer",
				"default": "V3"
			},
			"config": {
				"title": "Config",
				"description": "OpenStack configuration",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.openstack4j.core.transport.Config"
			},
			"domain": {
				"title": "Domain",
				"description": "Authentication domain",
				"type": "string",
				"$comment": "group:producer",
				"default": "default"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do",
				"type": "string",
				"$comment": "group:producer"
			},
			"password": {
				"title": "Password",
				"description": "OpenStack password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"project": {
				"title": "Project",
				"description": "The project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"subsystem": {
				"title": "Subsystem",
				"description": "OpenStack Nova subsystem",
				"type": "string",
				"enum": [
					"flavors",
					"servers",
					"keypairs"
				],
				"$comment": "group:producer"
			},
			"username": {
				"title": "Username",
				"description": "OpenStack username",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"password",
			"project",
			"subsystem",
			"username"
		]
	},
	"openstack-swift": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "OpenStack host url",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "OpenStack API version",
				"type": "string",
				"enum": [
					"V2",
					"V3"
				],
				"$comment": "group:producer",
				"default": "V3"
			},
			"config": {
				"title": "Config",
				"description": "OpenStack configuration",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.openstack4j.core.transport.Config"
			},
			"domain": {
				"title": "Domain",
				"description": "Authentication domain",
				"type": "string",
				"$comment": "group:producer",
				"default": "default"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to do",
				"type": "string",
				"$comment": "group:producer"
			},
			"password": {
				"title": "Password",
				"description": "OpenStack password",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"project": {
				"title": "Project",
				"description": "The project ID",
				"type": "string",
				"$comment": "group:producer"
			},
			"subsystem": {
				"title": "Subsystem",
				"description": "OpenStack Swift subsystem",
				"type": "string",
				"enum": [
					"objects",
					"containers"
				],
				"$comment": "group:producer"
			},
			"username": {
				"title": "Username",
				"description": "OpenStack username",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"password",
			"project",
			"subsystem",
			"username"
		]
	},
	"optaplanner": {
		"properties": {
			"problemName": {
				"title": "Problem Name",
				"description": "Problem name",
				"type": "string",
				"$comment": "group:common"
			},
			"configFile": {
				"title": "Config File",
				"description": "If SolverManager is absent from the header OptaPlannerConstants.SOLVER_MANAGER then a SolverManager will be created using this Optaplanner config file.",
				"type": "string",
				"$comment": "group:common"
			},
			"problemId": {
				"title": "Problem Id",
				"description": "In case of using SolverManager : the problem id",
				"type": "integer",
				"$comment": "group:common",
				"default": "1L"
			},
			"solverId": {
				"title": "Solver Id",
				"description": "Specifies the solverId to user for the solver instance key",
				"type": "string",
				"$comment": "group:common",
				"default": "DEFAULT_SOLVER"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"async": {
				"title": "Async",
				"description": "Specifies to perform operations in async mode",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"threadPoolSize": {
				"title": "Thread Pool Size",
				"description": "Specifies the thread pool size to use when async is true",
				"type": "integer",
				"$comment": "group:producer",
				"default": 10
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"solverManager": {
				"title": "Solver Manager",
				"description": "SolverManager",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.optaplanner.core.api.solver.SolverManager"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"problemName"
		]
	},
	"paho": {
		"properties": {
			"topic": {
				"title": "Topic",
				"description": "Name of the topic",
				"type": "string",
				"$comment": "group:common"
			},
			"automaticReconnect": {
				"title": "Automatic Reconnect",
				"description": "Sets whether the client will automatically attempt to reconnect to the server if the connection is lost. If set to false, the client will not attempt to automatically reconnect to the server in the event that the connection is lost. If set to true, in the event that the connection is lost, the client will attempt to reconnect to the server. It will initially wait 1 second before it attempts to reconnect, for every failed reconnect attempt, the delay will double until it is at 2 minutes at which point the delay will stay at 2 minutes.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"brokerUrl": {
				"title": "Broker Url",
				"description": "The URL of the MQTT broker.",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp://localhost:1883"
			},
			"cleanSession": {
				"title": "Clean Session",
				"description": "Sets whether the client and server should remember state across restarts and reconnects. If set to false both the client and server will maintain state across restarts of the client, the server and the connection. As state is maintained: Message delivery will be reliable meeting the specified QOS even if the client, server or connection are restarted. The server will treat a subscription as durable. If set to true the client and server will not maintain state across restarts of the client, the server or the connection. This means Message delivery to the specified QOS cannot be maintained if the client, server or connection are restarted The server will treat a subscription as non-durable",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"clientId": {
				"title": "Client Id",
				"description": "MQTT client identifier. The identifier must be unique.",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Sets the connection timeout value. This value, measured in seconds, defines the maximum time interval the client will wait for the network connection to the MQTT server to be established. The default timeout is 30 seconds. A value of 0 disables timeout processing meaning the client will wait until the network connection is made successfully or fails.",
				"type": "integer",
				"$comment": "group:common",
				"default": 30
			},
			"filePersistenceDirectory": {
				"title": "File Persistence Directory",
				"description": "Base directory used by file persistence. Will by default use user directory.",
				"type": "string",
				"$comment": "group:common"
			},
			"keepAliveInterval": {
				"title": "Keep Alive Interval",
				"description": "Sets the keep alive interval. This value, measured in seconds, defines the maximum time interval between messages sent or received. It enables the client to detect if the server is no longer available, without having to wait for the TCP/IP timeout. The client will ensure that at least one message travels across the network within each keep alive period. In the absence of a data-related message during the time period, the client sends a very small ping message, which the server will acknowledge. A value of 0 disables keepalive processing in the client. The default value is 60 seconds",
				"type": "integer",
				"$comment": "group:common",
				"default": 60
			},
			"maxInflight": {
				"title": "Max Inflight",
				"description": "Sets the max inflight. please increase this value in a high traffic environment. The default value is 10",
				"type": "integer",
				"$comment": "group:common",
				"default": 10
			},
			"maxReconnectDelay": {
				"title": "Max Reconnect Delay",
				"description": "Get the maximum time (in millis) to wait between reconnects",
				"type": "integer",
				"$comment": "group:common",
				"default": 128000
			},
			"mqttVersion": {
				"title": "Mqtt Version",
				"description": "Sets the MQTT version. The default action is to connect with version 3.1.1, and to fall back to 3.1 if that fails. Version 3.1.1 or 3.1 can be selected specifically, with no fall back, by using the MQTT_VERSION_3_1_1 or MQTT_VERSION_3_1 options respectively.",
				"type": "integer",
				"$comment": "group:common"
			},
			"persistence": {
				"title": "Persistence",
				"description": "Client persistence to be used - memory or file.",
				"type": "string",
				"enum": [
					"FILE",
					"MEMORY"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.paho.PahoPersistence",
				"default": "MEMORY"
			},
			"qos": {
				"title": "Qos",
				"description": "Client quality of service level (0-2).",
				"type": "integer",
				"$comment": "group:common",
				"default": 2
			},
			"retained": {
				"title": "Retained",
				"description": "Retain option",
				"type": "boolean",
				"$comment": "group:common"
			},
			"serverURIs": {
				"title": "Server URIs",
				"description": "Set a list of one or more serverURIs the client may connect to. Multiple servers can be separated by comma. Each serverURI specifies the address of a server that the client may connect to. Two types of connection are supported tcp:// for a TCP connection and ssl:// for a TCP connection secured by SSL/TLS. For example: tcp://localhost:1883 ssl://localhost:8883 If the port is not specified, it will default to 1883 for tcp:// URIs, and 8883 for ssl:// URIs. If serverURIs is set then it overrides the serverURI parameter passed in on the constructor of the MQTT client. When an attempt to connect is initiated the client will start with the first serverURI in the list and work through the list until a connection is established with a server. If a connection cannot be made to any of the servers then the connect attempt fails. Specifying a list of servers that a client may connect to has several uses: High Availability and reliable message delivery Some MQTT servers support a high availability feature where two or more equal MQTT servers share state. An MQTT client can connect to any of the equal servers and be assured that messages are reliably delivered and durable subscriptions are maintained no matter which server the client connects to. The cleansession flag must be set to false if durable subscriptions and/or reliable message delivery is required. Hunt List A set of servers may be specified that are not equal (as in the high availability option). As no state is shared across the servers reliable message delivery and durable subscriptions are not valid. The cleansession flag must be set to true if the hunt list mode is used",
				"type": "string",
				"$comment": "group:common"
			},
			"willPayload": {
				"title": "Will Payload",
				"description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Sets the message for the LWT.",
				"type": "string",
				"$comment": "group:common"
			},
			"willQos": {
				"title": "Will Qos",
				"description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Sets the quality of service to publish the message at (0, 1 or 2).",
				"type": "integer",
				"$comment": "group:common"
			},
			"willRetained": {
				"title": "Will Retained",
				"description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Sets whether or not the message should be retained.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"willTopic": {
				"title": "Will Topic",
				"description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Sets the topic that the willPayload will be published to.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"client": {
				"title": "Client",
				"description": "To use an existing mqtt client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.eclipse.paho.client.mqttv3.MqttClient"
			},
			"customWebSocketHeaders": {
				"title": "Custom Web Socket Headers",
				"description": "Sets the Custom WebSocket Headers for the WebSocket Connection.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"executorServiceTimeout": {
				"title": "Executor Service Timeout",
				"description": "Set the time in seconds that the executor service should wait when terminating before forcefully terminating. It is not recommended to change this value unless you are absolutely sure that you need to.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"httpsHostnameVerificationEnabled": {
				"title": "Https Hostname Verification Enabled",
				"description": "Whether SSL HostnameVerifier is enabled or not. The default value is true.",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password to be used for authentication against the MQTT broker",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"socketFactory": {
				"title": "Socket Factory",
				"description": "Sets the SocketFactory to use. This allows an application to apply its own policies around the creation of network sockets. If using an SSL connection, an SSLSocketFactory can be used to supply application-specific security settings.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:javax.net.SocketFactory"
			},
			"sslClientProps": {
				"title": "Ssl Client Props",
				"description": "Sets the SSL properties for the connection. Note that these properties are only valid if an implementation of the Java Secure Socket Extensions (JSSE) is available. These properties are not used if a custom SocketFactory has been set. The following properties can be used: com.ibm.ssl.protocol One of: SSL, SSLv3, TLS, TLSv1, SSL_TLS. com.ibm.ssl.contextProvider Underlying JSSE provider. For example IBMJSSE2 or SunJSSE com.ibm.ssl.keyStore The name of the file that contains the KeyStore object that you want the KeyManager to use. For example /mydir/etc/key.p12 com.ibm.ssl.keyStorePassword The password for the KeyStore object that you want the KeyManager to use. The password can either be in plain-text, or may be obfuscated using the static method: com.ibm.micro.security.Password.obfuscate(char password). This obfuscates the password using a simple and insecure XOR and Base64 encoding mechanism. Note that this is only a simple scrambler to obfuscate clear-text passwords. com.ibm.ssl.keyStoreType Type of key store, for example PKCS12, JKS, or JCEKS. com.ibm.ssl.keyStoreProvider Key store provider, for example IBMJCE or IBMJCEFIPS. com.ibm.ssl.trustStore The name of the file that contains the KeyStore object that you want the TrustManager to use. com.ibm.ssl.trustStorePassword The password for the TrustStore object that you want the TrustManager to use. The password can either be in plain-text, or may be obfuscated using the static method: com.ibm.micro.security.Password.obfuscate(char password). This obfuscates the password using a simple and insecure XOR and Base64 encoding mechanism. Note that this is only a simple scrambler to obfuscate clear-text passwords. com.ibm.ssl.trustStoreType The type of KeyStore object that you want the default TrustManager to use. Same possible values as keyStoreType. com.ibm.ssl.trustStoreProvider Trust store provider, for example IBMJCE or IBMJCEFIPS. com.ibm.ssl.enabledCipherSuites A list of which ciphers are enabled. Values are dependent on the provider, for example: SSL_RSA_WITH_AES_128_CBC_SHA;SSL_RSA_WITH_3DES_EDE_CBC_SHA. com.ibm.ssl.keyManager Sets the algorithm that will be used to instantiate a KeyManagerFactory object instead of using the default algorithm available in the platform. Example values: IbmX509 or IBMJ9X509. com.ibm.ssl.trustManager Sets the algorithm that will be used to instantiate a TrustManagerFactory object instead of using the default algorithm available in the platform. Example values: PKIX or IBMJ9X509.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.util.Properties"
			},
			"sslHostnameVerifier": {
				"title": "Ssl Hostname Verifier",
				"description": "Sets the HostnameVerifier for the SSL connection. Note that it will be used after handshake on a connection and you should do actions by yourself when hostname is verified error. There is no default HostnameVerifier",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:javax.net.ssl.HostnameVerifier"
			},
			"userName": {
				"title": "User Name",
				"description": "Username to be used for authentication against the MQTT broker",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"topic"
		]
	},
	"paho-mqtt5": {
		"properties": {
			"topic": {
				"title": "Topic",
				"description": "Name of the topic",
				"type": "string",
				"$comment": "group:common"
			},
			"automaticReconnect": {
				"title": "Automatic Reconnect",
				"description": "Sets whether the client will automatically attempt to reconnect to the server if the connection is lost. If set to false, the client will not attempt to automatically reconnect to the server in the event that the connection is lost. If set to true, in the event that the connection is lost, the client will attempt to reconnect to the server. It will initially wait 1 second before it attempts to reconnect, for every failed reconnect attempt, the delay will double until it is at 2 minutes at which point the delay will stay at 2 minutes.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"brokerUrl": {
				"title": "Broker Url",
				"description": "The URL of the MQTT broker.",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp://localhost:1883"
			},
			"cleanStart": {
				"title": "Clean Start",
				"description": "Sets whether the client and server should remember state across restarts and reconnects. If set to false both the client and server will maintain state across restarts of the client, the server and the connection. As state is maintained: Message delivery will be reliable meeting the specified QOS even if the client, server or connection are restarted. The server will treat a subscription as durable. If set to true the client and server will not maintain state across restarts of the client, the server or the connection. This means Message delivery to the specified QOS cannot be maintained if the client, server or connection are restarted The server will treat a subscription as non-durable",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"clientId": {
				"title": "Client Id",
				"description": "MQTT client identifier. The identifier must be unique.",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Sets the connection timeout value. This value, measured in seconds, defines the maximum time interval the client will wait for the network connection to the MQTT server to be established. The default timeout is 30 seconds. A value of 0 disables timeout processing meaning the client will wait until the network connection is made successfully or fails.",
				"type": "integer",
				"$comment": "group:common",
				"default": 30
			},
			"filePersistenceDirectory": {
				"title": "File Persistence Directory",
				"description": "Base directory used by file persistence. Will by default use user directory.",
				"type": "string",
				"$comment": "group:common"
			},
			"keepAliveInterval": {
				"title": "Keep Alive Interval",
				"description": "Sets the keep alive interval. This value, measured in seconds, defines the maximum time interval between messages sent or received. It enables the client to detect if the server is no longer available, without having to wait for the TCP/IP timeout. The client will ensure that at least one message travels across the network within each keep alive period. In the absence of a data-related message during the time period, the client sends a very small ping message, which the server will acknowledge. A value of 0 disables keepalive processing in the client. The default value is 60 seconds",
				"type": "integer",
				"$comment": "group:common",
				"default": 60
			},
			"maxReconnectDelay": {
				"title": "Max Reconnect Delay",
				"description": "Get the maximum time (in millis) to wait between reconnects",
				"type": "integer",
				"$comment": "group:common",
				"default": 128000
			},
			"persistence": {
				"title": "Persistence",
				"description": "Client persistence to be used - memory or file.",
				"type": "string",
				"enum": [
					"FILE",
					"MEMORY"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.paho.mqtt5.PahoMqtt5Persistence",
				"default": "MEMORY"
			},
			"qos": {
				"title": "Qos",
				"description": "Client quality of service level (0-2).",
				"type": "integer",
				"$comment": "group:common",
				"default": 2
			},
			"receiveMaximum": {
				"title": "Receive Maximum",
				"description": "Sets the Receive Maximum. This value represents the limit of QoS 1 and QoS 2 publications that the client is willing to process concurrently. There is no mechanism to limit the number of QoS 0 publications that the Server might try to send. The default value is 65535",
				"type": "integer",
				"$comment": "group:common",
				"default": 65535
			},
			"retained": {
				"title": "Retained",
				"description": "Retain option",
				"type": "boolean",
				"$comment": "group:common"
			},
			"serverURIs": {
				"title": "Server URIs",
				"description": "Set a list of one or more serverURIs the client may connect to. Multiple servers can be separated by comma. Each serverURI specifies the address of a server that the client may connect to. Two types of connection are supported tcp:// for a TCP connection and ssl:// for a TCP connection secured by SSL/TLS. For example: tcp://localhost:1883 ssl://localhost:8883 If the port is not specified, it will default to 1883 for tcp:// URIs, and 8883 for ssl:// URIs. If serverURIs is set then it overrides the serverURI parameter passed in on the constructor of the MQTT client. When an attempt to connect is initiated the client will start with the first serverURI in the list and work through the list until a connection is established with a server. If a connection cannot be made to any of the servers then the connect attempt fails. Specifying a list of servers that a client may connect to has several uses: High Availability and reliable message delivery Some MQTT servers support a high availability feature where two or more equal MQTT servers share state. An MQTT client can connect to any of the equal servers and be assured that messages are reliably delivered and durable subscriptions are maintained no matter which server the client connects to. The cleansession flag must be set to false if durable subscriptions and/or reliable message delivery is required. Hunt List A set of servers may be specified that are not equal (as in the high availability option). As no state is shared across the servers reliable message delivery and durable subscriptions are not valid. The cleansession flag must be set to true if the hunt list mode is used",
				"type": "string",
				"$comment": "group:common"
			},
			"sessionExpiryInterval": {
				"title": "Session Expiry Interval",
				"description": "Sets the Session Expiry Interval. This value, measured in seconds, defines the maximum time that the broker will maintain the session for once the client disconnects. Clients should only connect with a long Session Expiry interval if they intend to connect to the server at some later point in time. By default this value is -1 and so will not be sent, in this case, the session will not expire. If a 0 is sent, the session will end immediately once the Network Connection is closed. When the client has determined that it has no longer any use for the session, it should disconnect with a Session Expiry Interval set to 0.",
				"type": "integer",
				"$comment": "group:common",
				"default": -1
			},
			"willMqttProperties": {
				"title": "Will Mqtt Properties",
				"description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The MQTT properties set for the message.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.eclipse.paho.mqttv5.common.packet.MqttProperties"
			},
			"willPayload": {
				"title": "Will Payload",
				"description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The byte payload for the message.",
				"type": "string",
				"$comment": "group:common"
			},
			"willQos": {
				"title": "Will Qos",
				"description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The quality of service to publish the message at (0, 1 or 2).",
				"type": "integer",
				"$comment": "group:common",
				"default": 1
			},
			"willRetained": {
				"title": "Will Retained",
				"description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. Whether or not the message should be retained.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"willTopic": {
				"title": "Will Topic",
				"description": "Sets the Last Will and Testament (LWT) for the connection. In the event that this client unexpectedly loses its connection to the server, the server will publish a message to itself using the supplied details. The topic to publish to.",
				"type": "string",
				"$comment": "group:common"
			},
			"manualAcksEnabled": {
				"title": "Manual Acks Enabled",
				"description": "Sets whether to use manual acknowledgements for the client. By default, this is false and message will be automatically acknowledged upon received by Camel. If set to true, the acknowledgement is deferred to be acknowledged by Camel at the end of processing the message. This ensures that only successfully processed messages is acknowledged, and allows to rollback and retry the message in case of an error during routing in Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"client": {
				"title": "Client",
				"description": "To use an existing mqtt client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.eclipse.paho.mqttv5.client.MqttClient"
			},
			"customWebSocketHeaders": {
				"title": "Custom Web Socket Headers",
				"description": "Sets the Custom WebSocket Headers for the WebSocket Connection.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"executorServiceTimeout": {
				"title": "Executor Service Timeout",
				"description": "Set the time in seconds that the executor service should wait when terminating before forcefully terminating. It is not recommended to change this value unless you are absolutely sure that you need to.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"httpsHostnameVerificationEnabled": {
				"title": "Https Hostname Verification Enabled",
				"description": "Whether SSL HostnameVerifier is enabled or not. The default value is true.",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password to be used for authentication against the MQTT broker",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"socketFactory": {
				"title": "Socket Factory",
				"description": "Sets the SocketFactory to use. This allows an application to apply its own policies around the creation of network sockets. If using an SSL connection, an SSLSocketFactory can be used to supply application-specific security settings.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:javax.net.SocketFactory"
			},
			"sslClientProps": {
				"title": "Ssl Client Props",
				"description": "Sets the SSL properties for the connection. Note that these properties are only valid if an implementation of the Java Secure Socket Extensions (JSSE) is available. These properties are not used if a custom SocketFactory has been set. The following properties can be used: com.ibm.ssl.protocol One of: SSL, SSLv3, TLS, TLSv1, SSL_TLS. com.ibm.ssl.contextProvider Underlying JSSE provider. For example IBMJSSE2 or SunJSSE com.ibm.ssl.keyStore The name of the file that contains the KeyStore object that you want the KeyManager to use. For example /mydir/etc/key.p12 com.ibm.ssl.keyStorePassword The password for the KeyStore object that you want the KeyManager to use. The password can either be in plain-text, or may be obfuscated using the static method: com.ibm.micro.security.Password.obfuscate(char password). This obfuscates the password using a simple and insecure XOR and Base64 encoding mechanism. Note that this is only a simple scrambler to obfuscate clear-text passwords. com.ibm.ssl.keyStoreType Type of key store, for example PKCS12, JKS, or JCEKS. com.ibm.ssl.keyStoreProvider Key store provider, for example IBMJCE or IBMJCEFIPS. com.ibm.ssl.trustStore The name of the file that contains the KeyStore object that you want the TrustManager to use. com.ibm.ssl.trustStorePassword The password for the TrustStore object that you want the TrustManager to use. The password can either be in plain-text, or may be obfuscated using the static method: com.ibm.micro.security.Password.obfuscate(char password). This obfuscates the password using a simple and insecure XOR and Base64 encoding mechanism. Note that this is only a simple scrambler to obfuscate clear-text passwords. com.ibm.ssl.trustStoreType The type of KeyStore object that you want the default TrustManager to use. Same possible values as keyStoreType. com.ibm.ssl.trustStoreProvider Trust store provider, for example IBMJCE or IBMJCEFIPS. com.ibm.ssl.enabledCipherSuites A list of which ciphers are enabled. Values are dependent on the provider, for example: SSL_RSA_WITH_AES_128_CBC_SHA;SSL_RSA_WITH_3DES_EDE_CBC_SHA. com.ibm.ssl.keyManager Sets the algorithm that will be used to instantiate a KeyManagerFactory object instead of using the default algorithm available in the platform. Example values: IbmX509 or IBMJ9X509. com.ibm.ssl.trustManager Sets the algorithm that will be used to instantiate a TrustManagerFactory object instead of using the default algorithm available in the platform. Example values: PKIX or IBMJ9X509.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.util.Properties"
			},
			"sslHostnameVerifier": {
				"title": "Ssl Hostname Verifier",
				"description": "Sets the HostnameVerifier for the SSL connection. Note that it will be used after handshake on a connection and you should do actions by yourself when hostname is verified error. There is no default HostnameVerifier",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:javax.net.ssl.HostnameVerifier"
			},
			"userName": {
				"title": "User Name",
				"description": "Username to be used for authentication against the MQTT broker",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"topic"
		]
	},
	"pdf": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "Operation type",
				"type": "string",
				"enum": [
					"create",
					"append",
					"extractText",
					"merge"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.pdf.PdfOperation"
			},
			"font": {
				"title": "Font",
				"description": "Font",
				"type": "string",
				"enum": [
					"COURIER",
					"COURIER_BOLD",
					"COURIER_OBLIQUE",
					"COURIER_BOLD_OBLIQUE",
					"HELVETICA",
					"HELVETICA_BOLD",
					"HELVETICA_OBLIQUE",
					"HELVETICA_BOLD_OBLIQUE",
					"TIMES_ROMAN",
					"TIMES_BOLD",
					"TIMES_ITALIC",
					"TIMES_BOLD_ITALIC",
					"SYMBOL",
					"ZAPF_DINGBATS"
				],
				"$comment": "group:producer",
				"default": "HELVETICA"
			},
			"fontSize": {
				"title": "Font Size",
				"description": "Font size in pixels",
				"type": "number",
				"$comment": "group:producer",
				"default": "14.0"
			},
			"marginBottom": {
				"title": "Margin Bottom",
				"description": "Margin bottom in pixels",
				"type": "integer",
				"$comment": "group:producer",
				"default": 20
			},
			"marginLeft": {
				"title": "Margin Left",
				"description": "Margin left in pixels",
				"type": "integer",
				"$comment": "group:producer",
				"default": 20
			},
			"marginRight": {
				"title": "Margin Right",
				"description": "Margin right in pixels",
				"type": "integer",
				"$comment": "group:producer",
				"default": 40
			},
			"marginTop": {
				"title": "Margin Top",
				"description": "Margin top in pixels",
				"type": "integer",
				"$comment": "group:producer",
				"default": 20
			},
			"pageSize": {
				"title": "Page Size",
				"description": "Page size",
				"type": "string",
				"enum": [
					"LETTER",
					"LEGAL",
					"A0",
					"A1",
					"A2",
					"A3",
					"A4",
					"A5",
					"A6"
				],
				"$comment": "group:producer",
				"default": "A4"
			},
			"textProcessingFactory": {
				"title": "Text Processing Factory",
				"description": "Text processing to use. autoFormatting: Text is getting sliced by words, then max amount of words that fits in the line will be written into pdf document. With this strategy all words that doesn't fit in the line will be moved to the new line. lineTermination: Builds set of classes for line-termination writing strategy. Text getting sliced by line termination symbol and then it will be written regardless it fits in the line or not.",
				"type": "string",
				"enum": [
					"autoFormatting",
					"lineTermination"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.pdf.TextProcessingFactory",
				"default": "lineTermination"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation"
		]
	},
	"pg-replication-slot": {
		"properties": {
			"slot": {
				"title": "Slot",
				"description": "Replication Slot name",
				"type": "string",
				"$comment": "group:common"
			},
			"host": {
				"title": "Host",
				"description": "Postgres host",
				"type": "string",
				"$comment": "group:common",
				"default": "localhost"
			},
			"port": {
				"title": "Port",
				"description": "Postgres port",
				"type": "integer",
				"$comment": "group:common",
				"default": "5432"
			},
			"database": {
				"title": "Database",
				"description": "Postgres database name",
				"type": "string",
				"$comment": "group:common"
			},
			"outputPlugin": {
				"title": "Output Plugin",
				"description": "Output plugin name",
				"type": "string",
				"$comment": "group:common"
			},
			"password": {
				"title": "Password",
				"description": "Postgres password",
				"type": "string",
				"$comment": "group:common",
				"format": "password"
			},
			"user": {
				"title": "User",
				"description": "Postgres user",
				"type": "string",
				"$comment": "group:common",
				"default": "postgres"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"autoCreateSlot": {
				"title": "Auto Create Slot",
				"description": "Auto create slot if it does not exist",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"slotOptions": {
				"title": "Slot Options",
				"description": "Slot options to be passed to the output plugin.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"statusInterval": {
				"title": "Status Interval",
				"description": "Specifies the number of seconds between status packets sent back to Postgres server.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "10"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"slot",
			"database",
			"outputPlugin"
		]
	},
	"pgevent": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "To connect using hostname and port to the database.",
				"type": "string",
				"$comment": "group:common",
				"default": "localhost"
			},
			"port": {
				"title": "Port",
				"description": "To connect using hostname and port to the database.",
				"type": "integer",
				"$comment": "group:common",
				"default": "5432"
			},
			"database": {
				"title": "Database",
				"description": "The database name. The database name can take any characters because it is sent as a quoted identifier. It is part of the endpoint URI, so diacritical marks and non-Latin letters have to be URL encoded.",
				"type": "string",
				"$comment": "group:common"
			},
			"channel": {
				"title": "Channel",
				"description": "The channel name",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"datasource": {
				"title": "Datasource",
				"description": "To connect using the given javax.sql.DataSource instead of using hostname and port.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.sql.DataSource"
			},
			"pass": {
				"title": "Pass",
				"description": "Password for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"user": {
				"title": "User",
				"description": "Username for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password",
				"default": "postgres"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"database",
			"channel"
		]
	},
	"pinecone": {
		"properties": {
			"collection": {
				"title": "Collection",
				"description": "The collection Name",
				"type": "string",
				"$comment": "group:producer"
			},
			"cloud": {
				"title": "Cloud",
				"description": "Sets the cloud type to use (aws/gcp/azure)",
				"type": "string",
				"$comment": "group:producer"
			},
			"cloudRegion": {
				"title": "Cloud Region",
				"description": "Sets the cloud region",
				"type": "string",
				"$comment": "group:producer"
			},
			"collectionDimension": {
				"title": "Collection Dimension",
				"description": "Sets the Collection Dimension to use (1-1536)",
				"type": "integer",
				"$comment": "group:producer",
				"default": "1536"
			},
			"collectionSimilarityMetric": {
				"title": "Collection Similarity Metric",
				"description": "Sets the Collection Similarity Metric to use (cosine/euclidean/dotproduct)",
				"type": "string",
				"$comment": "group:producer"
			},
			"host": {
				"title": "Host",
				"description": "Sets a custom host URL to connect to",
				"type": "string",
				"$comment": "group:producer"
			},
			"indexName": {
				"title": "Index Name",
				"description": "Sets the index name to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "Set the proxy host",
				"type": "string",
				"$comment": "group:producer"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "Set the proxy port",
				"type": "integer",
				"$comment": "group:producer"
			},
			"tls": {
				"title": "Tls",
				"description": "Whether the client uses Transport Layer Security (TLS) to secure communications",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"token": {
				"title": "Token",
				"description": "Sets the API key to use for authentication",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"collection"
		]
	},
	"platform-http": {
		"properties": {
			"path": {
				"title": "Path",
				"description": "The path under which this endpoint serves the HTTP requests, for proxy use 'proxy'",
				"type": "string",
				"$comment": "group:consumer"
			},
			"consumes": {
				"title": "Consumes",
				"description": "The content type this endpoint accepts as an input, such as application/xml or application/json. null or &#42;/&#42; mean no restriction.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"cookieDomain": {
				"title": "Cookie Domain",
				"description": "Sets which server can receive cookies.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"cookieHttpOnly": {
				"title": "Cookie Http Only",
				"description": "Sets whether to prevent client side scripts from accessing created cookies.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"cookieMaxAge": {
				"title": "Cookie Max Age",
				"description": "Sets the maximum cookie age in seconds.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"cookiePath": {
				"title": "Cookie Path",
				"description": "Sets the URL path that must exist in the requested URL in order to send the Cookie.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "/"
			},
			"cookieSameSite": {
				"title": "Cookie Same Site",
				"description": "Sets whether to prevent the browser from sending cookies along with cross-site requests.",
				"type": "string",
				"enum": [
					"STRICT",
					"LAX",
					"NONE"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.platform.http.cookie.CookieConfiguration.CookieSameSite",
				"default": "Lax"
			},
			"cookieSecure": {
				"title": "Cookie Secure",
				"description": "Sets whether the cookie is only sent to the server with an encrypted request over HTTPS.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"handleWriteResponseError": {
				"title": "Handle Write Response Error",
				"description": "When Camel is complete processing the message, and the HTTP server is writing response. This option controls whether Camel should catch any failure during writing response and store this on the Exchange, which allows onCompletion/UnitOfWork to regard the Exchange as failed and have access to the caused exception from the HTTP server.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"httpMethodRestrict": {
				"title": "Http Method Restrict",
				"description": "A comma separated list of HTTP methods to serve, e.g. GET,POST . If no methods are specified, all methods will be served.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"matchOnUriPrefix": {
				"title": "Match On Uri Prefix",
				"description": "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"muteException": {
				"title": "Mute Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"populateBodyWithForm": {
				"title": "Populate Body With Form",
				"description": "Whether to populate the message Body with a Map containing application/x-www-form-urlencoded form properties.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"produces": {
				"title": "Produces",
				"description": "The content type this endpoint produces, such as application/xml or application/json.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"returnHttpRequestHeaders": {
				"title": "Return Http Request Headers",
				"description": "Whether to include HTTP request headers (Accept, User-Agent, etc.) into HTTP response produced by this endpoint.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"useCookieHandler": {
				"title": "Use Cookie Handler",
				"description": "Whether to enable the Cookie Handler that allows Cookie addition, expiry, and retrieval (currently only supported by camel-platform-http-vertx)",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"useStreaming": {
				"title": "Use Streaming",
				"description": "Whether to use streaming for large requests and responses (currently only supported by camel-platform-http-vertx)",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"fileNameExtWhitelist": {
				"title": "File Name Ext Whitelist",
				"description": "A comma or whitespace separated list of file extensions. Uploads having these extensions will be stored locally. Null value or asterisk () will allow all files.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter headers to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"platformHttpEngine": {
				"title": "Platform Http Engine",
				"description": "An HTTP Server engine implementation to serve the requests of this endpoint.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.platform.http.spi.PlatformHttpEngine"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"path"
		]
	},
	"plc4x": {
		"properties": {
			"driver": {
				"title": "Driver",
				"description": "PLC4X connection string for the connection to the target",
				"type": "string",
				"$comment": "group:common"
			},
			"autoReconnect": {
				"title": "Auto Reconnect",
				"description": "Whether to reconnect when no connection is present upon doing a request",
				"type": "boolean",
				"$comment": "group:common"
			},
			"period": {
				"title": "Period",
				"description": "Interval on which the Trigger should be checked",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"tags": {
				"title": "Tags",
				"description": "Tags as key/values from the Map to use in query",
				"type": "object",
				"$comment": "group:consumer"
			},
			"trigger": {
				"title": "Trigger",
				"description": "Query to a trigger. On a rising edge of the trigger, the tags will be read once",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"driver"
		]
	},
	"pop3": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The mail server host name",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The port number of the mail server",
				"type": "integer",
				"$comment": "group:common"
			},
			"closeFolder": {
				"title": "Close Folder",
				"description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keeps the folder open between polls.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"copyTo": {
				"title": "Copy To",
				"description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"decodeFilename": {
				"title": "Decode Filename",
				"description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"delete": {
				"title": "Delete",
				"description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. You can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether the consumer should disconnect after polling. If enabled, this forces Camel to connect on each poll.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"handleFailedMessage": {
				"title": "Handle Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows handling the caused exception by the consumer's error handler. By enabling the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"mimeDecodeHeaders": {
				"title": "Mime Decode Headers",
				"description": "This option enables transparent MIME decoding and unfolding for mail headers.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveTo": {
				"title": "Move To",
				"description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"peek": {
				"title": "Peek",
				"description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek, the mail will not be eagerly marked as SEEN on the mail server, which allows us to roll back the mail message if there is a processing error in Camel.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"skipFailedMessage": {
				"title": "Skip Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows skipping the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"unseen": {
				"title": "Unseen",
				"description": "Whether to limit by unseen mails only.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"failOnDuplicateFileAttachment": {
				"title": "Fail On Duplicate File Attachment",
				"description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true, then an exception is thrown failing to process the mail message.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"fetchSize": {
				"title": "Fetch Size",
				"description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. The default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": -1
			},
			"folderName": {
				"title": "Folder Name",
				"description": "The folder to poll.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "INBOX"
			},
			"generateMissingAttachmentNames": {
				"title": "Generate Missing Attachment Names",
				"description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"handleDuplicateAttachmentNames": {
				"title": "Handle Duplicate Attachment Names",
				"description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with an uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with an underscore and uuid (filename_uuid.fileextension).",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"mailUidGenerator": {
				"title": "Mail Uid Generator",
				"description": "A pluggable MailUidGenerator that allows to use custom logic to generate UUID of the mail message.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailUidGenerator"
			},
			"mapMailMessage": {
				"title": "Map Mail Message",
				"description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false, then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"postProcessAction": {
				"title": "Post Process Action",
				"description": "Refers to an MailBoxPostProcessAction for doing post processing tasks on the mailbox once the normal processing ended.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailBoxPostProcessAction"
			},
			"bcc": {
				"title": "Bcc",
				"description": "Sets the BCC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"cc": {
				"title": "Cc",
				"description": "Sets the CC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"from": {
				"title": "From",
				"description": "The from email address",
				"type": "string",
				"$comment": "group:producer",
				"default": "camel@localhost"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"subject": {
				"title": "Subject",
				"description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
				"type": "string",
				"$comment": "group:producer"
			},
			"to": {
				"title": "To",
				"description": "Sets the destination email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"javaMailSender": {
				"title": "Java Mail Sender",
				"description": "To use a custom org.apache.camel.component.mail.JavaMailSender for sending emails.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.mail.JavaMailSender"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"additionalJavaMailProperties": {
				"title": "Additional Java Mail Properties",
				"description": "Sets additional java mail properties, that will append/override any default properties that are set based on all the other options. This is useful if you need to add some special options but want to keep the others as is.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"alternativeBodyHeader": {
				"title": "Alternative Body Header",
				"description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "CamelMailAlternativeBody"
			},
			"attachmentsContentTransferEncodingResolver": {
				"title": "Attachments Content Transfer Encoding Resolver",
				"description": "To use a custom AttachmentsContentTransferEncodingResolver to resolve what content-type-encoding to use for attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.AttachmentsContentTransferEncodingResolver"
			},
			"authenticator": {
				"title": "Authenticator",
				"description": "The authenticator for login. If set then the password and username are ignored. It can be used for tokens which can expire and therefore must be read dynamically.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailAuthenticator"
			},
			"binding": {
				"title": "Binding",
				"description": "Sets the binding used to convert from a Camel message to and from a Mail message",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailBinding"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "The connection timeout in milliseconds.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 30000
			},
			"contentType": {
				"title": "Content Type",
				"description": "The mail message content type. Use text/html for HTML mails.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "text/plain"
			},
			"contentTypeResolver": {
				"title": "Content Type Resolver",
				"description": "Resolver to determine Content-Type for file attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.ContentTypeResolver"
			},
			"debugMode": {
				"title": "Debug Mode",
				"description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"ignoreUnsupportedCharset": {
				"title": "Ignore Unsupported Charset",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"ignoreUriScheme": {
				"title": "Ignore Uri Scheme",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"javaMailProperties": {
				"title": "Java Mail Properties",
				"description": "Sets the java mail options. Will clear any default properties and only use the properties provided for this method.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"session": {
				"title": "Session",
				"description": "Specifies the mail session that camel should use for all mail interactions. Useful in scenarios where mail sessions are created and managed by some other resource, such as a JavaEE container. When using a custom mail session, then the hostname and port from the mail session will be used (if configured on the session).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.mail.Session"
			},
			"useInlineAttachments": {
				"title": "Use Inline Attachments",
				"description": "Whether to use disposition inline or attachment.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which allows to cluster consuming from the same mailbox, and let the repository coordinate whether a mail message is valid for the consumer to process. By default no repository is in use.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"idempotentRepositoryRemoveOnCommit": {
				"title": "Idempotent Repository Remove On Commit",
				"description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"searchTerm": {
				"title": "Search Term",
				"description": "Refers to a jakarta.mail.search.SearchTerm which allows to filter mails based on search criteria such as subject, body, from, sent after a certain date etc.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:jakarta.mail.search.SearchTerm"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "60000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "The password for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"username": {
				"title": "Username",
				"description": "The username for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sortTerm": {
				"title": "Sort Term",
				"description": "Sorting order for messages. Only natively supported for IMAP. Emulated to some degree when using POP3 or when IMAP server does not have the SORT capability.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:org.eclipse.angus.mail.imap.SortTerm[]"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"pop3s": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The mail server host name",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The port number of the mail server",
				"type": "integer",
				"$comment": "group:common"
			},
			"closeFolder": {
				"title": "Close Folder",
				"description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keeps the folder open between polls.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"copyTo": {
				"title": "Copy To",
				"description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"decodeFilename": {
				"title": "Decode Filename",
				"description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"delete": {
				"title": "Delete",
				"description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. You can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether the consumer should disconnect after polling. If enabled, this forces Camel to connect on each poll.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"handleFailedMessage": {
				"title": "Handle Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows handling the caused exception by the consumer's error handler. By enabling the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"mimeDecodeHeaders": {
				"title": "Mime Decode Headers",
				"description": "This option enables transparent MIME decoding and unfolding for mail headers.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveTo": {
				"title": "Move To",
				"description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"peek": {
				"title": "Peek",
				"description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek, the mail will not be eagerly marked as SEEN on the mail server, which allows us to roll back the mail message if there is a processing error in Camel.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"skipFailedMessage": {
				"title": "Skip Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows skipping the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"unseen": {
				"title": "Unseen",
				"description": "Whether to limit by unseen mails only.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"failOnDuplicateFileAttachment": {
				"title": "Fail On Duplicate File Attachment",
				"description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true, then an exception is thrown failing to process the mail message.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"fetchSize": {
				"title": "Fetch Size",
				"description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. The default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": -1
			},
			"folderName": {
				"title": "Folder Name",
				"description": "The folder to poll.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "INBOX"
			},
			"generateMissingAttachmentNames": {
				"title": "Generate Missing Attachment Names",
				"description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"handleDuplicateAttachmentNames": {
				"title": "Handle Duplicate Attachment Names",
				"description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with an uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with an underscore and uuid (filename_uuid.fileextension).",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"mailUidGenerator": {
				"title": "Mail Uid Generator",
				"description": "A pluggable MailUidGenerator that allows to use custom logic to generate UUID of the mail message.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailUidGenerator"
			},
			"mapMailMessage": {
				"title": "Map Mail Message",
				"description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false, then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"postProcessAction": {
				"title": "Post Process Action",
				"description": "Refers to an MailBoxPostProcessAction for doing post processing tasks on the mailbox once the normal processing ended.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailBoxPostProcessAction"
			},
			"bcc": {
				"title": "Bcc",
				"description": "Sets the BCC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"cc": {
				"title": "Cc",
				"description": "Sets the CC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"from": {
				"title": "From",
				"description": "The from email address",
				"type": "string",
				"$comment": "group:producer",
				"default": "camel@localhost"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"subject": {
				"title": "Subject",
				"description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
				"type": "string",
				"$comment": "group:producer"
			},
			"to": {
				"title": "To",
				"description": "Sets the destination email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"javaMailSender": {
				"title": "Java Mail Sender",
				"description": "To use a custom org.apache.camel.component.mail.JavaMailSender for sending emails.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.mail.JavaMailSender"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"additionalJavaMailProperties": {
				"title": "Additional Java Mail Properties",
				"description": "Sets additional java mail properties, that will append/override any default properties that are set based on all the other options. This is useful if you need to add some special options but want to keep the others as is.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"alternativeBodyHeader": {
				"title": "Alternative Body Header",
				"description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "CamelMailAlternativeBody"
			},
			"attachmentsContentTransferEncodingResolver": {
				"title": "Attachments Content Transfer Encoding Resolver",
				"description": "To use a custom AttachmentsContentTransferEncodingResolver to resolve what content-type-encoding to use for attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.AttachmentsContentTransferEncodingResolver"
			},
			"authenticator": {
				"title": "Authenticator",
				"description": "The authenticator for login. If set then the password and username are ignored. It can be used for tokens which can expire and therefore must be read dynamically.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailAuthenticator"
			},
			"binding": {
				"title": "Binding",
				"description": "Sets the binding used to convert from a Camel message to and from a Mail message",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailBinding"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "The connection timeout in milliseconds.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 30000
			},
			"contentType": {
				"title": "Content Type",
				"description": "The mail message content type. Use text/html for HTML mails.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "text/plain"
			},
			"contentTypeResolver": {
				"title": "Content Type Resolver",
				"description": "Resolver to determine Content-Type for file attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.ContentTypeResolver"
			},
			"debugMode": {
				"title": "Debug Mode",
				"description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"ignoreUnsupportedCharset": {
				"title": "Ignore Unsupported Charset",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"ignoreUriScheme": {
				"title": "Ignore Uri Scheme",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"javaMailProperties": {
				"title": "Java Mail Properties",
				"description": "Sets the java mail options. Will clear any default properties and only use the properties provided for this method.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"session": {
				"title": "Session",
				"description": "Specifies the mail session that camel should use for all mail interactions. Useful in scenarios where mail sessions are created and managed by some other resource, such as a JavaEE container. When using a custom mail session, then the hostname and port from the mail session will be used (if configured on the session).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.mail.Session"
			},
			"useInlineAttachments": {
				"title": "Use Inline Attachments",
				"description": "Whether to use disposition inline or attachment.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which allows to cluster consuming from the same mailbox, and let the repository coordinate whether a mail message is valid for the consumer to process. By default no repository is in use.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"idempotentRepositoryRemoveOnCommit": {
				"title": "Idempotent Repository Remove On Commit",
				"description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"searchTerm": {
				"title": "Search Term",
				"description": "Refers to a jakarta.mail.search.SearchTerm which allows to filter mails based on search criteria such as subject, body, from, sent after a certain date etc.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:jakarta.mail.search.SearchTerm"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "60000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "The password for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"username": {
				"title": "Username",
				"description": "The username for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sortTerm": {
				"title": "Sort Term",
				"description": "Sorting order for messages. Only natively supported for IMAP. Emulated to some degree when using POP3 or when IMAP server does not have the SORT capability.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:org.eclipse.angus.mail.imap.SortTerm[]"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"pubnub": {
		"properties": {
			"channel": {
				"title": "Channel",
				"description": "The channel used for subscribing/publishing events",
				"type": "string",
				"$comment": "group:common"
			},
			"uuid": {
				"title": "Uuid",
				"description": "UUID to be used as a device identifier, a default UUID is generated if not passed.",
				"type": "string",
				"$comment": "group:common"
			},
			"withPresence": {
				"title": "With Presence",
				"description": "Also subscribe to related presence information",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"operation": {
				"title": "Operation",
				"description": "The operation to perform. PUBLISH: Default. Send a message to all subscribers of a channel. FIRE: allows the client to send a message to BLOCKS Event Handlers. These messages will go directly to any Event Handlers registered on the channel. HERENOW: Obtain information about the current state of a channel including a list of unique user-ids currently subscribed to the channel and the total occupancy count. GETSTATE: Used to get key/value pairs specific to a subscriber uuid. State information is supplied as a JSON object of key/value pairs SETSTATE: Used to set key/value pairs specific to a subscriber uuid GETHISTORY: Fetches historical messages of a channel.",
				"type": "string",
				"enum": [
					"HERENOW",
					"GETSTATE",
					"SETSTATE",
					"GETHISTORY",
					"PUBLISH",
					"FIRE"
				],
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"pubnub": {
				"title": "Pubnub",
				"description": "Reference to a Pubnub client in the registry.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.pubnub.api.java.PubNub"
			},
			"authKey": {
				"title": "Auth Key",
				"description": "If Access Manager is utilized, client will use this authKey in all restricted requests. Default value notice: This setting is deprecated because it relates to deprecated Access Manager (PAM V2) and will be removed in the future. Please, migrate to new Access Manager (PAM V3) https://www.pubnub.com/docs/general/resources/migration-guides/pam-v3-migration",
				"type": "string",
				"$comment": "group:security",
				"format": "password",
				"deprecated": true
			},
			"publishKey": {
				"title": "Publish Key",
				"description": "The publish key obtained from your PubNub account. Required when publishing messages.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "The secret key used for message signing.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secure": {
				"title": "Secure",
				"description": "Use SSL for secure transmission.",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"subscribeKey": {
				"title": "Subscribe Key",
				"description": "The subscribe key obtained from your PubNub account. Required when subscribing to channels or listening for presence events",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"channel",
			"uuid"
		]
	},
	"pulsar": {
		"properties": {
			"persistence": {
				"title": "Persistence",
				"description": "Whether the topic is persistent or non-persistent",
				"type": "string",
				"enum": [
					"persistent",
					"non-persistent"
				],
				"$comment": "group:common"
			},
			"tenant": {
				"title": "Tenant",
				"description": "The tenant",
				"type": "string",
				"$comment": "group:common"
			},
			"namespace": {
				"title": "Namespace",
				"description": "The namespace",
				"type": "string",
				"$comment": "group:common"
			},
			"topic": {
				"title": "Topic",
				"description": "The topic",
				"type": "string",
				"$comment": "group:common"
			},
			"authenticationClass": {
				"title": "Authentication Class",
				"description": "The Authentication FQCN to be used while creating the client from URI",
				"type": "string",
				"$comment": "group:common"
			},
			"authenticationParams": {
				"title": "Authentication Params",
				"description": "The Authentication Parameters to be used while creating the client from URI",
				"type": "string",
				"$comment": "group:common"
			},
			"serviceUrl": {
				"title": "Service Url",
				"description": "The Pulsar Service URL to point while creating the client from URI",
				"type": "string",
				"$comment": "group:common"
			},
			"ackGroupTimeMillis": {
				"title": "Ack Group Time Millis",
				"description": "Group the consumer acknowledgments for the specified time in milliseconds - defaults to 100",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 100
			},
			"ackTimeoutMillis": {
				"title": "Ack Timeout Millis",
				"description": "Timeout for unacknowledged messages in milliseconds - defaults to 10000",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10000
			},
			"ackTimeoutRedeliveryBackoff": {
				"title": "Ack Timeout Redelivery Backoff",
				"description": "RedeliveryBackoff to use for ack timeout redelivery backoff.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.pulsar.client.api.RedeliveryBackoff"
			},
			"allowManualAcknowledgement": {
				"title": "Allow Manual Acknowledgement",
				"description": "Whether to allow manual message acknowledgements. If this option is enabled, then messages are not acknowledged automatically after successful route completion. Instead, an instance of PulsarMessageReceipt is stored as a header on the org.apache.camel.Exchange. Messages can then be acknowledged using PulsarMessageReceipt at any time before the ackTimeout occurs.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"consumerName": {
				"title": "Consumer Name",
				"description": "Name of the consumer when subscription is EXCLUSIVE",
				"type": "string",
				"$comment": "group:consumer",
				"default": "sole-consumer"
			},
			"consumerNamePrefix": {
				"title": "Consumer Name Prefix",
				"description": "Prefix to add to consumer names when a SHARED or FAILOVER subscription is used",
				"type": "string",
				"$comment": "group:consumer",
				"default": "cons"
			},
			"consumerQueueSize": {
				"title": "Consumer Queue Size",
				"description": "Size of the consumer queue - defaults to 10",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"deadLetterTopic": {
				"title": "Dead Letter Topic",
				"description": "Name of the topic where the messages which fail maxRedeliverCount times will be sent. Note: if not set, default topic name will be topicName-subscriptionName-DLQ",
				"type": "string",
				"$comment": "group:consumer"
			},
			"enableRetry": {
				"title": "Enable Retry",
				"description": "To enable retry letter topic mode. The default retry letter topic uses this format: topicname-subscriptionname-RETRY",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"keySharedPolicy": {
				"title": "Key Shared Policy",
				"description": "Policy to use by consumer when using key-shared subscription type.",
				"type": "string",
				"enum": [
					"AUTO_SPLIT",
					"STICKY"
				],
				"$comment": "group:consumer"
			},
			"maxRedeliverCount": {
				"title": "Max Redeliver Count",
				"description": "Maximum number of times that a message will be redelivered before being sent to the dead letter queue. If this value is not set, no Dead Letter Policy will be created",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"messageListener": {
				"title": "Message Listener",
				"description": "Whether to use the messageListener interface, or to receive messages using a separate thread pool",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"negativeAckRedeliveryBackoff": {
				"title": "Negative Ack Redelivery Backoff",
				"description": "RedeliveryBackoff to use for negative ack redelivery backoff.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.pulsar.client.api.RedeliveryBackoff"
			},
			"negativeAckRedeliveryDelayMicros": {
				"title": "Negative Ack Redelivery Delay Micros",
				"description": "Set the negative acknowledgement delay",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 60000000
			},
			"numberOfConsumers": {
				"title": "Number Of Consumers",
				"description": "Number of consumers - defaults to 1",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"numberOfConsumerThreads": {
				"title": "Number Of Consumer Threads",
				"description": "Number of threads to receive and handle messages when using a separate thread pool",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"readCompacted": {
				"title": "Read Compacted",
				"description": "Enable compacted topic reading.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"retryLetterTopic": {
				"title": "Retry Letter Topic",
				"description": "Name of the topic to use in retry mode. Note: if not set, default topic name will be topicName-subscriptionName-RETRY",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscriptionInitialPosition": {
				"title": "Subscription Initial Position",
				"description": "Control the initial position in the topic of a newly created subscription. Default is latest message.",
				"type": "string",
				"enum": [
					"EARLIEST",
					"LATEST"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.pulsar.utils.consumers.SubscriptionInitialPosition",
				"default": "LATEST"
			},
			"subscriptionName": {
				"title": "Subscription Name",
				"description": "Name of the subscription to use",
				"type": "string",
				"$comment": "group:consumer",
				"default": "subs"
			},
			"subscriptionTopicsMode": {
				"title": "Subscription Topics Mode",
				"description": "Determines to which topics this consumer should be subscribed to - Persistent, Non-Persistent, or both. Only used with pattern subscriptions.",
				"type": "string",
				"enum": [
					"PersistentOnly",
					"NonPersistentOnly",
					"AllTopics"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.pulsar.client.api.RegexSubscriptionMode",
				"default": "PersistentOnly"
			},
			"subscriptionType": {
				"title": "Subscription Type",
				"description": "Type of the subscription EXCLUSIVESHAREDFAILOVERKEY_SHARED, defaults to EXCLUSIVE",
				"type": "string",
				"enum": [
					"EXCLUSIVE",
					"SHARED",
					"FAILOVER",
					"KEY_SHARED"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.pulsar.utils.consumers.SubscriptionType",
				"default": "EXCLUSIVE"
			},
			"topicsPattern": {
				"title": "Topics Pattern",
				"description": "Whether the topic is a pattern (regular expression) that allows the consumer to subscribe to all matching topics in the namespace",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"batcherBuilder": {
				"title": "Batcher Builder",
				"description": "Control batching method used by the producer.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.pulsar.client.api.BatcherBuilder",
				"default": "DEFAULT"
			},
			"batchingEnabled": {
				"title": "Batching Enabled",
				"description": "Control whether automatic batching of messages is enabled for the producer.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"batchingMaxMessages": {
				"title": "Batching Max Messages",
				"description": "The maximum size to batch messages.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1000
			},
			"batchingMaxPublishDelayMicros": {
				"title": "Batching Max Publish Delay Micros",
				"description": "The maximum time period within which the messages sent will be batched if batchingEnabled is true.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1000
			},
			"blockIfQueueFull": {
				"title": "Block If Queue Full",
				"description": "Whether to block the producing thread if pending messages queue is full or to throw a ProducerQueueIsFullError",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"chunkingEnabled": {
				"title": "Chunking Enabled",
				"description": "Control whether chunking of messages is enabled for the producer.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"compressionType": {
				"title": "Compression Type",
				"description": "Compression type to use",
				"type": "string",
				"enum": [
					"NONE",
					"LZ4",
					"ZLIB",
					"ZSTD",
					"SNAPPY"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.pulsar.client.api.CompressionType",
				"default": "NONE"
			},
			"hashingScheme": {
				"title": "Hashing Scheme",
				"description": "Hashing function to use when choosing the partition to use for a particular message",
				"type": "string",
				"enum": [
					"JavaStringHash",
					"Murmur3_32Hash"
				],
				"$comment": "group:producer",
				"default": "JavaStringHash"
			},
			"initialSequenceId": {
				"title": "Initial Sequence Id",
				"description": "The first message published will have a sequence Id of initialSequenceId 1.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"maxPendingMessages": {
				"title": "Max Pending Messages",
				"description": "Size of the pending massages queue. When the queue is full, by default, any further sends will fail unless blockIfQueueFull=true",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1000
			},
			"maxPendingMessagesAcrossPartitions": {
				"title": "Max Pending Messages Across Partitions",
				"description": "The maximum number of pending messages for partitioned topics. The maxPendingMessages value will be reduced if (number of partitions maxPendingMessages) exceeds this value. Partitioned topics have a pending message queue for each partition.",
				"type": "integer",
				"$comment": "group:producer",
				"deprecated": true,
				"default": 50000
			},
			"messageRouter": {
				"title": "Message Router",
				"description": "Custom Message Router to use",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.pulsar.client.api.MessageRouter"
			},
			"messageRoutingMode": {
				"title": "Message Routing Mode",
				"description": "Message Routing Mode to use",
				"type": "string",
				"enum": [
					"SinglePartition",
					"RoundRobinPartition",
					"CustomPartition"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.pulsar.client.api.MessageRoutingMode",
				"default": "RoundRobinPartition"
			},
			"producerName": {
				"title": "Producer Name",
				"description": "Name of the producer. If unset, lets Pulsar select a unique identifier.",
				"type": "string",
				"$comment": "group:producer"
			},
			"sendTimeoutMs": {
				"title": "Send Timeout Ms",
				"description": "Send timeout in milliseconds",
				"type": "integer",
				"$comment": "group:producer",
				"default": 30000
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"persistence",
			"tenant",
			"namespace",
			"topic"
		]
	},
	"qdrant": {
		"properties": {
			"collection": {
				"title": "Collection",
				"description": "The collection Name",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiKey": {
				"title": "Api Key",
				"description": "Sets the API key to use for authentication",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"host": {
				"title": "Host",
				"description": "The host to connect to.",
				"type": "string",
				"$comment": "group:producer",
				"default": "localhost"
			},
			"maxResults": {
				"title": "Max Results",
				"description": "Max results for similarity search",
				"type": "integer",
				"$comment": "group:producer",
				"default": 3
			},
			"port": {
				"title": "Port",
				"description": "The port to connect to.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 6334
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets a default timeout for all requests",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.time.Duration"
			},
			"tls": {
				"title": "Tls",
				"description": "Whether the client uses Transport Layer Security (TLS) to secure communications",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"filter": {
				"title": "Filter",
				"description": "Filter of type io.qdrant.client.grpc.Points.Points.Filter for similarity search. This is for advanced usage.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.qdrant.client.grpc.Points.Filter"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"collection"
		]
	},
	"quartz": {
		"properties": {
			"groupName": {
				"title": "Group Name",
				"description": "The quartz group name to use. The combination of group name and trigger name should be unique.",
				"type": "string",
				"$comment": "group:consumer",
				"default": "Camel"
			},
			"triggerName": {
				"title": "Trigger Name",
				"description": "The quartz trigger name to use. The combination of group name and trigger name should be unique.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"cron": {
				"title": "Cron",
				"description": "Specifies a cron expression to define when to trigger.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"deleteJob": {
				"title": "Delete Job",
				"description": "If set to true, then the trigger automatically delete when route stop. Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse pre-configured trigger with camel Uri. Just ensure the names match. Notice you cannot have both deleteJob and pauseJob set to true.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"durableJob": {
				"title": "Durable Job",
				"description": "Whether or not the job should remain stored after it is orphaned (no triggers point to it).",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"pauseJob": {
				"title": "Pause Job",
				"description": "If set to true, then the trigger automatically pauses when route stop. Else if set to false, it will remain in scheduler. When set to false, it will also mean user may reuse pre-configured trigger with camel Uri. Just ensure the names match. Notice you cannot have both deleteJob and pauseJob set to true.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"recoverableJob": {
				"title": "Recoverable Job",
				"description": "Instructs the scheduler whether or not the job should be re-executed if a 'recovery' or 'fail-over' situation is encountered.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"stateful": {
				"title": "Stateful",
				"description": "Uses a Quartz PersistJobDataAfterExecution and DisallowConcurrentExecution instead of the default job.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"customCalendar": {
				"title": "Custom Calendar",
				"description": "Specifies a custom calendar to avoid specific range of date",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.quartz.Calendar"
			},
			"ignoreExpiredNextFireTime": {
				"title": "Ignore Expired Next Fire Time",
				"description": "Whether to ignore quartz cannot schedule a trigger because the trigger will never fire in the future. This can happen when using a cron trigger that are configured to only run in the past. By default, Quartz will fail to schedule the trigger and therefore fail to start the Camel route. You can set this to true which then logs a WARN and then ignore the problem, meaning that the route will never fire in the future.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"jobParameters": {
				"title": "Job Parameters",
				"description": "To configure additional options on the job.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"prefixJobNameWithEndpointId": {
				"title": "Prefix Job Name With Endpoint Id",
				"description": "Whether the job name should be prefixed with endpoint id",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"triggerParameters": {
				"title": "Trigger Parameters",
				"description": "To configure additional options on the trigger. The parameter timeZone is supported if the cron option is present. Otherwise the parameters repeatInterval and repeatCount are supported. Note: When using repeatInterval values of 1000 or less, the first few events after starting the camel context may be fired more rapidly than expected.",
				"type": "object",
				"$comment": "group:advanced"
			},
			"usingFixedCamelContextName": {
				"title": "Using Fixed Camel Context Name",
				"description": "If it is true, JobDataMap uses the CamelContext name directly to reference the CamelContext, if it is false, JobDataMap uses use the CamelContext management name which could be changed during the deploy time.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"autoStartScheduler": {
				"title": "Auto Start Scheduler",
				"description": "Whether or not the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"triggerStartDelay": {
				"title": "Trigger Start Delay",
				"description": "In case of scheduler has already started, we want the trigger start slightly after current time to ensure endpoint is fully started before the job kicks in. Negative value shifts trigger start time in the past.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "500"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"triggerName"
		]
	},
	"quickfix": {
		"properties": {
			"configurationName": {
				"title": "Configuration Name",
				"description": "Path to the quickfix configuration file. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the configuration file using these protocols (classpath is default). ref will lookup the configuration file in the registry. bean will call a method on a bean to be used as the configuration. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
				"type": "string",
				"$comment": "group:common"
			},
			"lazyCreateEngine": {
				"title": "Lazy Create Engine",
				"description": "This option allows creating QuickFIX/J engine on demand. Value true means the engine is started when first message is send or there's consumer configured in route definition. When false value is used, the engine is started at the endpoint creation. When this parameter is missing, the value of component's property lazyCreateEngines is being used.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"sessionID": {
				"title": "Session ID",
				"description": "The optional sessionID identifies a specific FIX session. The format of the sessionID is: (BeginString):(SenderCompID)/(SenderSubID)/(SenderLocationID)-(TargetCompID)/(TargetSubID)/(TargetLocationID)",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"configurationName"
		]
	},
	"reactive-streams": {
		"properties": {
			"stream": {
				"title": "Stream",
				"description": "Name of the stream channel used by the endpoint to exchange messages.",
				"type": "string",
				"$comment": "group:common"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Number of threads used to process exchanges in the Camel route.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"exchangesRefillLowWatermark": {
				"title": "Exchanges Refill Low Watermark",
				"description": "Set the low watermark of requested exchanges to the active subscription as percentage of the maxInflightExchanges. When the number of pending items from the upstream source is lower than the watermark, new items can be requested to the subscription. If set to 0, the subscriber will request items in batches of maxInflightExchanges, only after all items of the previous batch have been processed. If set to 1, the subscriber can request a new item each time an exchange is processed (chatty). Any intermediate value can be used.",
				"type": "number",
				"$comment": "group:consumer",
				"default": "0.25"
			},
			"forwardOnComplete": {
				"title": "Forward On Complete",
				"description": "Determines if onComplete events should be pushed to the Camel route.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"forwardOnError": {
				"title": "Forward On Error",
				"description": "Determines if onError events should be pushed to the Camel route. Exceptions will be set as message body.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maxInflightExchanges": {
				"title": "Max Inflight Exchanges",
				"description": "Maximum number of exchanges concurrently being processed by Camel. This parameter controls backpressure on the stream. Setting a non-positive value will disable backpressure.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "128"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"backpressureStrategy": {
				"title": "Backpressure Strategy",
				"description": "The backpressure strategy to use when pushing events to a slow subscriber.",
				"type": "string",
				"enum": [
					"BUFFER",
					"OLDEST",
					"LATEST"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.reactive.streams.ReactiveStreamsBackpressureStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"ref": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of endpoint to lookup in the registry.",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"rest": {
		"properties": {
			"method": {
				"title": "Method",
				"description": "HTTP method to use.",
				"type": "string",
				"enum": [
					"get",
					"post",
					"put",
					"delete",
					"patch",
					"head",
					"trace",
					"connect",
					"options"
				],
				"$comment": "group:common"
			},
			"path": {
				"title": "Path",
				"description": "The base path, can use &#42; as path suffix to support wildcard HTTP route matching.",
				"type": "string",
				"$comment": "group:common"
			},
			"uriTemplate": {
				"title": "Uri Template",
				"description": "The uri template",
				"type": "string",
				"$comment": "group:common"
			},
			"consumes": {
				"title": "Consumes",
				"description": "Media type such as: 'text/xml', or 'application/json' this REST service accepts. By default we accept all kinds of types.",
				"type": "string",
				"$comment": "group:common"
			},
			"inType": {
				"title": "In Type",
				"description": "To declare the incoming POJO binding type as a FQN class name",
				"type": "string",
				"$comment": "group:common"
			},
			"outType": {
				"title": "Out Type",
				"description": "To declare the outgoing POJO binding type as a FQN class name",
				"type": "string",
				"$comment": "group:common"
			},
			"produces": {
				"title": "Produces",
				"description": "Media type such as: 'text/xml', or 'application/json' this REST service returns.",
				"type": "string",
				"$comment": "group:common"
			},
			"routeId": {
				"title": "Route Id",
				"description": "Name of the route this REST services creates",
				"type": "string",
				"$comment": "group:common"
			},
			"consumerComponentName": {
				"title": "Consumer Component Name",
				"description": "The Camel Rest component to use for the consumer REST transport, such as jetty, servlet, undertow. If no component has been explicitly configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found, then that is being used.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"description": {
				"title": "Description",
				"description": "Human description to document this REST service",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"apiDoc": {
				"title": "Api Doc",
				"description": "The openapi api doc resource to use. The resource is loaded from classpath by default and must be in JSON format.",
				"type": "string",
				"$comment": "group:producer"
			},
			"bindingMode": {
				"title": "Binding Mode",
				"description": "Configures the binding mode for the producer. If set to anything other than 'off' the producer will try to convert the body of the incoming message from inType to the json or xml, and the response from json or xml to outType.",
				"type": "string",
				"enum": [
					"auto",
					"off",
					"json",
					"xml",
					"json_xml"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.spi.RestConfiguration.RestBindingMode"
			},
			"host": {
				"title": "Host",
				"description": "Host and port of HTTP service to use (override host in openapi schema)",
				"type": "string",
				"$comment": "group:producer"
			},
			"producerComponentName": {
				"title": "Producer Component Name",
				"description": "The Camel Rest component to use for the producer REST transport, such as http, undertow. If no component has been explicitly configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestProducerFactory is registered in the registry. If either one is found, then that is being used.",
				"type": "string",
				"$comment": "group:producer"
			},
			"queryParameters": {
				"title": "Query Parameters",
				"description": "Query parameters for the HTTP service to call. The query parameters can contain multiple parameters separated by ampersand such such as foo=123&bar=456.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"method",
			"path"
		]
	},
	"rest-api": {
		"properties": {
			"path": {
				"title": "Path",
				"description": "The base path",
				"type": "string",
				"$comment": "group:consumer"
			},
			"apiComponentName": {
				"title": "Api Component Name",
				"description": "The Camel Rest API component to use for generating the API of the REST services, such as openapi.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"consumerComponentName": {
				"title": "Consumer Component Name",
				"description": "The Camel Rest component to use for the consumer REST transport, such as jetty, servlet, undertow. If no component has been explicitly configured, then Camel will lookup if there is a Camel component that integrates with the Rest DSL, or if a org.apache.camel.spi.RestConsumerFactory is registered in the registry. If either one is found, then that is being used.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"path"
		]
	},
	"rest-openapi": {
		"properties": {
			"specificationUri": {
				"title": "Specification Uri",
				"description": "Path to the OpenApi specification file. The scheme, host base path are taken from this specification, but these can be overridden with properties on the component or endpoint level. If not given the component tries to load openapi.json resource from the classpath. Note that the host defined on the component and endpoint of this Component should contain the scheme, hostname and optionally the port in the URI syntax (i.e. http://api.example.com:8080). Overrides component configuration. The OpenApi specification can be loaded from different sources by prefixing with file: classpath: http: https:. Support for https is limited to using the JDK installed UrlHandler, and as such it can be cumbersome to setup TLS/SSL certificates for https (such as setting a number of javax.net.ssl JVM system properties). How to do that consult the JDK documentation for UrlHandler. Default value notice: By default loads openapi.json file",
				"type": "string",
				"$comment": "group:common",
				"default": "openapi.json"
			},
			"operationId": {
				"title": "Operation Id",
				"description": "ID of the operation from the OpenApi specification. This is required when using producer",
				"type": "string",
				"$comment": "group:producer"
			},
			"apiContextPath": {
				"title": "Api Context Path",
				"description": "Sets the context-path to use for servicing the OpenAPI specification",
				"type": "string",
				"$comment": "group:consumer"
			},
			"clientRequestValidation": {
				"title": "Client Request Validation",
				"description": "Whether to enable validation of the client request to check if the incoming request is valid according to the OpenAPI specification",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"consumes": {
				"title": "Consumes",
				"description": "What payload type this component capable of consuming. Could be one type, like application/json or multiple types as application/json, application/xml; q=0.5 according to the RFC7231. This equates or multiple types as application/json, application/xml; q=0.5 according to the RFC7231. This equates to the value of Accept HTTP header. If set overrides any value found in the OpenApi specification and. in the component configuration",
				"type": "string",
				"$comment": "group:consumer"
			},
			"missingOperation": {
				"title": "Missing Operation",
				"description": "Whether the consumer should fail,ignore or return a mock response for OpenAPI operations that are not mapped to a corresponding route.",
				"type": "string",
				"enum": [
					"fail",
					"ignore",
					"mock"
				],
				"$comment": "group:consumer",
				"default": "fail"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"consumerComponentName": {
				"title": "Consumer Component Name",
				"description": "Name of the Camel component that will service the requests. The component must be present in Camel registry and it must implement RestOpenApiConsumerFactory service provider interface. If not set CLASSPATH is searched for single component that implements RestOpenApiConsumerFactory SPI. Overrides component configuration.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"mockIncludePattern": {
				"title": "Mock Include Pattern",
				"description": "Used for inclusive filtering of mock data from directories. The pattern is using Ant-path style pattern. Multiple patterns can be specified separated by comma.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "classpath:camel-mock/**"
			},
			"restOpenapiProcessorStrategy": {
				"title": "Rest Openapi Processor Strategy",
				"description": "To use a custom strategy for how to process Rest DSL requests",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.rest.openapi.RestOpenapiProcessorStrategy"
			},
			"basePath": {
				"title": "Base Path",
				"description": "API basePath, for example /v3. Default is unset, if set overrides the value present in OpenApi specification and in the component configuration.",
				"type": "string",
				"$comment": "group:producer"
			},
			"host": {
				"title": "Host",
				"description": "Scheme hostname and port to direct the HTTP requests to in the form of https://hostname:port. Can be configured at the endpoint, component or in the corresponding REST configuration in the Camel Context. If you give this component a name (e.g. petstore) that REST configuration is consulted first, rest-openapi next, and global configuration last. If set overrides any value found in the OpenApi specification, RestConfiguration. Overrides all other configuration.",
				"type": "string",
				"$comment": "group:producer"
			},
			"produces": {
				"title": "Produces",
				"description": "What payload type this component is producing. For example application/json according to the RFC7231. This equates to the value of Content-Type HTTP header. If set overrides any value present in the OpenApi specification. Overrides all other configuration.",
				"type": "string",
				"$comment": "group:producer"
			},
			"requestValidationEnabled": {
				"title": "Request Validation Enabled",
				"description": "Enable validation of requests against the configured OpenAPI specification",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"componentName": {
				"title": "Component Name",
				"description": "Name of the Camel component that will perform the requests. The component must be present in Camel registry and it must implement RestProducerFactory service provider interface. If not set CLASSPATH is searched for single component that implements RestProducerFactory SPI. Overrides component configuration.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"robotframework": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:common"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"argumentFiles": {
				"title": "Argument Files",
				"description": "A text String to read more arguments from.",
				"type": "string",
				"$comment": "group:common"
			},
			"combinedTagStats": {
				"title": "Combined Tag Stats",
				"description": "Creates combined statistics based on tags. Use the format tags:title List",
				"type": "string",
				"$comment": "group:common"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:common"
			},
			"criticalTags": {
				"title": "Critical Tags",
				"description": "Tests that have the given tags are considered critical. List",
				"type": "string",
				"$comment": "group:common"
			},
			"debugFile": {
				"title": "Debug File",
				"description": "A debug String that is written during execution.",
				"type": "string",
				"$comment": "group:common"
			},
			"document": {
				"title": "Document",
				"description": "Sets the documentation of the top-level tests suites.",
				"type": "string",
				"$comment": "group:common"
			},
			"dryrun": {
				"title": "Dryrun",
				"description": "Sets dryrun mode on use. In the dry run mode tests are run without executing keywords originating from test libraries. Useful for validating test data syntax.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"excludes": {
				"title": "Excludes",
				"description": "Selects the tests cases by tags. List",
				"type": "string",
				"$comment": "group:common"
			},
			"exitOnFailure": {
				"title": "Exit On Failure",
				"description": "Sets robot to stop execution immediately if a critical test fails.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"includes": {
				"title": "Includes",
				"description": "Selects the tests cases by tags. List",
				"type": "string",
				"$comment": "group:common"
			},
			"listener": {
				"title": "Listener",
				"description": "Sets a single listener for monitoring tests execution",
				"type": "string",
				"$comment": "group:common"
			},
			"listeners": {
				"title": "Listeners",
				"description": "Sets multiple listeners for monitoring tests execution. Use the format ListenerWithArgs:arg1:arg2 or simply ListenerWithoutArgs List",
				"type": "string",
				"$comment": "group:common"
			},
			"log": {
				"title": "Log",
				"description": "Sets the path to the generated log String.",
				"type": "string",
				"$comment": "group:common"
			},
			"logLevel": {
				"title": "Log Level",
				"description": "Sets the threshold level for logging.",
				"type": "string",
				"$comment": "group:common"
			},
			"logTitle": {
				"title": "Log Title",
				"description": "Sets a title for the generated tests log.",
				"type": "string",
				"$comment": "group:common"
			},
			"metadata": {
				"title": "Metadata",
				"description": "Sets free metadata for the top level tests suites. comma seperated list of string resulting as List",
				"type": "string",
				"$comment": "group:common"
			},
			"monitorColors": {
				"title": "Monitor Colors",
				"description": "Using ANSI colors in console. Normally colors work in unixes but not in Windows. Default is 'on'. 'on' - use colors in unixes but not in Windows 'off' - never use colors 'force' - always use colors (also in Windows)",
				"type": "string",
				"$comment": "group:common"
			},
			"monitorWidth": {
				"title": "Monitor Width",
				"description": "Width of the monitor output. Default is 78.",
				"type": "string",
				"$comment": "group:common",
				"default": "78"
			},
			"name": {
				"title": "Name",
				"description": "Sets the name of the top-level tests suites.",
				"type": "string",
				"$comment": "group:common"
			},
			"nonCriticalTags": {
				"title": "Non Critical Tags",
				"description": "Tests that have the given tags are not critical. List",
				"type": "string",
				"$comment": "group:common"
			},
			"noStatusReturnCode": {
				"title": "No Status Return Code",
				"description": "If true, sets the return code to zero regardless of failures in test cases. Error codes are returned normally.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"output": {
				"title": "Output",
				"description": "Sets the path to the generated output String.",
				"type": "string",
				"$comment": "group:common"
			},
			"outputDirectory": {
				"title": "Output Directory",
				"description": "Configures where generated reports are to be placed.",
				"type": "string",
				"$comment": "group:common"
			},
			"randomize": {
				"title": "Randomize",
				"description": "Sets the test execution order to be randomized. Valid values are all, suite, and test",
				"type": "string",
				"$comment": "group:common"
			},
			"report": {
				"title": "Report",
				"description": "Sets the path to the generated report String.",
				"type": "string",
				"$comment": "group:common"
			},
			"reportBackground": {
				"title": "Report Background",
				"description": "Sets background colors for the generated report and summary.",
				"type": "string",
				"$comment": "group:common"
			},
			"reportTitle": {
				"title": "Report Title",
				"description": "Sets a title for the generated tests report.",
				"type": "string",
				"$comment": "group:common"
			},
			"runEmptySuite": {
				"title": "Run Empty Suite",
				"description": "Executes tests also if the top level test suite is empty. Useful e.g. with --include/--exclude when it is not an error that no test matches the condition.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"runFailed": {
				"title": "Run Failed",
				"description": "Re-run failed tests, based on output.xml String.",
				"type": "string",
				"$comment": "group:common"
			},
			"runMode": {
				"title": "Run Mode",
				"description": "Sets the execution mode for this tests run. Note that this setting has been deprecated in Robot Framework 2.8. Use separate dryryn, skipTeardownOnExit, exitOnFailure, and randomize settings instead.",
				"type": "string",
				"$comment": "group:common"
			},
			"skipTeardownOnExit": {
				"title": "Skip Teardown On Exit",
				"description": "Sets whether the teardowns are skipped if the test execution is prematurely stopped.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"splitOutputs": {
				"title": "Split Outputs",
				"description": "Splits output and log files.",
				"type": "string",
				"$comment": "group:common"
			},
			"suites": {
				"title": "Suites",
				"description": "Selects the tests suites by name. List",
				"type": "string",
				"$comment": "group:common"
			},
			"suiteStatLevel": {
				"title": "Suite Stat Level",
				"description": "Defines how many levels to show in the Statistics by Suite table in outputs.",
				"type": "string",
				"$comment": "group:common"
			},
			"summaryTitle": {
				"title": "Summary Title",
				"description": "Sets a title for the generated summary report.",
				"type": "string",
				"$comment": "group:common"
			},
			"tagDocs": {
				"title": "Tag Docs",
				"description": "Adds documentation to the specified tags. List",
				"type": "string",
				"$comment": "group:common"
			},
			"tags": {
				"title": "Tags",
				"description": "Sets the tags(s) to all executed tests cases. List",
				"type": "string",
				"$comment": "group:common"
			},
			"tagStatExcludes": {
				"title": "Tag Stat Excludes",
				"description": "Excludes these tags from the Statistics by Tag and Test Details by Tag tables in outputs. List",
				"type": "string",
				"$comment": "group:common"
			},
			"tagStatIncludes": {
				"title": "Tag Stat Includes",
				"description": "Includes only these tags in the Statistics by Tag and Test Details by Tag tables in outputs. List",
				"type": "string",
				"$comment": "group:common"
			},
			"tagStatLinks": {
				"title": "Tag Stat Links",
				"description": "Adds external links to the Statistics by Tag table in outputs. Use the format pattern:link:title List",
				"type": "string",
				"$comment": "group:common"
			},
			"tests": {
				"title": "Tests",
				"description": "Selects the tests cases by name. List",
				"type": "string",
				"$comment": "group:common"
			},
			"timestampOutputs": {
				"title": "Timestamp Outputs",
				"description": "Adds a timestamp to all output files.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"variableFiles": {
				"title": "Variable Files",
				"description": "Sets variables using variables files. Use the format path:args List",
				"type": "string",
				"$comment": "group:common"
			},
			"variables": {
				"title": "Variables",
				"description": "Sets individual variables. Use the format name:value List",
				"type": "string",
				"$comment": "group:common"
			},
			"warnOnSkippedFiles": {
				"title": "Warn On Skipped Files",
				"description": "Show a warning when an invalid String is skipped.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"xunitFile": {
				"title": "Xunit File",
				"description": "Sets the path to the generated XUnit compatible result String, relative to outputDirectory. The String is in xml format. By default, the String name is derived from the testCasesDirectory parameter, replacing blanks in the directory name by underscores.",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"rocketmq": {
		"properties": {
			"topicName": {
				"title": "Topic Name",
				"description": "Topic name of this endpoint.",
				"type": "string",
				"$comment": "group:common"
			},
			"namesrvAddr": {
				"title": "Namesrv Addr",
				"description": "Name server address of RocketMQ cluster.",
				"type": "string",
				"$comment": "group:common",
				"default": "localhost:9876"
			},
			"consumerGroup": {
				"title": "Consumer Group",
				"description": "Consumer group name.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"subscribeTags": {
				"title": "Subscribe Tags",
				"description": "Subscribe tags of consumer. Multiple tags could be split by , such as TagATagB",
				"type": "string",
				"$comment": "group:consumer",
				"default": "*"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"producerGroup": {
				"title": "Producer Group",
				"description": "Producer group name.",
				"type": "string",
				"$comment": "group:producer"
			},
			"replyToConsumerGroup": {
				"title": "Reply To Consumer Group",
				"description": "Consumer group name used for receiving response.",
				"type": "string",
				"$comment": "group:producer"
			},
			"replyToTopic": {
				"title": "Reply To Topic",
				"description": "Topic used for receiving response when using in-out pattern.",
				"type": "string",
				"$comment": "group:producer"
			},
			"sendTag": {
				"title": "Send Tag",
				"description": "Each message would be sent with this tag.",
				"type": "string",
				"$comment": "group:producer"
			},
			"waitForSendResult": {
				"title": "Wait For Send Result",
				"description": "Whether waiting for send result before routing to next endpoint.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"requestTimeoutCheckerIntervalMillis": {
				"title": "Request Timeout Checker Interval Millis",
				"description": "Check interval milliseconds of request timeout.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1000
			},
			"requestTimeoutMillis": {
				"title": "Request Timeout Millis",
				"description": "Timeout milliseconds of receiving response when using in-out pattern.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 10000
			},
			"accessKey": {
				"title": "Access Key",
				"description": "Access key for RocketMQ ACL.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"secretKey": {
				"title": "Secret Key",
				"description": "Secret key for RocketMQ ACL.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"topicName"
		]
	},
	"rss": {
		"properties": {
			"feedUri": {
				"title": "Feed Uri",
				"description": "The URI to the feed to poll.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sortEntries": {
				"title": "Sort Entries",
				"description": "Sets whether to sort entries by published date. Only works when splitEntries = true.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"splitEntries": {
				"title": "Split Entries",
				"description": "Sets whether or not entries should be sent individually or whether the entire feed should be sent as a single message",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"throttleEntries": {
				"title": "Throttle Entries",
				"description": "Sets whether all entries identified in a single feed poll should be delivered immediately. If true, only one entry is processed per delay. Only applicable when splitEntries = true.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"feedHeader": {
				"title": "Feed Header",
				"description": "Sets whether to add the feed object as a header.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"feedUri"
		]
	},
	"saga": {
		"properties": {
			"action": {
				"title": "Action",
				"description": "Action to execute (complete or compensate)",
				"type": "string",
				"enum": [
					"COMPLETE",
					"COMPENSATE"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.saga.SagaEndpoint.SagaEndpointAction"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"action"
		]
	},
	"salesforce": {
		"properties": {
			"operationName": {
				"title": "Operation Name",
				"description": "The operation to use",
				"type": "string",
				"enum": [
					"getVersions",
					"getResources",
					"getGlobalObjects",
					"getBasicInfo",
					"getDescription",
					"getSObject",
					"createSObject",
					"updateSObject",
					"deleteSObject",
					"getSObjectWithId",
					"upsertSObject",
					"deleteSObjectWithId",
					"getBlobField",
					"query",
					"queryMore",
					"queryAll",
					"search",
					"apexCall",
					"recent",
					"getEventSchema",
					"createJob",
					"getJob",
					"closeJob",
					"abortJob",
					"createBatch",
					"getBatch",
					"getAllBatches",
					"getRequest",
					"getResults",
					"createBatchQuery",
					"getQueryResultIds",
					"getQueryResult",
					"getRecentReports",
					"getReportDescription",
					"executeSyncReport",
					"executeAsyncReport",
					"getReportInstances",
					"getReportResults",
					"limits",
					"approval",
					"approvals",
					"composite-tree",
					"composite-batch",
					"composite",
					"compositeRetrieveSObjectCollections",
					"compositeCreateSObjectCollections",
					"compositeUpdateSObjectCollections",
					"compositeUpsertSObjectCollections",
					"compositeDeleteSObjectCollections",
					"bulk2GetAllJobs",
					"bulk2CreateJob",
					"bulk2GetJob",
					"bulk2CreateBatch",
					"bulk2CloseJob",
					"bulk2AbortJob",
					"bulk2DeleteJob",
					"bulk2GetSuccessfulResults",
					"bulk2GetFailedResults",
					"bulk2GetUnprocessedRecords",
					"bulk2CreateQueryJob",
					"bulk2GetQueryJob",
					"bulk2GetAllQueryJobs",
					"bulk2GetQueryJobResults",
					"bulk2AbortQueryJob",
					"bulk2DeleteQueryJob",
					"raw",
					"subscribe",
					"pubSubSubscribe",
					"pubSubPublish"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.salesforce.internal.OperationName"
			},
			"topicName": {
				"title": "Topic Name",
				"description": "The name of the topic/channel to use",
				"type": "string",
				"$comment": "group:producer"
			},
			"apexMethod": {
				"title": "Apex Method",
				"description": "APEX method name",
				"type": "string",
				"$comment": "group:common"
			},
			"apexQueryParams": {
				"title": "Apex Query Params",
				"description": "Query params for APEX method",
				"type": "object",
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "Salesforce API version.",
				"type": "string",
				"$comment": "group:common",
				"default": "56.0"
			},
			"backoffIncrement": {
				"title": "Backoff Increment",
				"description": "Backoff interval increment for Streaming connection restart attempts for failures beyond CometD auto-reconnect.",
				"type": "string",
				"$comment": "group:common",
				"format": "duration",
				"default": "1000"
			},
			"batchId": {
				"title": "Batch Id",
				"description": "Bulk API Batch ID",
				"type": "string",
				"$comment": "group:common"
			},
			"contentType": {
				"title": "Content Type",
				"description": "Bulk API content type, one of XML, CSV, ZIP_XML, ZIP_CSV",
				"type": "string",
				"enum": [
					"XML",
					"CSV",
					"JSON",
					"ZIP_XML",
					"ZIP_CSV",
					"ZIP_JSON"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.salesforce.api.dto.bulk.ContentType"
			},
			"defaultReplayId": {
				"title": "Default Replay Id",
				"description": "Default replayId setting if no value is found in initialReplayIdMap",
				"type": "integer",
				"$comment": "group:common",
				"default": "-1"
			},
			"fallBackReplayId": {
				"title": "Fall Back Replay Id",
				"description": "ReplayId to fall back to after an Invalid Replay Id response",
				"type": "integer",
				"$comment": "group:common",
				"default": "-1"
			},
			"format": {
				"title": "Format",
				"description": "Payload format to use for Salesforce API calls, either JSON or XML, defaults to JSON. As of Camel 3.12, this option only applies to the Raw operation.",
				"type": "string",
				"enum": [
					"JSON",
					"XML"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.salesforce.internal.PayloadFormat"
			},
			"httpClient": {
				"title": "Http Client",
				"description": "Custom Jetty Http Client to use to connect to Salesforce.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.salesforce.SalesforceHttpClient"
			},
			"includeDetails": {
				"title": "Include Details",
				"description": "Include details in Salesforce1 Analytics report, defaults to false.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"initialReplayIdMap": {
				"title": "Initial Replay Id Map",
				"description": "Replay IDs to start from per channel name.",
				"type": "object",
				"$comment": "group:common"
			},
			"instanceId": {
				"title": "Instance Id",
				"description": "Salesforce1 Analytics report execution instance ID",
				"type": "string",
				"$comment": "group:common"
			},
			"jobId": {
				"title": "Job Id",
				"description": "Bulk API Job ID",
				"type": "string",
				"$comment": "group:common"
			},
			"limit": {
				"title": "Limit",
				"description": "Limit on number of returned records. Applicable to some of the API, check the Salesforce documentation.",
				"type": "integer",
				"$comment": "group:common"
			},
			"locator": {
				"title": "Locator",
				"description": "Locator provided by salesforce Bulk 2.0 API for use in getting results for a Query job.",
				"type": "string",
				"$comment": "group:common"
			},
			"maxBackoff": {
				"title": "Max Backoff",
				"description": "Maximum backoff interval for Streaming connection restart attempts for failures beyond CometD auto-reconnect.",
				"type": "string",
				"$comment": "group:common",
				"format": "duration",
				"default": "30000"
			},
			"maxRecords": {
				"title": "Max Records",
				"description": "The maximum number of records to retrieve per set of results for a Bulk 2.0 Query. The request is still subject to the size limits. If you are working with a very large number of query results, you may experience a timeout before receiving all the data from Salesforce. To prevent a timeout, specify the maximum number of records your client is expecting to receive in the maxRecords parameter. This splits the results into smaller sets with this value as the maximum size.",
				"type": "integer",
				"$comment": "group:common"
			},
			"notFoundBehaviour": {
				"title": "Not Found Behaviour",
				"description": "Sets the behaviour of 404 not found status received from Salesforce API. Should the body be set to NULL NotFoundBehaviour#NULL or should a exception be signaled on the exchange NotFoundBehaviour#EXCEPTION - the default.",
				"type": "string",
				"enum": [
					"EXCEPTION",
					"NULL"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.salesforce.NotFoundBehaviour",
				"default": "EXCEPTION"
			},
			"notifyForFields": {
				"title": "Notify For Fields",
				"description": "Notify for fields, options are ALL, REFERENCED, SELECT, WHERE",
				"type": "string",
				"enum": [
					"ALL",
					"REFERENCED",
					"SELECT",
					"WHERE"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.salesforce.internal.dto.NotifyForFieldsEnum"
			},
			"notifyForOperationCreate": {
				"title": "Notify For Operation Create",
				"description": "Notify for create operation, defaults to false (API version &gt;= 29.0)",
				"type": "boolean",
				"$comment": "group:common"
			},
			"notifyForOperationDelete": {
				"title": "Notify For Operation Delete",
				"description": "Notify for delete operation, defaults to false (API version &gt;= 29.0)",
				"type": "boolean",
				"$comment": "group:common"
			},
			"notifyForOperations": {
				"title": "Notify For Operations",
				"description": "Notify for operations, options are ALL, CREATE, EXTENDED, UPDATE (API version &lt; 29.0)",
				"type": "string",
				"enum": [
					"ALL",
					"CREATE",
					"EXTENDED",
					"UPDATE"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.salesforce.internal.dto.NotifyForOperationsEnum"
			},
			"notifyForOperationUndelete": {
				"title": "Notify For Operation Undelete",
				"description": "Notify for un-delete operation, defaults to false (API version &gt;= 29.0)",
				"type": "boolean",
				"$comment": "group:common"
			},
			"notifyForOperationUpdate": {
				"title": "Notify For Operation Update",
				"description": "Notify for update operation, defaults to false (API version &gt;= 29.0)",
				"type": "boolean",
				"$comment": "group:common"
			},
			"objectMapper": {
				"title": "Object Mapper",
				"description": "Custom Jackson ObjectMapper to use when serializing/deserializing Salesforce objects.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:com.fasterxml.jackson.databind.ObjectMapper"
			},
			"pkChunking": {
				"title": "Pk Chunking",
				"description": "Use PK Chunking. Only for use in original Bulk API. Bulk 2.0 API performs PK chunking automatically, if necessary.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"pkChunkingChunkSize": {
				"title": "Pk Chunking Chunk Size",
				"description": "Chunk size for use with PK Chunking. If unspecified, salesforce default is 100,000. Maximum size is 250,000.",
				"type": "integer",
				"$comment": "group:common"
			},
			"pkChunkingParent": {
				"title": "Pk Chunking Parent",
				"description": "Specifies the parent object when you're enabling PK chunking for queries on sharing objects. The chunks are based on the parent object's records rather than the sharing object's records. For example, when querying on AccountShare, specify Account as the parent object. PK chunking is supported for sharing objects as long as the parent object is supported.",
				"type": "string",
				"$comment": "group:common"
			},
			"pkChunkingStartRow": {
				"title": "Pk Chunking Start Row",
				"description": "Specifies the 15-character or 18-character record ID to be used as the lower boundary for the first chunk. Use this parameter to specify a starting ID when restarting a job that failed between batches.",
				"type": "string",
				"$comment": "group:common"
			},
			"queryLocator": {
				"title": "Query Locator",
				"description": "Query Locator provided by salesforce for use when a query results in more records than can be retrieved in a single call. Use this value in a subsequent call to retrieve additional records.",
				"type": "string",
				"$comment": "group:common"
			},
			"rawPayload": {
				"title": "Raw Payload",
				"description": "Use raw payload String for request and response (either JSON or XML depending on format), instead of DTOs, false by default",
				"type": "boolean",
				"$comment": "group:common"
			},
			"reportId": {
				"title": "Report Id",
				"description": "Salesforce1 Analytics report Id",
				"type": "string",
				"$comment": "group:common"
			},
			"reportMetadata": {
				"title": "Report Metadata",
				"description": "Salesforce1 Analytics report metadata for filtering",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.salesforce.api.dto.analytics.reports.ReportMetadata"
			},
			"resultId": {
				"title": "Result Id",
				"description": "Bulk API Result ID",
				"type": "string",
				"$comment": "group:common"
			},
			"sObjectBlobFieldName": {
				"title": "SObject Blob Field Name",
				"description": "SObject blob field name",
				"type": "string",
				"$comment": "group:common"
			},
			"sObjectClass": {
				"title": "SObject Class",
				"description": "Fully qualified SObject class name, usually generated using camel-salesforce-maven-plugin",
				"type": "string",
				"$comment": "group:common"
			},
			"sObjectFields": {
				"title": "SObject Fields",
				"description": "SObject fields to retrieve",
				"type": "string",
				"$comment": "group:common"
			},
			"sObjectId": {
				"title": "SObject Id",
				"description": "SObject ID if required by API",
				"type": "string",
				"$comment": "group:common"
			},
			"sObjectIdName": {
				"title": "SObject Id Name",
				"description": "SObject external ID field name",
				"type": "string",
				"$comment": "group:common"
			},
			"sObjectIdValue": {
				"title": "SObject Id Value",
				"description": "SObject external ID field value",
				"type": "string",
				"$comment": "group:common"
			},
			"sObjectName": {
				"title": "SObject Name",
				"description": "SObject name if required or supported by API",
				"type": "string",
				"$comment": "group:common"
			},
			"sObjectQuery": {
				"title": "SObject Query",
				"description": "Salesforce SOQL query string",
				"type": "string",
				"$comment": "group:common"
			},
			"sObjectSearch": {
				"title": "SObject Search",
				"description": "Salesforce SOSL search string",
				"type": "string",
				"$comment": "group:common"
			},
			"streamQueryResult": {
				"title": "Stream query result",
				"description": "If true, streams SOQL query result and transparently handles subsequent requests if there are multiple pages. Otherwise, results are returned one page at a time.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"updateTopic": {
				"title": "Update Topic",
				"description": "Whether to update an existing Push Topic when using the Streaming API, defaults to false",
				"type": "boolean",
				"$comment": "group:common"
			},
			"pubSubBatchSize": {
				"title": "Pub Sub Batch Size",
				"description": "Max number of events to receive in a batch from the Pub/Sub API.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 100
			},
			"pubSubDeserializeType": {
				"title": "Pub Sub Deserialize Type",
				"description": "How to deserialize events consume from the Pub/Sub API. AVRO will try a SpecificRecord subclass if found, otherwise GenericRecord.",
				"type": "string",
				"enum": [
					"AVRO",
					"SPECIFIC_RECORD",
					"GENERIC_RECORD",
					"POJO",
					"JSON"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.salesforce.PubSubDeserializeType",
				"default": "AVRO"
			},
			"pubSubPojoClass": {
				"title": "Pub Sub Pojo Class",
				"description": "Fully qualified class name to deserialize Pub/Sub API event to.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"pubSubReplayId": {
				"title": "Pub Sub Replay Id",
				"description": "The replayId value to use when subscribing to the Pub/Sub API.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"replayId": {
				"title": "Replay Id",
				"description": "The replayId value to use when subscribing to the Streaming API.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"replayPreset": {
				"title": "Replay Preset",
				"description": "Replay preset for Pub/Sub API.",
				"type": "string",
				"enum": [
					"LATEST",
					"EARLIEST",
					"CUSTOM"
				],
				"$comment": "group:consumer",
				"format": "bean:com.salesforce.eventbus.protobuf.ReplayPreset",
				"default": "LATEST"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"allOrNone": {
				"title": "All Or None",
				"description": "Composite API option to indicate to rollback all records if any are not successful.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"apexUrl": {
				"title": "Apex Url",
				"description": "APEX method URL",
				"type": "string",
				"$comment": "group:producer"
			},
			"compositeMethod": {
				"title": "Composite Method",
				"description": "Composite (raw) method.",
				"type": "string",
				"$comment": "group:producer"
			},
			"eventName": {
				"title": "Event Name",
				"description": "Name of Platform Event, Change Data Capture Event, custom event, etc.",
				"type": "string",
				"$comment": "group:producer"
			},
			"eventSchemaFormat": {
				"title": "Event Schema Format",
				"description": "EXPANDED: Apache Avro format but doesn't strictly adhere to the record complex type. COMPACT: Apache Avro, adheres to the specification for the record complex type. This parameter is available in API version 43.0 and later.",
				"type": "string",
				"enum": [
					"EXPANDED",
					"COMPACT"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.salesforce.internal.dto.EventSchemaFormatEnum"
			},
			"eventSchemaId": {
				"title": "Event Schema Id",
				"description": "The ID of the event schema.",
				"type": "string",
				"$comment": "group:producer"
			},
			"rawHttpHeaders": {
				"title": "Raw Http Headers",
				"description": "Comma separated list of message headers to include as HTTP parameters for Raw operation.",
				"type": "string",
				"$comment": "group:producer"
			},
			"rawMethod": {
				"title": "Raw Method",
				"description": "HTTP method to use for the Raw operation",
				"type": "string",
				"$comment": "group:producer"
			},
			"rawPath": {
				"title": "Raw Path",
				"description": "The portion of the endpoint URL after the domain name. E.g., '/services/data/v52.0/sobjects/Account/'",
				"type": "string",
				"$comment": "group:producer"
			},
			"rawQueryParameters": {
				"title": "Raw Query Parameters",
				"description": "Comma separated list of message headers to include as query parameters for Raw operation. Do not url-encode values as this will be done automatically.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operationName"
		]
	},
	"sap-netweaver": {
		"properties": {
			"url": {
				"title": "Url",
				"description": "Url to the SAP net-weaver gateway server.",
				"type": "string",
				"$comment": "group:producer"
			},
			"flatternMap": {
				"title": "Flattern Map",
				"description": "If the JSON Map contains only a single entry, then flattern by storing that single entry value as the message body.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"json": {
				"title": "Json",
				"description": "Whether to return data in JSON format. If this option is false, then XML is returned in Atom format.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"jsonAsMap": {
				"title": "Json As Map",
				"description": "To transform the JSON from a String to a Map in the message body.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password for account.",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username for account.",
				"type": "string",
				"$comment": "group:producer",
				"format": "password"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"url",
			"password",
			"username"
		]
	},
	"scheduler": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The name of the scheduler",
				"type": "string",
				"$comment": "group:consumer"
			},
			"includeMetadata": {
				"title": "Include Metadata",
				"description": "Whether to include metadata in the exchange such as fired time, timer name, timer count etc.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "Number of core threads in the thread pool used by the scheduling thread pool. Is by default using a single thread",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"schematron": {
		"properties": {
			"path": {
				"title": "Path",
				"description": "The path to the schematron rules file. Can either be in class path or location in the file system.",
				"type": "string",
				"$comment": "group:producer"
			},
			"abort": {
				"title": "Abort",
				"description": "Flag to abort the route and throw a schematron validation exception.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"rules": {
				"title": "Rules",
				"description": "To use the given schematron rules instead of loading from the path",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:javax.xml.transform.Templates"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"uriResolver": {
				"title": "Uri Resolver",
				"description": "Set the URIResolver to be used for resolving schematron includes in the rules file.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.URIResolver"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"path"
		]
	},
	"scp": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname of the FTP server",
				"type": "string",
				"$comment": "group:producer"
			},
			"port": {
				"title": "Port",
				"description": "Port of the FTP server",
				"type": "integer",
				"$comment": "group:producer"
			},
			"directoryName": {
				"title": "Directory Name",
				"description": "The starting directory",
				"type": "string",
				"$comment": "group:producer"
			},
			"checksumFileAlgorithm": {
				"title": "Checksum File Algorithm",
				"description": "If provided, then Camel will write a checksum file when the original file has been written. The checksum file will contain the checksum created with the provided algorithm for the original file. The checksum file will always be written in the same folder as the original file.",
				"type": "string",
				"enum": [
					"MD2",
					"MD5",
					"SHA_1",
					"SHA_224",
					"SHA_256",
					"SHA_384",
					"SHA_512",
					"SHA_512_224",
					"SHA_512_256",
					"SHA3_224",
					"SHA3_256",
					"SHA3_384",
					"SHA3_512"
				],
				"$comment": "group:producer"
			},
			"chmod": {
				"title": "Chmod",
				"description": "Allows you to set chmod on the stored file. For example chmod=664.",
				"type": "string",
				"$comment": "group:producer",
				"default": "664"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"fileName": {
				"title": "File Name",
				"description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
				"type": "string",
				"$comment": "group:producer"
			},
			"flatten": {
				"title": "Flatten",
				"description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"jailStartingDirectory": {
				"title": "Jail Starting Directory",
				"description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"strictHostKeyChecking": {
				"title": "Strict Host Key Checking",
				"description": "Sets whether to use strict host key checking. Possible values are: no, yes",
				"type": "string",
				"enum": [
					"no",
					"yes"
				],
				"$comment": "group:producer",
				"default": "no"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"disconnectOnBatchComplete": {
				"title": "Disconnect On Batch Complete",
				"description": "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"moveExistingFileStrategy": {
				"title": "Move Existing File Strategy",
				"description": "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.file.strategy.FileMoveExistingStrategy"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "10000"
			},
			"soTimeout": {
				"title": "So Timeout",
				"description": "Sets the so timeout FTP and FTPS Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "300000"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets the data timeout for waiting for reply Used only by FTPClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "30000"
			},
			"knownHostsFile": {
				"title": "Known Hosts File",
				"description": "Sets the known_hosts file, so that the jsch endpoint can do host key verification. You can prefix with classpath: to load the file from classpath instead of file system.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"preferredAuthentications": {
				"title": "Preferred Authentications",
				"description": "Set a comma separated list of authentications that will be used in order of preference. Possible authentication methods are defined by JCraft JSCH. Some examples include: gssapi-with-mic,publickey,keyboard-interactive,password If not specified the JSCH and/or system defaults will be used.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privateKeyBytes": {
				"title": "Private Key Bytes",
				"description": "Set the private key bytes to that the endpoint can do private key verification. This must be used only if privateKeyFile wasn't set. Otherwise the file will have the priority.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privateKeyFile": {
				"title": "Private Key File",
				"description": "Set the private key file to that the endpoint can do private key verification. You can prefix with classpath: to load the file from classpath instead of file system.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privateKeyFilePassphrase": {
				"title": "Private Key File Passphrase",
				"description": "Set the private key file passphrase to that the endpoint can do private key verification.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"useUserKnownHostsFile": {
				"title": "Use User Known Hosts File",
				"description": "If knownHostFile has not been explicit configured, then use the host file from System.getProperty(user.home) /.ssh/known_hosts",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"ciphers": {
				"title": "Ciphers",
				"description": "Set a comma separated list of ciphers that will be used in order of preference. Possible cipher names are defined by JCraft JSCH. Some examples include: aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc. If not specified the default list from JSCH will be used.",
				"type": "string",
				"$comment": "group:security (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"seda": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of queue",
				"type": "string",
				"$comment": "group:common"
			},
			"size": {
				"title": "Size",
				"description": "The maximum capacity of the SEDA queue (i.e., the number of messages it can hold). Will by default use the defaultSize set on the SEDA component.",
				"type": "integer",
				"$comment": "group:common",
				"default": 1000
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Number of concurrent threads processing exchanges.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"limitConcurrentConsumers": {
				"title": "Limit Concurrent Consumers",
				"description": "Whether to limit the number of concurrentConsumers to the maximum of 500. By default, an exception will be thrown if an endpoint is configured with a greater number. You can disable that check by turning this option off.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"multipleConsumers": {
				"title": "Multiple Consumers",
				"description": "Specifies whether multiple consumers are allowed. If enabled, you can use SEDA for Publish-Subscribe messaging. That is, you can send a message to the SEDA queue and have each consumer receive a copy of the message. When enabled, this option should be specified on every consumer endpoint.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"pollTimeout": {
				"title": "Poll Timeout",
				"description": "The timeout (in milliseconds) used when polling. When a timeout occurs, the consumer can check whether it is allowed to continue running. Setting a lower value allows the consumer to react more quickly upon shutdown.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": 1000
			},
			"purgeWhenStopping": {
				"title": "Purge When Stopping",
				"description": "Whether to purge the task queue when stopping the consumer/route. This allows to stop faster, as any pending messages on the queue is discarded.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"blockWhenFull": {
				"title": "Block When Full",
				"description": "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"discardIfNoConsumers": {
				"title": "Discard If No Consumers",
				"description": "Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"discardWhenFull": {
				"title": "Discard When Full",
				"description": "Whether a thread that sends messages to a full SEDA queue will be discarded. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will give up sending and continue, meaning that the message was not sent to the SEDA queue.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"failIfNoConsumers": {
				"title": "Fail If No Consumers",
				"description": "Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"offerTimeout": {
				"title": "Offer Timeout",
				"description": "Offer timeout (in milliseconds) can be added to the block case when queue is full. You can disable timeout by using 0 or a negative value.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Timeout (in milliseconds) before a SEDA producer will stop waiting for an asynchronous task to complete. You can disable timeout by using 0 or a negative value.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "30000"
			},
			"waitForTaskToComplete": {
				"title": "Wait For Task To Complete",
				"description": "Option to specify whether the caller should wait for the async task to complete or not before continuing. The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory. The last value, IfReplyExpected, will only wait if the message is Request Reply based. The default option is IfReplyExpected.",
				"type": "string",
				"enum": [
					"Never",
					"IfReplyExpected",
					"Always"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.WaitForTaskToComplete",
				"default": "IfReplyExpected"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"queue": {
				"title": "Queue",
				"description": "Define the queue instance which will be used by the endpoint",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.concurrent.BlockingQueue<org.apache.camel.Exchange>"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"service": {
		"properties": {
			"delegateUri": {
				"title": "Delegate Uri",
				"description": "The endpoint uri to expose as service",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"delegateUri"
		]
	},
	"servicenow": {
		"properties": {
			"instanceName": {
				"title": "Instance Name",
				"description": "The ServiceNow instance name",
				"type": "string",
				"$comment": "group:producer"
			},
			"display": {
				"title": "Display",
				"description": "Set this parameter to true to return only scorecards where the indicator Display field is selected. Set this parameter to all to return scorecards with any Display field value. This parameter is true by default.",
				"type": "string",
				"enum": [
					"false",
					"true",
					"all"
				],
				"$comment": "group:producer",
				"default": "true"
			},
			"displayValue": {
				"title": "Display Value",
				"description": "Return the display value (true), actual value (false), or both (all) for reference fields (default: false)",
				"type": "string",
				"enum": [
					"false",
					"true",
					"all"
				],
				"$comment": "group:producer",
				"default": "false"
			},
			"excludeReferenceLink": {
				"title": "Exclude Reference Link",
				"description": "True to exclude Table API links for reference fields (default: false)",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"favorites": {
				"title": "Favorites",
				"description": "Set this parameter to true to return only scorecards that are favorites of the querying user.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"includeAggregates": {
				"title": "Include Aggregates",
				"description": "Set this parameter to true to always return all available aggregates for an indicator, including when an aggregate has already been applied. If a value is not specified, this parameter defaults to false and returns no aggregates.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"includeAvailableAggregates": {
				"title": "Include Available Aggregates",
				"description": "Set this parameter to true to return all available aggregates for an indicator when no aggregate has been applied. If a value is not specified, this parameter defaults to false and returns no aggregates.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"includeAvailableBreakdowns": {
				"title": "Include Available Breakdowns",
				"description": "Set this parameter to true to return all available breakdowns for an indicator. If a value is not specified, this parameter defaults to false and returns no breakdowns.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"includeScoreNotes": {
				"title": "Include Score Notes",
				"description": "Set this parameter to true to return all notes associated with the score. The note element contains the note text as well as the author and timestamp when the note was added.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"includeScores": {
				"title": "Include Scores",
				"description": "Set this parameter to true to return all scores for a scorecard. If a value is not specified, this parameter defaults to false and returns only the most recent score value.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"inputDisplayValue": {
				"title": "Input Display Value",
				"description": "True to set raw value of input fields (default: false)",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"key": {
				"title": "Key",
				"description": "Set this parameter to true to return only scorecards for key indicators.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"models": {
				"title": "Models",
				"description": "Defines both request and response models",
				"type": "object",
				"$comment": "group:producer"
			},
			"perPage": {
				"title": "Per Page",
				"description": "Enter the maximum number of scorecards each query can return. By default this value is 10, and the maximum is 100.",
				"type": "integer",
				"$comment": "group:producer",
				"default": "10"
			},
			"release": {
				"title": "Release",
				"description": "The ServiceNow release to target, default to Helsinki See https://docs.servicenow.com",
				"type": "string",
				"enum": [
					"FUJI",
					"GENEVA",
					"HELSINKI"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.servicenow.ServiceNowRelease",
				"default": "HELSINKI"
			},
			"requestModels": {
				"title": "Request Models",
				"description": "Defines the request model",
				"type": "object",
				"$comment": "group:producer"
			},
			"resource": {
				"title": "Resource",
				"description": "The default resource, can be overridden by header CamelServiceNowResource",
				"type": "string",
				"$comment": "group:producer"
			},
			"responseModels": {
				"title": "Response Models",
				"description": "Defines the response model",
				"type": "object",
				"$comment": "group:producer"
			},
			"sortBy": {
				"title": "Sort By",
				"description": "Specify the value to use when sorting results. By default, queries sort records by value.",
				"type": "string",
				"enum": [
					"value",
					"change",
					"changeperc",
					"gap",
					"gapperc",
					"duedate",
					"name",
					"order",
					"default",
					"group",
					"indicator_group",
					"frequency",
					"target",
					"date",
					"trend",
					"bullet",
					"direction"
				],
				"$comment": "group:producer"
			},
			"sortDir": {
				"title": "Sort Dir",
				"description": "Specify the sort direction, ascending or descending. By default, queries sort records in descending order. Use sysparm_sortdir=asc to sort in ascending order.",
				"type": "string",
				"enum": [
					"asc",
					"desc"
				],
				"$comment": "group:producer"
			},
			"suppressAutoSysField": {
				"title": "Suppress Auto Sys Field",
				"description": "True to suppress auto generation of system fields (default: false)",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"suppressPaginationHeader": {
				"title": "Suppress Pagination Header",
				"description": "Set this value to true to remove the Link header from the response. The Link header allows you to request additional pages of data when the number of records matching your query exceeds the query limit",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"table": {
				"title": "Table",
				"description": "The default table, can be overridden by header CamelServiceNowTable",
				"type": "string",
				"$comment": "group:producer"
			},
			"target": {
				"title": "Target",
				"description": "Set this parameter to true to return only scorecards that have a target.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"topLevelOnly": {
				"title": "Top Level Only",
				"description": "Gets only those categories whose parent is a catalog.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The ServiceNow REST API version, default latest",
				"type": "string",
				"$comment": "group:advanced"
			},
			"dateFormat": {
				"title": "Date Format",
				"description": "The date format used for Json serialization/deserialization",
				"type": "string",
				"$comment": "group:advanced",
				"default": "yyyy-MM-dd"
			},
			"dateTimeFormat": {
				"title": "Date Time Format",
				"description": "The date-time format used for Json serialization/deserialization",
				"type": "string",
				"$comment": "group:advanced",
				"default": "yyyy-MM-dd HH:mm:ss"
			},
			"httpClientPolicy": {
				"title": "Http Client Policy",
				"description": "To configure http-client",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.cxf.transports.http.configuration.HTTPClientPolicy"
			},
			"mapper": {
				"title": "Mapper",
				"description": "Sets Jackson's ObjectMapper to use for request/reply",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.fasterxml.jackson.databind.ObjectMapper"
			},
			"proxyAuthorizationPolicy": {
				"title": "Proxy Authorization Policy",
				"description": "To configure proxy authentication",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.cxf.configuration.security.ProxyAuthorizationPolicy"
			},
			"retrieveTargetRecordOnImport": {
				"title": "Retrieve Target Record On Import",
				"description": "Set this parameter to true to retrieve the target record when using import set api. The import set result is then replaced by the target record",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"timeFormat": {
				"title": "Time Format",
				"description": "The time format used for Json serialization/deserialization",
				"type": "string",
				"$comment": "group:advanced",
				"default": "HH:mm:ss"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "The proxy host name",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "The proxy port number",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"apiUrl": {
				"title": "Api Url",
				"description": "The ServiceNow REST API url",
				"type": "string",
				"$comment": "group:security"
			},
			"oauthClientId": {
				"title": "Oauth Client Id",
				"description": "OAuth2 ClientID",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthClientSecret": {
				"title": "Oauth Client Secret",
				"description": "OAuth2 ClientSecret",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"oauthTokenUrl": {
				"title": "Oauth Token Url",
				"description": "OAuth token Url",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "ServiceNow account password, MUST be provided",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"proxyPassword": {
				"title": "Proxy Password",
				"description": "Password for proxy authentication",
				"type": "string",
				"$comment": "group:security"
			},
			"proxyUserName": {
				"title": "Proxy User Name",
				"description": "Username for proxy authentication",
				"type": "string",
				"$comment": "group:security"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters. See http://camel.apache.org/camel-configuration-utilities.html",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"userName": {
				"title": "User Name",
				"description": "ServiceNow user account name, MUST be provided",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"instanceName",
			"password",
			"userName"
		]
	},
	"servlet": {
		"properties": {
			"contextPath": {
				"title": "Context Path",
				"description": "The context-path to use",
				"type": "string",
				"$comment": "group:consumer"
			},
			"disableStreamCache": {
				"title": "Disable Stream Cache",
				"description": "Determines whether or not the raw input stream is cached or not. The Camel consumer (camel-servlet, camel-jetty etc.) will by default cache the input stream to support reading it multiple times to ensure it Camel can retrieve all data from the stream. However you can set this option to true when you for example need to access the raw stream, such as streaming it directly to a file or other persistent store. DefaultHttpBinding will copy the request input stream into a stream cache and put it into message body if this option is false to support reading the stream multiple times. If you use Servlet to bridge/proxy an endpoint then consider enabling this option to improve performance, in case you do not need to read the message payload multiple times. The producer (camel-http) will by default cache the response body stream. If setting this option to true, then the producers will not cache the response body stream but use the response stream as-is (the stream can only be read once) as the message body.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:common (advanced)",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"httpBinding": {
				"title": "Http Binding",
				"description": "To use a custom HttpBinding to control the mapping between Camel message and HttpClient.",
				"type": "string",
				"$comment": "group:common (advanced)",
				"format": "bean:org.apache.camel.http.common.HttpBinding"
			},
			"chunked": {
				"title": "Chunked",
				"description": "If this option is false the Servlet will disable the HTTP streaming and set the content-length header on the response",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"async": {
				"title": "Async",
				"description": "Configure the consumer to work in async mode",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"httpMethodRestrict": {
				"title": "Http Method Restrict",
				"description": "Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"logException": {
				"title": "Log Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side the exception's stack trace will be logged when the exception stack trace is not sent in the response's body.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"matchOnUriPrefix": {
				"title": "Match On Uri Prefix",
				"description": "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"muteException": {
				"title": "Mute Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"responseBufferSize": {
				"title": "Response Buffer Size",
				"description": "To use a custom buffer size on the jakarta.servlet.ServletResponse.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"servletName": {
				"title": "Servlet Name",
				"description": "Name of the servlet to use",
				"type": "string",
				"$comment": "group:consumer",
				"default": "CamelServlet"
			},
			"attachmentMultipartBinding": {
				"title": "Attachment Multipart Binding",
				"description": "Whether to automatic bind multipart/form-data as attachments on the Camel Exchange. The options attachmentMultipartBinding=true and disableStreamCache=false cannot work together. Remove disableStreamCache to use AttachmentMultipartBinding. This is turn off by default as this may require servlet specific configuration to enable this when using Servlet's.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerCheckContentAvailable": {
				"title": "Eager Check Content Available",
				"description": "Whether to eager check whether the HTTP requests has content if the content-length header is 0 or not present. This can be turned on in case HTTP clients do not send streamed data.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"fileNameExtWhitelist": {
				"title": "File Name Ext Whitelist",
				"description": "Whitelist of accepted filename extensions for accepting uploaded files. Multiple extensions can be separated by comma, such as txt,xml.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"mapHttpMessageBody": {
				"title": "Map Http Message Body",
				"description": "If this option is true then IN exchange Body of the exchange will be mapped to HTTP body. Setting this to false will avoid the HTTP mapping.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"mapHttpMessageFormUrlEncodedBody": {
				"title": "Map Http Message Form Url Encoded Body",
				"description": "If this option is true then IN exchange Form Encoded body of the exchange will be mapped to HTTP. Setting this to false will avoid the HTTP Form Encoded body mapping.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"mapHttpMessageHeaders": {
				"title": "Map Http Message Headers",
				"description": "If this option is true then IN exchange Headers of the exchange will be mapped to HTTP headers. Setting this to false will avoid the HTTP Headers mapping.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"optionsEnabled": {
				"title": "Options Enabled",
				"description": "Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"traceEnabled": {
				"title": "Trace Enabled",
				"description": "Specifies whether to enable HTTP TRACE for this Servlet consumer. By default TRACE is turned off.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"contextPath"
		]
	},
	"sftp": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname of the FTP server",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port of the FTP server",
				"type": "integer",
				"$comment": "group:common"
			},
			"directoryName": {
				"title": "Directory Name",
				"description": "The starting directory",
				"type": "string",
				"$comment": "group:common"
			},
			"binary": {
				"title": "Binary",
				"description": "Specifies the file transfer mode, BINARY or ASCII. Default is ASCII (false).",
				"type": "boolean",
				"$comment": "group:common"
			},
			"charset": {
				"title": "Charset",
				"description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
				"type": "string",
				"$comment": "group:common"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether or not to disconnect from remote FTP server right after use. Disconnect will only disconnect the current connection to the FTP server. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"doneFileName": {
				"title": "Done File Name",
				"description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
				"type": "string",
				"$comment": "group:common"
			},
			"fileName": {
				"title": "File Name",
				"description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
				"type": "string",
				"$comment": "group:common"
			},
			"jschLoggingLevel": {
				"title": "Jsch Logging Level",
				"description": "The logging level to use for JSCH activity logging. As JSCH is verbose at by default at INFO level the threshold is WARN by default.",
				"type": "string",
				"enum": [
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "WARN"
			},
			"passiveMode": {
				"title": "Passive Mode",
				"description": "Sets passive mode connections. Default is active mode connections.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"separator": {
				"title": "Separator",
				"description": "Sets the path separator to be used. UNIX = Uses unix style path separator Windows = Uses windows style path separator Auto = (is default) Use existing path separator in file name",
				"type": "string",
				"enum": [
					"UNIX",
					"Windows",
					"Auto"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.file.remote.RemoteFileConfiguration.PathSeparator",
				"default": "UNIX"
			},
			"fastExistsCheck": {
				"title": "Fast Exists Check",
				"description": "If set this option to be true, camel-ftp will use the list file directly to check if the file exists. Since some FTP server may not support to list the file directly, if the option is false, camel-ftp will use the old way to list the directory and check if the file exists. This option also influences readLock=changed to control whether it performs a fast check to update file information or not. This can be used to speed up the process if the FTP server has a lot of files.",
				"type": "boolean",
				"$comment": "group:common (advanced)"
			},
			"delete": {
				"title": "Delete",
				"description": "If true, the file will be deleted after it is processed successfully.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveFailed": {
				"title": "Move Failed",
				"description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"noop": {
				"title": "Noop",
				"description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"preMove": {
				"title": "Pre Move",
				"description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"preSort": {
				"title": "Pre Sort",
				"description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"recursive": {
				"title": "Recursive",
				"description": "If a directory, will look for files in all the sub-directories as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"streamDownload": {
				"title": "Stream Download",
				"description": "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route. If enabling this option then you must set stepwise=false as both cannot be enabled at the same time.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"download": {
				"title": "Download",
				"description": "Whether the FTP consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"ignoreFileNotFoundOrPermissionError": {
				"title": "Ignore File Not Found Or Permission Error",
				"description": "Whether to ignore when (trying to list files in directories or when downloading a file), which does not exist or due to permission error. By default when a directory or file does not exist or insufficient permission, then an exception is thrown. Setting this option to true allows to ignore that instead.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"inProgressRepository": {
				"title": "In Progress Repository",
				"description": "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"localWorkDirectory": {
				"title": "Local Work Directory",
				"description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"onCompletionExceptionHandler": {
				"title": "On Completion Exception Handler",
				"description": "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"processStrategy": {
				"title": "Process Strategy",
				"description": "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.file.GenericFileProcessStrategy<org.apache.camel.component.file.remote.SftpRemoteFile>"
			},
			"throwExceptionOnConnectFailed": {
				"title": "Throw Exception On Connect Failed",
				"description": "Should an exception be thrown if connection failed (exhausted)By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the org.apache.camel.spi.PollingConsumerPollStrategy rollback method.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"useList": {
				"title": "Use List",
				"description": "Whether to allow using LIST command when downloading a file. Default is true. In some use cases you may want to download a specific file and are not allowed to use the LIST command, and therefore you can set this option to false. Notice when using this option, then the specific file to download does not include meta-data information such as file size, timestamp, permissions etc, because those information is only possible to retrieve when LIST command is in use.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"checksumFileAlgorithm": {
				"title": "Checksum File Algorithm",
				"description": "If provided, then Camel will write a checksum file when the original file has been written. The checksum file will contain the checksum created with the provided algorithm for the original file. The checksum file will always be written in the same folder as the original file.",
				"type": "string",
				"enum": [
					"MD2",
					"MD5",
					"SHA_1",
					"SHA_224",
					"SHA_256",
					"SHA_384",
					"SHA_512",
					"SHA_512_224",
					"SHA_512_256",
					"SHA3_224",
					"SHA3_256",
					"SHA3_384",
					"SHA3_512"
				],
				"$comment": "group:producer"
			},
			"fileExist": {
				"title": "File Exist",
				"description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
				"type": "string",
				"enum": [
					"Override",
					"Append",
					"Fail",
					"Ignore",
					"Move",
					"TryRename"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.file.GenericFileExist",
				"default": "Override"
			},
			"flatten": {
				"title": "Flatten",
				"description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"jailStartingDirectory": {
				"title": "Jail Starting Directory",
				"description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"moveExisting": {
				"title": "Move Existing",
				"description": "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempFileName": {
				"title": "Temp File Name",
				"description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempPrefix": {
				"title": "Temp Prefix",
				"description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"chmod": {
				"title": "Chmod",
				"description": "Allows you to set chmod on the stored file. For example chmod=640.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"chmodDirectory": {
				"title": "Chmod Directory",
				"description": "Allows you to set chmod during path creation. For example chmod=640.",
				"type": "string",
				"$comment": "group:producer (advanced)"
			},
			"disconnectOnBatchComplete": {
				"title": "Disconnect On Batch Complete",
				"description": "Whether or not to disconnect from remote FTP server right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the FTP server.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"eagerDeleteTargetFile": {
				"title": "Eager Delete Target File",
				"description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"keepLastModified": {
				"title": "Keep Last Modified",
				"description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"moveExistingFileStrategy": {
				"title": "Move Existing File Strategy",
				"description": "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.file.strategy.FileMoveExistingStrategy"
			},
			"sendNoop": {
				"title": "Send Noop",
				"description": "Whether to send a noop command as a pre-write check before uploading files to the FTP server. This is enabled by default as a validation of the connection is still valid, which allows to silently re-connect to be able to upload the file. However if this causes problems, you can turn this option off.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"autoCreate": {
				"title": "Auto Create",
				"description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"bindAddress": {
				"title": "Bind Address",
				"description": "Specifies the address of the local interface against which the connection should bind.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"bulkRequests": {
				"title": "Bulk Requests",
				"description": "Specifies how many requests may be outstanding at any one time. Increasing this value may slightly improve file transfer speed but will increase memory usage.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"compression": {
				"title": "Compression",
				"description": "To use compression. Specify a level from 1 to 10. Important: You must manually add the needed JSCH zlib JAR to the classpath for compression support.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "Sets the connect timeout for waiting for a connection to be established Used by both FTPClient and JSCH",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "10000"
			},
			"existDirCheckUsingLs": {
				"title": "Exist Dir Check Using Ls",
				"description": "Whether to check for existing directory using LS command or CD. By default LS is used which is safer as otherwise Camel needs to change the directory back after checking. However LS has been reported to cause a problem on windows system in some situations and therefore you can disable this option to use CD.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"filenameEncoding": {
				"title": "Filename Encoding",
				"description": "Encoding to use for FTP client when parsing filenames. By default, UTF-8 is used.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"maximumReconnectAttempts": {
				"title": "Maximum Reconnect Attempts",
				"description": "Specifies the maximum reconnect attempts Camel performs when it tries to connect to the remote FTP server. Use 0 to disable this behavior.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"proxy": {
				"title": "Proxy",
				"description": "To use a custom configured com.jcraft.jsch.Proxy. This proxy is used to consume/send messages from the target SFTP host.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.jcraft.jsch.Proxy"
			},
			"reconnectDelay": {
				"title": "Reconnect Delay",
				"description": "Delay in millis Camel will wait before performing a reconnect attempt.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "1000"
			},
			"serverAliveCountMax": {
				"title": "Server Alive Count Max",
				"description": "Sets the number of keep-alive messages which may be sent without receiving any messages back from the server. If this threshold is reached while keep-alive messages are being sent, the connection will be disconnected. The default value is one.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1
			},
			"serverAliveInterval": {
				"title": "Server Alive Interval",
				"description": "Sets the interval (millis) to send a keep-alive message. If zero is specified, any keep-alive message must not be sent. The default interval is zero.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"serverMessageLoggingLevel": {
				"title": "Server Message Logging Level",
				"description": "The logging level used for various human intended log messages from the FTP server. This can be used during troubleshooting to raise the logging level and inspect the logs received from the FTP server.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"soTimeout": {
				"title": "So Timeout",
				"description": "Sets the so timeout FTP and FTPS Is the SocketOptions.SO_TIMEOUT value in millis. Recommended option is to set this to 300000 so as not have a hanged connection. On SFTP this option is set as timeout on the JSCH Session instance.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "300000"
			},
			"stepwise": {
				"title": "Stepwise",
				"description": "Sets whether we should stepwise change directories while traversing file structures when downloading files, or as well when uploading a file to a directory. You can disable this if you for example are in a situation where you cannot change directory on the FTP server due security reasons. Stepwise cannot be used together with streamDownload.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets the data timeout for waiting for reply Used only by FTPClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "30000"
			},
			"antExclude": {
				"title": "Ant Exclude",
				"description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"antFilterCaseSensitive": {
				"title": "Ant Filter Case Sensitive",
				"description": "Sets case sensitive flag on ant filter.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"antInclude": {
				"title": "Ant Include",
				"description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"eagerMaxMessagesPerPoll": {
				"title": "Eager Max Messages Per Poll",
				"description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"exclude": {
				"title": "Exclude",
				"description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"excludeExt": {
				"title": "Exclude Ext",
				"description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"filter": {
				"title": "Filter",
				"description": "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.component.file.GenericFileFilter<org.apache.camel.component.file.remote.SftpRemoteFile>"
			},
			"filterDirectory": {
				"title": "Filter Directory",
				"description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
				"type": "string",
				"$comment": "group:filter"
			},
			"filterFile": {
				"title": "Filter File",
				"description": "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotent": {
				"title": "Idempotent",
				"description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:filter"
			},
			"idempotentEager": {
				"title": "Idempotent Eager",
				"description": "Sets whether to eagerly add the filename to the idempotent repository or wait until the exchange is complete.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"idempotentKey": {
				"title": "Idempotent Key",
				"description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryIdempotentRepository if none is specified and idempotent is true.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"include": {
				"title": "Include",
				"description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"includeExt": {
				"title": "Include Ext",
				"description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"maxDepth": {
				"title": "Max Depth",
				"description": "The maximum depth to traverse when recursively processing a directory.",
				"type": "integer",
				"$comment": "group:filter",
				"default": 2147483647
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"minDepth": {
				"title": "Min Depth",
				"description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"move": {
				"title": "Move",
				"description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
				"type": "string",
				"$comment": "group:filter"
			},
			"exclusiveReadLockStrategy": {
				"title": "Exclusive Read Lock Strategy",
				"description": "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
				"type": "string",
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy<org.apache.camel.component.file.remote.SftpRemoteFile>"
			},
			"readLock": {
				"title": "Read Lock",
				"description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
				"type": "string",
				"enum": [
					"none",
					"markerFile",
					"fileLock",
					"rename",
					"changed",
					"idempotent",
					"idempotent-changed",
					"idempotent-rename"
				],
				"$comment": "group:lock",
				"default": "none"
			},
			"readLockCheckInterval": {
				"title": "Read Lock Check Interval",
				"description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1000
			},
			"readLockDeleteOrphanLockFiles": {
				"title": "Read Lock Delete Orphan Lock Files",
				"description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockIdempotentReleaseAsync": {
				"title": "Read Lock Idempotent Release Async",
				"description": "Whether the delayed release task should be synchronous or asynchronous. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "boolean",
				"$comment": "group:lock"
			},
			"readLockIdempotentReleaseAsyncPoolSize": {
				"title": "Read Lock Idempotent Release Async Pool Size",
				"description": "The number of threads in the scheduled thread pool when using asynchronous release tasks. Using a default of 1 core threads should be sufficient in almost all use-cases, only set this to a higher value if either updating the idempotent repository is slow, or there are a lot of files to process. This option is not in-use if you use a shared thread pool by configuring the readLockIdempotentReleaseExecutorService option. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "integer",
				"$comment": "group:lock"
			},
			"readLockIdempotentReleaseDelay": {
				"title": "Read Lock Idempotent Release Delay",
				"description": "Whether to delay the release task for a period of millis. This can be used to delay the release tasks to expand the window when a file is regarded as read-locked, in an active/active cluster scenario with a shared idempotent repository, to ensure other nodes cannot potentially scan and acquire the same file, due to race-conditions. By expanding the time-window of the release tasks helps prevents these situations. Note delaying is only needed if you have configured readLockRemoveOnCommit to true.",
				"type": "integer",
				"$comment": "group:lock"
			},
			"readLockIdempotentReleaseExecutorService": {
				"title": "Read Lock Idempotent Release Executor Service",
				"description": "To use a custom and shared thread pool for asynchronous release tasks. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "string",
				"$comment": "group:lock",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"readLockLoggingLevel": {
				"title": "Read Lock Logging Level",
				"description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"readLockMarkerFile": {
				"title": "Read Lock Marker File",
				"description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockMinAge": {
				"title": "Read Lock Min Age",
				"description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 0
			},
			"readLockMinLength": {
				"title": "Read Lock Min Length",
				"description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1
			},
			"readLockRemoveOnCommit": {
				"title": "Read Lock Remove On Commit",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "boolean",
				"$comment": "group:lock"
			},
			"readLockRemoveOnRollback": {
				"title": "Read Lock Remove On Rollback",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockTimeout": {
				"title": "Read Lock Timeout",
				"description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 10000
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"autoCreateKnownHostsFile": {
				"title": "Auto Create Known Hosts File",
				"description": "If knownHostFile does not exist, then attempt to auto-create the path and file (beware that the file will be created by the current user of the running Java process, which may not have file permission).",
				"type": "boolean",
				"$comment": "group:security"
			},
			"ciphers": {
				"title": "Ciphers",
				"description": "Set a comma separated list of ciphers that will be used in order of preference. Possible cipher names are defined by JCraft JSCH. Some examples include: aes128-ctr,aes128-cbc,3des-ctr,3des-cbc,blowfish-cbc,aes192-cbc,aes256-cbc. If not specified the default list from JSCH will be used.",
				"type": "string",
				"$comment": "group:security"
			},
			"keyExchangeProtocols": {
				"title": "Key Exchange Protocols",
				"description": "Set a comma separated list of key exchange protocols that will be used in order of preference. Possible cipher names are defined by JCraft JSCH. Some examples include: diffie-hellman-group-exchange-sha1,diffie-hellman-group1-sha1,diffie-hellman-group14-sha1, diffie-hellman-group-exchange-sha256,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521. If not specified the default list from JSCH will be used.",
				"type": "string",
				"$comment": "group:security"
			},
			"keyPair": {
				"title": "Key Pair",
				"description": "Sets a key pair of the public and private key so to that the SFTP endpoint can do public/private key verification.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.security.KeyPair|password"
			},
			"knownHosts": {
				"title": "Known Hosts",
				"description": "Sets the known_hosts from the byte array, so that the SFTP endpoint can do host key verification.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"knownHostsFile": {
				"title": "Known Hosts File",
				"description": "Sets the known_hosts file, so that the SFTP endpoint can do host key verification.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"knownHostsUri": {
				"title": "Known Hosts Uri",
				"description": "Sets the known_hosts file (loaded from classpath by default), so that the SFTP endpoint can do host key verification.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "Password to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"preferredAuthentications": {
				"title": "Preferred Authentications",
				"description": "Set the preferred authentications which SFTP endpoint will used. Some example include:password,publickey. If not specified the default list from JSCH will be used.",
				"type": "string",
				"$comment": "group:security"
			},
			"privateKey": {
				"title": "Private Key",
				"description": "Set the private key as byte so that the SFTP endpoint can do private key verification.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privateKeyFile": {
				"title": "Private Key File",
				"description": "Set the private key file so that the SFTP endpoint can do private key verification.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privateKeyPassphrase": {
				"title": "Private Key Passphrase",
				"description": "Set the private key file passphrase so that the SFTP endpoint can do private key verification.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privateKeyUri": {
				"title": "Private Key Uri",
				"description": "Set the private key file (loaded from classpath by default) so that the SFTP endpoint can do private key verification.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"publicKeyAcceptedAlgorithms": {
				"title": "Public Key Accepted Algorithms",
				"description": "Set a comma separated list of public key accepted algorithms. Some examples include: ssh-dss,ssh-rsa,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521. If not specified the default list from JSCH will be used.",
				"type": "string",
				"$comment": "group:security"
			},
			"serverHostKeys": {
				"title": "Server Host Keys",
				"description": "Set a comma separated list of algorithms supported for the server host key. Some examples include: ssh-dss,ssh-rsa,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521. If not specified the default list from JSCH will be used.",
				"type": "string",
				"$comment": "group:security"
			},
			"strictHostKeyChecking": {
				"title": "Strict Host Key Checking",
				"description": "Sets whether to use strict host key checking.",
				"type": "string",
				"enum": [
					"no",
					"yes"
				],
				"$comment": "group:security",
				"default": "no"
			},
			"username": {
				"title": "Username",
				"description": "Username to use for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"useUserKnownHostsFile": {
				"title": "Use User Known Hosts File",
				"description": "If knownHostFile has not been explicit configured then use the host file from System.getProperty(user.home)/.ssh/known_hosts",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"shuffle": {
				"title": "Shuffle",
				"description": "To shuffle the list of files (sort in random order)",
				"type": "boolean",
				"$comment": "group:sort"
			},
			"sortBy": {
				"title": "Sort By",
				"description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
				"type": "string",
				"$comment": "group:sort"
			},
			"sorter": {
				"title": "Sorter",
				"description": "Pluggable sorter as a java.util.Comparator class.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:java.util.Comparator<org.apache.camel.component.file.GenericFile<org.apache.camel.component.file.remote.SftpRemoteFile>>"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"sjms": {
		"properties": {
			"destinationType": {
				"title": "Destination Type",
				"description": "The kind of destination to use",
				"type": "string",
				"enum": [
					"queue",
					"topic"
				],
				"$comment": "group:common",
				"default": "queue"
			},
			"destinationName": {
				"title": "Destination Name",
				"description": "DestinationName is a JMS queue or topic name. By default, the destinationName is interpreted as a queue name.",
				"type": "string",
				"$comment": "group:common"
			},
			"acknowledgementMode": {
				"title": "Acknowledgement Mode",
				"description": "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
				"type": "string",
				"enum": [
					"SESSION_TRANSACTED",
					"CLIENT_ACKNOWLEDGE",
					"AUTO_ACKNOWLEDGE",
					"DUPS_OK_ACKNOWLEDGE"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.sjms.jms.SessionAcknowledgementType",
				"default": "AUTO_ACKNOWLEDGE"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:jakarta.jms.ConnectionFactory"
			},
			"disableReplyTo": {
				"title": "Disable Reply To",
				"description": "Specifies whether Camel ignores the JMSReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the JMSReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "Provides an explicit ReplyTo destination (overrides any incoming value of Message.getJMSReplyTo() in consumer).",
				"type": "string",
				"$comment": "group:common"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"asyncConsumer": {
				"title": "Async Consumer",
				"description": "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously (Camel 3.0 may support async transactions).",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"autoStartup": {
				"title": "Auto Startup",
				"description": "Specifies whether the consumer container should auto-startup.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"clientId": {
				"title": "Client Id",
				"description": "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions. If using Apache ActiveMQ you may prefer to use Virtual Topics instead.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"durableSubscriptionName": {
				"title": "Durable Subscription Name",
				"description": "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"replyToDeliveryPersistent": {
				"title": "Reply To Delivery Persistent",
				"description": "Specifies whether to use persistent delivery by default for replies.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerLoadingOfProperties": {
				"title": "Eager Loading Of Properties",
				"description": "Enables eager loading of JMS properties and payload as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties. See also the option eagerPoisonBody.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerPoisonBody": {
				"title": "Eager Poison Body",
				"description": "If eagerLoadingOfProperties is enabled and the JMS message payload (JMS body or JMS properties) is poison (cannot be read/mapped), then set this text as the message body instead so the message can be processed (the cause of the poison are already stored as exception on the Exchange). This can be turned off by setting eagerPoisonBody=false. See also the option eagerLoadingOfProperties.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "Poison JMS message due to ${exception.message}"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"messageSelector": {
				"title": "Message Selector",
				"description": "Sets the JMS Message selector syntax.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"replyToSameDestinationAllowed": {
				"title": "Reply To Same Destination Allowed",
				"description": "Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"deliveryMode": {
				"title": "Delivery Mode",
				"description": "Specifies the delivery mode to be used. Possible values are those defined by jakarta.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.",
				"type": "integer",
				"enum": [
					"1",
					"2"
				],
				"$comment": "group:producer"
			},
			"deliveryPersistent": {
				"title": "Delivery Persistent",
				"description": "Specifies whether persistent delivery is used by default.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"priority": {
				"title": "Priority",
				"description": "Values greater than 1 specify the message priority when sending (where 1 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
				"type": "integer",
				"enum": [
					"1",
					"2",
					"3",
					"4",
					"5",
					"6",
					"7",
					"8",
					"9"
				],
				"$comment": "group:producer",
				"default": 4
			},
			"replyToConcurrentConsumers": {
				"title": "Reply To Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToOverride": {
				"title": "Reply To Override",
				"description": "Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.",
				"type": "string",
				"$comment": "group:producer"
			},
			"replyToType": {
				"title": "Reply To Type",
				"description": "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Exclusive is used.",
				"type": "string",
				"enum": [
					"Temporary",
					"Exclusive"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.sjms.ReplyToType"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "20000"
			},
			"timeToLive": {
				"title": "Time To Live",
				"description": "When sending messages, specifies the time-to-live of the message (in milliseconds).",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"disableTimeToLive": {
				"title": "Disable Time To Live",
				"description": "Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"explicitQosEnabled": {
				"title": "Explicit Qos Enabled",
				"description": "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"preserveMessageQos": {
				"title": "Preserve Message Qos",
				"description": "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"asyncStartListener": {
				"title": "Async Start Listener",
				"description": "Whether to startup the consumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or fail over. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStopListener": {
				"title": "Async Stop Listener",
				"description": "Whether to stop the consumer message listener asynchronously, when stopping a route.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"destinationCreationStrategy": {
				"title": "Destination Creation Strategy",
				"description": "To use a custom DestinationCreationStrategy.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.sjms.jms.DestinationCreationStrategy"
			},
			"exceptionListener": {
				"title": "Exception Listener",
				"description": "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.jms.ExceptionListener"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"includeAllJMSXProperties": {
				"title": "Include All JMSXProperties",
				"description": "Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"jmsKeyFormatStrategy": {
				"title": "Jms Key Format Strategy",
				"description": "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.sjms.jms.JmsKeyFormatStrategy"
			},
			"mapJmsMessage": {
				"title": "Map Jms Message",
				"description": "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as jakarta.jms.TextMessage to a String etc. See section about how mapping works below for more details.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"messageCreatedStrategy": {
				"title": "Message Created Strategy",
				"description": "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of jakarta.jms.Message objects when Camel is sending a JMS message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.sjms.jms.MessageCreatedStrategy"
			},
			"recoveryInterval": {
				"title": "Recovery Interval",
				"description": "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "5000"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a jakarta.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transacted": {
				"title": "Transacted",
				"description": "Specifies whether to use transacted mode",
				"type": "boolean",
				"$comment": "group:transaction"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"destinationName"
		]
	},
	"sjms2": {
		"properties": {
			"destinationType": {
				"title": "Destination Type",
				"description": "The kind of destination to use",
				"type": "string",
				"enum": [
					"queue",
					"topic"
				],
				"$comment": "group:common",
				"default": "queue"
			},
			"destinationName": {
				"title": "Destination Name",
				"description": "DestinationName is a JMS queue or topic name. By default, the destinationName is interpreted as a queue name.",
				"type": "string",
				"$comment": "group:common"
			},
			"acknowledgementMode": {
				"title": "Acknowledgement Mode",
				"description": "The JMS acknowledgement name, which is one of: SESSION_TRANSACTED, CLIENT_ACKNOWLEDGE, AUTO_ACKNOWLEDGE, DUPS_OK_ACKNOWLEDGE",
				"type": "string",
				"enum": [
					"SESSION_TRANSACTED",
					"CLIENT_ACKNOWLEDGE",
					"AUTO_ACKNOWLEDGE",
					"DUPS_OK_ACKNOWLEDGE"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.sjms.jms.SessionAcknowledgementType",
				"default": "AUTO_ACKNOWLEDGE"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:jakarta.jms.ConnectionFactory"
			},
			"disableReplyTo": {
				"title": "Disable Reply To",
				"description": "Specifies whether Camel ignores the JMSReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the JMSReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "Provides an explicit ReplyTo destination (overrides any incoming value of Message.getJMSReplyTo() in consumer).",
				"type": "string",
				"$comment": "group:common"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"asyncConsumer": {
				"title": "Async Consumer",
				"description": "Whether the JmsConsumer processes the Exchange asynchronously. If enabled then the JmsConsumer may pickup the next message from the JMS queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the JmsConsumer will pickup the next message from the JMS queue. Note if transacted has been enabled, then asyncConsumer=true does not run asynchronously, as transaction must be executed synchronously (Camel 3.0 may support async transactions).",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"autoStartup": {
				"title": "Auto Startup",
				"description": "Specifies whether the consumer container should auto-startup.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"clientId": {
				"title": "Client Id",
				"description": "Sets the JMS client ID to use. Note that this value, if specified, must be unique and can only be used by a single JMS connection instance. It is typically only required for durable topic subscriptions. If using Apache ActiveMQ you may prefer to use Virtual Topics instead.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when consuming from JMS (not for request/reply over JMS). See also the maxMessagesPerTask option to control dynamic scaling up/down of threads. When doing request/reply over JMS then the option replyToConcurrentConsumers is used to control number of concurrent consumers on the reply message listener.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"durable": {
				"title": "Durable",
				"description": "Sets the topic to be durable",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"durableSubscriptionName": {
				"title": "Durable Subscription Name",
				"description": "The durable subscriber name for specifying durable topic subscriptions. The clientId option must be configured as well.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"replyToDeliveryPersistent": {
				"title": "Reply To Delivery Persistent",
				"description": "Specifies whether to use persistent delivery by default for replies.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"shared": {
				"title": "Shared",
				"description": "Sets the topic to be shared",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"subscriptionId": {
				"title": "Subscription Id",
				"description": "Sets the topic subscription id, required for durable or shared topics.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerLoadingOfProperties": {
				"title": "Eager Loading Of Properties",
				"description": "Enables eager loading of JMS properties and payload as soon as a message is loaded which generally is inefficient as the JMS properties may not be required but sometimes can catch early any issues with the underlying JMS provider and the use of JMS properties. See also the option eagerPoisonBody.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"eagerPoisonBody": {
				"title": "Eager Poison Body",
				"description": "If eagerLoadingOfProperties is enabled and the JMS message payload (JMS body or JMS properties) is poison (cannot be read/mapped), then set this text as the message body instead so the message can be processed (the cause of the poison are already stored as exception on the Exchange). This can be turned off by setting eagerPoisonBody=false. See also the option eagerLoadingOfProperties.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "Poison JMS message due to ${exception.message}"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"messageSelector": {
				"title": "Message Selector",
				"description": "Sets the JMS Message selector syntax.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"replyToSameDestinationAllowed": {
				"title": "Reply To Same Destination Allowed",
				"description": "Whether a JMS consumer is allowed to send a reply message to the same destination that the consumer is using to consume from. This prevents an endless loop by consuming and sending back the same message to itself.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"deliveryMode": {
				"title": "Delivery Mode",
				"description": "Specifies the delivery mode to be used. Possible values are those defined by jakarta.jms.DeliveryMode. NON_PERSISTENT = 1 and PERSISTENT = 2.",
				"type": "integer",
				"enum": [
					"1",
					"2"
				],
				"$comment": "group:producer"
			},
			"deliveryPersistent": {
				"title": "Delivery Persistent",
				"description": "Specifies whether persistent delivery is used by default.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"priority": {
				"title": "Priority",
				"description": "Values greater than 1 specify the message priority when sending (where 1 is the lowest priority and 9 is the highest). The explicitQosEnabled option must also be enabled in order for this option to have any effect.",
				"type": "integer",
				"enum": [
					"1",
					"2",
					"3",
					"4",
					"5",
					"6",
					"7",
					"8",
					"9"
				],
				"$comment": "group:producer",
				"default": 4
			},
			"replyToConcurrentConsumers": {
				"title": "Reply To Concurrent Consumers",
				"description": "Specifies the default number of concurrent consumers when doing request/reply over JMS. See also the maxMessagesPerTask option to control dynamic scaling up/down of threads.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 1
			},
			"replyToOverride": {
				"title": "Reply To Override",
				"description": "Provides an explicit ReplyTo destination in the JMS message, which overrides the setting of replyTo. It is useful if you want to forward the message to a remote Queue and receive the reply message from the ReplyTo destination.",
				"type": "string",
				"$comment": "group:producer"
			},
			"replyToType": {
				"title": "Reply To Type",
				"description": "Allows for explicitly specifying which kind of strategy to use for replyTo queues when doing request/reply over JMS. Possible values are: Temporary or Exclusive. By default Camel will use temporary queues. However if replyTo has been configured, then Exclusive is used.",
				"type": "string",
				"enum": [
					"Temporary",
					"Exclusive"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.sjms.ReplyToType"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "The timeout for waiting for a reply when using the InOut Exchange Pattern (in milliseconds). The default is 20 seconds. You can include the header CamelJmsRequestTimeout to override this endpoint configured timeout value, and thus have per message individual timeout values. See also the requestTimeoutCheckerInterval option.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "20000"
			},
			"timeToLive": {
				"title": "Time To Live",
				"description": "When sending messages, specifies the time-to-live of the message (in milliseconds).",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Whether to allow sending messages with no body. If this option is false and the message body is null, then an JMSException is thrown.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"disableTimeToLive": {
				"title": "Disable Time To Live",
				"description": "Use this option to force disabling time to live. For example when you do request/reply over JMS, then Camel will by default use the requestTimeout value as time to live on the message being sent. The problem is that the sender and receiver systems have to have their clocks synchronized, so they are in sync. This is not always so easy to archive. So you can use disableTimeToLive=true to not set a time to live value on the sent message. Then the message will not expire on the receiver system. See below in section About time to live for more details.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"explicitQosEnabled": {
				"title": "Explicit Qos Enabled",
				"description": "Set if the deliveryMode, priority or timeToLive qualities of service should be used when sending messages. This option is based on Spring's JmsTemplate. The deliveryMode, priority and timeToLive options are applied to the current endpoint. This contrasts with the preserveMessageQos option, which operates at message granularity, reading QoS properties exclusively from the Camel In message headers.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"preserveMessageQos": {
				"title": "Preserve Message Qos",
				"description": "Set to true, if you want to send message using the QoS settings specified on the message, instead of the QoS settings on the JMS endpoint. The following three headers are considered JMSPriority, JMSDeliveryMode, and JMSExpiration. You can provide all or only some of them. If not provided, Camel will fall back to use the values from the endpoint instead. So, when using this option, the headers override the values from the endpoint. The explicitQosEnabled option, by contrast, will only use options set on the endpoint, and not values from the message header.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"asyncStartListener": {
				"title": "Async Start Listener",
				"description": "Whether to startup the consumer message listener asynchronously, when starting a route. For example if a JmsConsumer cannot get a connection to a remote JMS broker, then it may block while retrying and/or fail over. This will cause Camel to block while starting routes. By setting this option to true, you will let routes startup, while the JmsConsumer connects to the JMS broker using a dedicated thread in asynchronous mode. If this option is used, then beware that if the connection could not be established, then an exception is logged at WARN level, and the consumer will not be able to receive messages; You can then restart the route to retry.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"asyncStopListener": {
				"title": "Async Stop Listener",
				"description": "Whether to stop the consumer message listener asynchronously, when stopping a route.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"destinationCreationStrategy": {
				"title": "Destination Creation Strategy",
				"description": "To use a custom DestinationCreationStrategy.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.sjms.jms.DestinationCreationStrategy"
			},
			"exceptionListener": {
				"title": "Exception Listener",
				"description": "Specifies the JMS Exception Listener that is to be notified of any underlying JMS exceptions.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.jms.ExceptionListener"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"includeAllJMSXProperties": {
				"title": "Include All JMSXProperties",
				"description": "Whether to include all JMSXxxx properties when mapping from JMS to Camel Message. Setting this to true will include properties such as JMSXAppID, and JMSXUserID etc. Note: If you are using a custom headerFilterStrategy then this option does not apply.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"jmsKeyFormatStrategy": {
				"title": "Jms Key Format Strategy",
				"description": "Pluggable strategy for encoding and decoding JMS keys so they can be compliant with the JMS specification. Camel provides two implementations out of the box: default and passthrough. The default strategy will safely marshal dots and hyphens (. and -). The passthrough strategy leaves the key as is. Can be used for JMS brokers which do not care whether JMS header keys contain illegal characters. You can provide your own implementation of the org.apache.camel.component.jms.JmsKeyFormatStrategy and refer to it using the # notation.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.sjms.jms.JmsKeyFormatStrategy"
			},
			"mapJmsMessage": {
				"title": "Map Jms Message",
				"description": "Specifies whether Camel should auto map the received JMS message to a suited payload type, such as jakarta.jms.TextMessage to a String etc. See section about how mapping works below for more details.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"messageCreatedStrategy": {
				"title": "Message Created Strategy",
				"description": "To use the given MessageCreatedStrategy which are invoked when Camel creates new instances of jakarta.jms.Message objects when Camel is sending a JMS message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.sjms.jms.MessageCreatedStrategy"
			},
			"recoveryInterval": {
				"title": "Recovery Interval",
				"description": "Specifies the interval between recovery attempts, i.e. when a connection is being refreshed, in milliseconds. The default is 5000 ms, that is, 5 seconds.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "duration",
				"default": "5000"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and you are using Request Reply messaging (InOut) and an Exchange failed on the consumer side, then the caused Exception will be send back in response as a jakarta.jms.ObjectMessage. If the client is Camel, the returned Exception is rethrown. This allows you to use Camel JMS as a bridge in your routing - for example, using persistent queues to enable robust routing. Notice that if you also have transferExchange enabled, this option takes precedence. The caught exception is required to be serializable. The original Exception on the consumer side can be wrapped in an outer exception such as org.apache.camel.RuntimeCamelException when returned to the producer. Use this with caution as the data is using Java Object serialization and requires the received to be able to deserialize the data at Class level, which forces a strong coupling between the producers and consumer!",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transacted": {
				"title": "Transacted",
				"description": "Specifies whether to use transacted mode",
				"type": "boolean",
				"$comment": "group:transaction"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"destinationName"
		]
	},
	"slack": {
		"properties": {
			"channel": {
				"title": "Channel",
				"description": "The channel name (syntax #name) or slack user (syntax userName) to send a message directly to an user.",
				"type": "string",
				"$comment": "group:common"
			},
			"token": {
				"title": "Token",
				"description": "The token to access Slack. This app needs to have channels:history, groups:history, im:history, mpim:history, channels:read, groups:read, im:read and mpim:read permissions. The User OAuth Token is the kind of token needed.",
				"type": "string",
				"$comment": "group:common",
				"format": "password"
			},
			"conversationType": {
				"title": "Conversation Type",
				"description": "Type of conversation",
				"type": "string",
				"enum": [
					"PUBLIC_CHANNEL",
					"PRIVATE_CHANNEL",
					"MPIM",
					"IM"
				],
				"$comment": "group:consumer",
				"format": "bean:com.slack.api.model.ConversationType",
				"default": "PUBLIC_CHANNEL"
			},
			"maxResults": {
				"title": "Max Results",
				"description": "The Max Result for the poll",
				"type": "string",
				"$comment": "group:consumer",
				"default": "10"
			},
			"naturalOrder": {
				"title": "Natural Order",
				"description": "Create exchanges in natural order (oldest to newest) or not",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"serverUrl": {
				"title": "Server Url",
				"description": "The Server URL of the Slack instance",
				"type": "string",
				"$comment": "group:consumer",
				"default": "https://slack.com"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"iconEmoji": {
				"title": "Icon Emoji",
				"description": "Use a Slack emoji as an avatar",
				"type": "string",
				"$comment": "group:producer",
				"deprecated": true
			},
			"iconUrl": {
				"title": "Icon Url",
				"description": "The avatar that the component will use when sending message to a channel or user.",
				"type": "string",
				"$comment": "group:producer",
				"deprecated": true
			},
			"username": {
				"title": "Username",
				"description": "This is the username that the bot will have when sending messages to a channel or user.",
				"type": "string",
				"$comment": "group:producer",
				"format": "password",
				"deprecated": true
			},
			"webhookUrl": {
				"title": "Webhook Url",
				"description": "The incoming webhook URL",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "10000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"channel"
		]
	},
	"smb": {
		"properties": {
			"hostname": {
				"title": "Hostname",
				"description": "The share hostname or IP address",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The share port number",
				"type": "integer",
				"$comment": "group:common",
				"default": 445
			},
			"shareName": {
				"title": "Share Name",
				"description": "The name of the share directory",
				"type": "string",
				"$comment": "group:common"
			},
			"charset": {
				"title": "Charset",
				"description": "This option is used to specify the encoding of the file. You can use this on the consumer, to specify the encodings of the files, which allow Camel to know the charset it should load the file content in case the file content is being accessed. Likewise when writing a file, you can use this option to specify which charset to write the file as well. Do mind that when writing the file Camel may have to read the message content into memory to be able to convert the data into the configured charset, so do not use this if you have big messages.",
				"type": "string",
				"$comment": "group:common"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether or not to disconnect from remote SMB share right after use. Disconnect will only disconnect the current connection to the SMB share. If you have a consumer which you want to stop, then you need to stop the consumer/route instead.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"doneFileName": {
				"title": "Done File Name",
				"description": "Producer: If provided, then Camel will write a 2nd done file when the original file has been written. The done file will be empty. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders. The done file will always be written in the same folder as the original file. Consumer: If provided, Camel will only consume files if a done file exists. This option configures what file name to use. Either you can specify a fixed name. Or you can use dynamic placeholders.The done file is always expected in the same folder as the original file. Only ${file.name} and ${file.name.next} is supported as dynamic placeholders.",
				"type": "string",
				"$comment": "group:common"
			},
			"fileName": {
				"title": "File Name",
				"description": "Use Expression such as File Language to dynamically set the filename. For consumers, it's used as a filename filter. For producers, it's used to evaluate the filename to write. If an expression is set, it take precedence over the CamelFileName header. (Note: The header itself can also be an Expression). The expression options support both String and Expression types. If the expression is a String type, it is always evaluated using the File Language. If the expression is an Expression type, the specified Expression type is used - this allows you, for instance, to use OGNL expressions. For the consumer, you can use it to filter filenames, so you can for instance consume today's file using the File Language syntax: mydata-${date:now:yyyyMMdd}.txt. The producers support the CamelOverruleFileName header which takes precedence over any existing CamelFileName header; the CamelOverruleFileName is a header that is used only once, and makes it easier as this avoids to temporary store CamelFileName and have to restore it afterwards.",
				"type": "string",
				"$comment": "group:common"
			},
			"path": {
				"title": "Path",
				"description": "The base directory within the share",
				"type": "string",
				"$comment": "group:common"
			},
			"delete": {
				"title": "Delete",
				"description": "If true, the file will be deleted after it is processed successfully.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveFailed": {
				"title": "Move Failed",
				"description": "Sets the move failure expression based on Simple language. For example, to move files into a .error subdirectory use: .error. Note: When moving the files to the fail location Camel will handle the error and will not pick up the file again.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"noop": {
				"title": "Noop",
				"description": "If true, the file is not moved or deleted in any way. This option is good for readonly data, or for ETL type requirements. If noop=true, Camel will set idempotent=true as well, to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"preMove": {
				"title": "Pre Move",
				"description": "Expression (such as File Language) used to dynamically set the filename when moving it before processing. For example to move in-progress files into the order directory set this value to order.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"preSort": {
				"title": "Pre Sort",
				"description": "When pre-sort is enabled then the consumer will sort the file and directory names during polling, that was retrieved from the file system. You may want to do this in case you need to operate on the files in a sorted order. The pre-sort is executed before the consumer starts to filter, and accept files to process by Camel. This option is default=false meaning disabled.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"recursive": {
				"title": "Recursive",
				"description": "If a directory, will look for files in all the sub-directories as well.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"searchPattern": {
				"title": "Search Pattern",
				"description": "The search pattern used to list the files (server side on SMB). This parameter can contain the name of a file (or multiple files, if wildcards are used) within this directory. When it is null all files are included. Two wild card characters are supported in the search pattern. The (question mark) character matches a single character. If a search pattern contains one or more characters, then exactly that number of characters is matched by the wildcards. For example, the criterion x matches abx but not abcx or ax, because the two file names do not have enough characters preceding the literal. When a file name criterion has characters trailing a literal, then the match is made with specified number of characters or less. For example, the criterion x matches xab, xa, and x, but not xabc. If only characters are present in the file name selection criterion, then the match is made as if the criterion contained characters trailing a literal. The (asterisk) character matches an entire file name. A null or empty specification criterion also selects all file names. For example, .abc or .abc match any file with an extension of abc. ., , or empty string match all files in a directory.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"streamDownload": {
				"title": "Stream Download",
				"description": "Sets the download method to use when not using a local working directory. If set to true, the remote files are streamed to the route as they are read. When set to false, the remote files are loaded into memory before being sent into the route.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"download": {
				"title": "Download",
				"description": "Whether the SMB consumer should download the file. If this option is set to false, then the message body will be null, but the consumer will still trigger a Camel Exchange that has details about the file such as file name, file size, etc. It's just that the file will not be downloaded.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"inProgressRepository": {
				"title": "In Progress Repository",
				"description": "A pluggable in-progress repository org.apache.camel.spi.IdempotentRepository. The in-progress repository is used to account the current in progress files being consumed. By default a memory based repository is used.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"localWorkDirectory": {
				"title": "Local Work Directory",
				"description": "When consuming, a local work directory can be used to store the remote file content directly in local files, to avoid loading the content into memory. This is beneficial, if you consume a very big remote file and thus can conserve memory.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"onCompletionExceptionHandler": {
				"title": "On Completion Exception Handler",
				"description": "To use a custom org.apache.camel.spi.ExceptionHandler to handle any thrown exceptions that happens during the file on completion process where the consumer does either a commit or rollback. The default implementation will log any exception at WARN level and ignore.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"processStrategy": {
				"title": "Process Strategy",
				"description": "A pluggable org.apache.camel.component.file.GenericFileProcessStrategy allowing you to implement your own readLock option or similar. Can also be used when special conditions must be met before a file can be consumed, such as a special ready file exists. If this option is set then the readLock option does not apply.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.file.GenericFileProcessStrategy<com.hierynomus.msfscc.fileinformation.FileIdBothDirectoryInformation>"
			},
			"startingDirectoryMustExist": {
				"title": "Starting Directory Must Exist",
				"description": "Whether the starting directory must exist. Mind that the autoCreate option is default enabled, which means the starting directory is normally auto created if it doesn't exist. You can disable autoCreate and enable this to ensure the starting directory must exist. Will throw an exception if the directory doesn't exist.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"throwExceptionOnConnectFailed": {
				"title": "Throw Exception On Connect Failed",
				"description": "Should an exception be thrown if connection failed (exhausted). By default exception is not thrown and a WARN is logged. You can use this to enable exception being thrown and handle the thrown exception from the PollingConsumerPollStrategy rollback method.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"checksumFileAlgorithm": {
				"title": "Checksum File Algorithm",
				"description": "If provided, then Camel will write a checksum file when the original file has been written. The checksum file will contain the checksum created with the provided algorithm for the original file. The checksum file will always be written in the same folder as the original file.",
				"type": "string",
				"enum": [
					"MD2",
					"MD5",
					"SHA_1",
					"SHA_224",
					"SHA_256",
					"SHA_384",
					"SHA_512",
					"SHA_512_224",
					"SHA_512_256",
					"SHA3_224",
					"SHA3_256",
					"SHA3_384",
					"SHA3_512"
				],
				"$comment": "group:producer"
			},
			"fileExist": {
				"title": "File Exist",
				"description": "What to do if a file already exists with the same name. Override, which is the default, replaces the existing file. - Append - adds content to the existing file. - Fail - throws a GenericFileOperationException, indicating that there is already an existing file. - Ignore - silently ignores the problem and does not override the existing file, but assumes everything is okay. - Move - option requires to use the moveExisting option to be configured as well. The option eagerDeleteTargetFile can be used to control what to do if an moving the file, and there exists already an existing file, otherwise causing the move operation to fail. The Move option will move any existing files, before writing the target file. - TryRename is only applicable if tempFileName option is in use. This allows to try renaming the file from the temporary name to the actual name, without doing any exists check. This check may be faster on some file systems and especially FTP servers.",
				"type": "string",
				"enum": [
					"Override",
					"Append",
					"Fail",
					"Ignore",
					"Move",
					"TryRename"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.file.GenericFileExist",
				"default": "Override"
			},
			"flatten": {
				"title": "Flatten",
				"description": "Flatten is used to flatten the file name path to strip any leading paths, so it's just the file name. This allows you to consume recursively into sub-directories, but when you eg write the files to another directory they will be written in a single directory. Setting this to true on the producer enforces that any file name in CamelFileName header will be stripped for any leading paths.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"jailStartingDirectory": {
				"title": "Jail Starting Directory",
				"description": "Used for jailing (restricting) writing files to the starting directory (and sub) only. This is enabled by default to not allow Camel to write files to outside directories (to be more secured out of the box). You can turn this off to allow writing files to directories outside the starting directory, such as parent or root folders.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"moveExisting": {
				"title": "Move Existing",
				"description": "Expression (such as File Language) used to compute file name to use when fileExist=Move is configured. To move files into a backup subdirectory just enter backup. This option only supports the following File Language tokens: file:name, file:name.ext, file:name.noext, file:onlyname, file:onlyname.noext, file:ext, and file:parent. Notice the file:parent is not supported by the FTP component, as the FTP component can only move any existing files to a relative directory based on current dir as base.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempFileName": {
				"title": "Temp File Name",
				"description": "The same as tempPrefix option but offering a more fine grained control on the naming of the temporary filename as it uses the File Language. The location for tempFilename is relative to the final file location in the option 'fileName', not the target directory in the base uri. For example if option fileName includes a directory prefix: dir/finalFilename then tempFileName is relative to that subdirectory dir.",
				"type": "string",
				"$comment": "group:producer"
			},
			"tempPrefix": {
				"title": "Temp Prefix",
				"description": "This option is used to write the file using a temporary name and then, after the write is complete, rename it to the real name. Can be used to identify files being written and also avoid consumers (not using exclusive read locks) reading in progress files. Is often used by FTP when uploading big files.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Used to specify if a null body is allowed during file writing. If set to true then an empty file will be created, when set to false, and attempting to send a null body to the file component, a GenericFileWriteException of 'Cannot write null body to file.' will be thrown. If the fileExist option is set to 'Override', then the file will be truncated, and if set to append the file will remain unchanged.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"disconnectOnBatchComplete": {
				"title": "Disconnect On Batch Complete",
				"description": "Whether or not to disconnect from remote SMB share right after a Batch upload is complete. disconnectOnBatchComplete will only disconnect the current connection to the SMB share.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"eagerDeleteTargetFile": {
				"title": "Eager Delete Target File",
				"description": "Whether or not to eagerly delete any existing target file. This option only applies when you use fileExists=Override and the tempFileName option as well. You can use this to disable (set it to false) deleting the target file before the temp file is written. For example you may write big files and want the target file to exists during the temp file is being written. This ensure the target file is only deleted until the very last moment, just before the temp file is being renamed to the target filename. This option is also used to control whether to delete any existing files when fileExist=Move is enabled, and an existing file exists. If this option copyAndDeleteOnRenameFails false, then an exception will be thrown if an existing file existed, if its true, then the existing file is deleted before the move operation.",
				"type": "boolean",
				"$comment": "group:producer (advanced)",
				"default": true
			},
			"keepLastModified": {
				"title": "Keep Last Modified",
				"description": "Will keep the last modified timestamp from the source file (if any). Will use the FileConstants.FILE_LAST_MODIFIED header to located the timestamp. This header can contain either a java.util.Date or long with the timestamp. If the timestamp exists and the option is enabled it will set this timestamp on the written file. Note: This option only applies to the file producer. You cannot use this option with any of the ftp producers.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"moveExistingFileStrategy": {
				"title": "Move Existing File Strategy",
				"description": "Strategy (Custom Strategy) used to move file with special naming token to use when fileExist=Move is configured. By default, there is an implementation used if no custom strategy is provided",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.file.strategy.FileMoveExistingStrategy"
			},
			"autoCreate": {
				"title": "Auto Create",
				"description": "Automatically create missing directories in the file's pathname. For the file consumer, that means creating the starting directory. For the file producer, it means the directory the files should be written to.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"bufferSize": {
				"title": "Buffer Size",
				"description": "Buffer size in bytes used for writing files (or in case of FTP for downloading and uploading files).",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 131072
			},
			"smbConfig": {
				"title": "Smb Config",
				"description": "An optional SMB client configuration, can be used to configure client specific configurations, like timeouts",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:com.hierynomus.smbj.SmbConfig"
			},
			"antExclude": {
				"title": "Ant Exclude",
				"description": "Ant style filter exclusion. If both antInclude and antExclude are used, antExclude takes precedence over antInclude. Multiple exclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"antFilterCaseSensitive": {
				"title": "Ant Filter Case Sensitive",
				"description": "Sets case sensitive flag on ant filter.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"antInclude": {
				"title": "Ant Include",
				"description": "Ant style filter inclusion. Multiple inclusions may be specified in comma-delimited format.",
				"type": "string",
				"$comment": "group:filter"
			},
			"eagerMaxMessagesPerPoll": {
				"title": "Eager Max Messages Per Poll",
				"description": "Allows for controlling whether the limit from maxMessagesPerPoll is eager or not. If eager then the limit is during the scanning of files. Where as false would scan all files, and then perform sorting. Setting this option to false allows for sorting all files first, and then limit the poll. Mind that this requires a higher memory usage as all file details are in memory to perform the sorting.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"exclude": {
				"title": "Exclude",
				"description": "Is used to exclude files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"excludeExt": {
				"title": "Exclude Ext",
				"description": "Is used to exclude files matching file extension name (case insensitive). For example to exclude bak files, then use excludeExt=bak. Multiple extensions can be separated by comma, for example to exclude bak and dat files, use excludeExt=bak,dat. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"filter": {
				"title": "Filter",
				"description": "Pluggable filter as a org.apache.camel.component.file.GenericFileFilter class. Will skip files if filter returns false in its accept() method.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.component.file.GenericFileFilter<com.hierynomus.msfscc.fileinformation.FileIdBothDirectoryInformation>"
			},
			"filterDirectory": {
				"title": "Filter Directory",
				"description": "Filters the directory based on Simple language. For example to filter on current date, you can use a simple date pattern such as ${date:now:yyyMMdd}",
				"type": "string",
				"$comment": "group:filter"
			},
			"filterFile": {
				"title": "Filter File",
				"description": "Filters the file based on Simple language. For example to filter on file size, you can use ${file:size} 5000",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotent": {
				"title": "Idempotent",
				"description": "Option to use the Idempotent Consumer EIP pattern to let Camel skip already processed files. Will by default use a memory based LRUCache that holds 1000 entries. If noop=true then idempotent will be enabled as well to avoid consuming the same files over and over again.",
				"type": "boolean",
				"$comment": "group:filter"
			},
			"idempotentEager": {
				"title": "Idempotent Eager",
				"description": "Sets whether to eagerly add the filename to the idempotent repository or wait until the exchange is complete.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"idempotentKey": {
				"title": "Idempotent Key",
				"description": "To use a custom idempotent key. By default the absolute path of the file is used. You can use the File Language, for example to use the file name and file size, you can do: idempotentKey=${file:name}-${file:size}",
				"type": "string",
				"$comment": "group:filter"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which by default use MemoryIdempotentRepository if none is specified and idempotent is true.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"include": {
				"title": "Include",
				"description": "Is used to include files, if filename matches the regex pattern (matching is case in-sensitive). Notice if you use symbols such as plus sign and others you would need to configure this using the RAW() syntax if configuring this as an endpoint uri. See more details at configuring endpoint uris",
				"type": "string",
				"$comment": "group:filter"
			},
			"includeExt": {
				"title": "Include Ext",
				"description": "Is used to include files matching file extension name (case insensitive). For example to include txt files, then use includeExt=txt. Multiple extensions can be separated by comma, for example to include txt and xml files, use includeExt=txt,xml. Note that the file extension includes all parts, for example having a file named mydata.tar.gz will have extension as tar.gz. For more flexibility then use the include/exclude options.",
				"type": "string",
				"$comment": "group:filter"
			},
			"maxDepth": {
				"title": "Max Depth",
				"description": "The maximum depth to traverse when recursively processing a directory.",
				"type": "integer",
				"$comment": "group:filter",
				"default": 2147483647
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "To define a maximum messages to gather per poll. By default no maximum is set. Can be used to set a limit of e.g. 1000 to avoid when starting up the server that there are thousands of files. Set a value of 0 or negative to disabled it. Notice: If this option is in use then the File and FTP components will limit before any sorting. For example if you have 100000 files and use maxMessagesPerPoll=500, then only the first 500 files will be picked up, and then sorted. You can use the eagerMaxMessagesPerPoll option and set this to false to allow to scan all files first and then sort afterwards.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"minDepth": {
				"title": "Min Depth",
				"description": "The minimum depth to start processing when recursively processing a directory. Using minDepth=1 means the base directory. Using minDepth=2 means the first sub directory.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"move": {
				"title": "Move",
				"description": "Expression (such as Simple Language) used to dynamically set the filename when moving it after processing. To move files into a .done subdirectory just enter .done.",
				"type": "string",
				"$comment": "group:filter"
			},
			"exclusiveReadLockStrategy": {
				"title": "Exclusive Read Lock Strategy",
				"description": "Pluggable read-lock as a org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy implementation.",
				"type": "string",
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.component.file.GenericFileExclusiveReadLockStrategy<com.hierynomus.msfscc.fileinformation.FileIdBothDirectoryInformation>"
			},
			"readLock": {
				"title": "Read Lock",
				"description": "Used by consumer, to only poll the files if it has exclusive read-lock on the file (i.e. the file is not in-progress or being written). Camel will wait until the file lock is granted. This option provides the build in strategies: - none - No read lock is in use - markerFile - Camel creates a marker file (fileName.camelLock) and then holds a lock on it. This option is not available for the FTP component - changed - Changed is using file length/modification timestamp to detect whether the file is currently being copied or not. Will at least use 1 sec to determine this, so this option cannot consume files as fast as the others, but can be more reliable as the JDK IO API cannot always determine whether a file is currently being used by another process. The option readLockCheckInterval can be used to set the check frequency. - fileLock - is for using java.nio.channels.FileLock. This option is not avail for Windows OS and the FTP component. This approach should be avoided when accessing a remote file system via a mount/share unless that file system supports distributed file locks. - rename - rename is for using a try to rename the file as a test if we can get exclusive read-lock. - idempotent - (only for file component) idempotent is for using a idempotentRepository as the read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-changed - (only for file component) idempotent-changed is for using a idempotentRepository and changed as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that. - idempotent-rename - (only for file component) idempotent-rename is for using a idempotentRepository and rename as the combined read-lock. This allows to use read locks that supports clustering if the idempotent repository implementation supports that.Notice: The various read locks is not all suited to work in clustered mode, where concurrent consumers on different nodes is competing for the same files on a shared file system. The markerFile using a close to atomic operation to create the empty marker file, but its not guaranteed to work in a cluster. The fileLock may work better but then the file system need to support distributed file locks, and so on. Using the idempotent read lock can support clustering if the idempotent repository supports clustering, such as Hazelcast Component or Infinispan.",
				"type": "string",
				"enum": [
					"none",
					"markerFile",
					"fileLock",
					"rename",
					"changed",
					"idempotent",
					"idempotent-changed",
					"idempotent-rename"
				],
				"$comment": "group:lock",
				"default": "none"
			},
			"readLockCheckInterval": {
				"title": "Read Lock Check Interval",
				"description": "Interval in millis for the read-lock, if supported by the read lock. This interval is used for sleeping between attempts to acquire the read lock. For example when using the changed read lock, you can set a higher interval period to cater for slow writes. The default of 1 sec. may be too fast if the producer is very slow writing the file. Notice: For FTP the default readLockCheckInterval is 5000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1000
			},
			"readLockDeleteOrphanLockFiles": {
				"title": "Read Lock Delete Orphan Lock Files",
				"description": "Whether or not read lock with marker files should upon startup delete any orphan read lock files, which may have been left on the file system, if Camel was not properly shutdown (such as a JVM crash). If turning this option to false then any orphaned lock file will cause Camel to not attempt to pickup that file, this could also be due another node is concurrently reading files from the same shared directory.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockLoggingLevel": {
				"title": "Read Lock Logging Level",
				"description": "Logging level used when a read lock could not be acquired. By default a DEBUG is logged. You can change this level, for example to OFF to not have any logging. This option is only applicable for readLock of types: changed, fileLock, idempotent, idempotent-changed, idempotent-rename, rename.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:lock",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "DEBUG"
			},
			"readLockMarkerFile": {
				"title": "Read Lock Marker File",
				"description": "Whether to use marker file with the changed, rename, or exclusive read lock types. By default a marker file is used as well to guard against other processes picking up the same files. This behavior can be turned off by setting this option to false. For example if you do not want to write marker files to the file systems by the Camel application.",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockMinAge": {
				"title": "Read Lock Min Age",
				"description": "This option is applied only for readLock=changed. It allows to specify a minimum age the file must be before attempting to acquire the read lock. For example use readLockMinAge=300s to require the file is at last 5 minutes old. This can speedup the changed read lock as it will only attempt to acquire files which are at least that given age.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 0
			},
			"readLockMinLength": {
				"title": "Read Lock Min Length",
				"description": "This option is applied only for readLock=changed. It allows you to configure a minimum file length. By default Camel expects the file to contain data, and thus the default value is 1. You can set this option to zero, to allow consuming zero-length files.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 1
			},
			"readLockRemoveOnCommit": {
				"title": "Read Lock Remove On Commit",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file is succeeded and a commit happens. By default the file is not removed which ensures that any race-condition do not occur so another active node may attempt to grab the file. Instead the idempotent repository may support eviction strategies that you can configure to evict the file name entry after X minutes - this ensures no problems with race conditions. See more details at the readLockIdempotentReleaseDelay option.",
				"type": "boolean",
				"$comment": "group:lock"
			},
			"readLockRemoveOnRollback": {
				"title": "Read Lock Remove On Rollback",
				"description": "This option is applied only for readLock=idempotent. It allows to specify whether to remove the file name entry from the idempotent repository when processing the file failed and a rollback happens. If this option is false, then the file name entry is confirmed (as if the file did a commit).",
				"type": "boolean",
				"$comment": "group:lock",
				"default": true
			},
			"readLockTimeout": {
				"title": "Read Lock Timeout",
				"description": "Optional timeout in millis for the read-lock, if supported by the read-lock. If the read-lock could not be granted and the timeout triggered, then Camel will skip the file. At next poll Camel, will try the file again, and this time maybe the read-lock could be granted. Use a value of 0 or lower to indicate forever. Currently fileLock, changed and rename support the timeout. Notice: For FTP the default readLockTimeout value is 20000 instead of 10000. The readLockTimeout value must be higher than readLockCheckInterval, but a rule of thumb is to have a timeout that is at least 2 or more times higher than the readLockCheckInterval. This is needed to ensure that ample time is allowed for the read lock process to try to grab the lock before the timeout was hit.",
				"type": "integer",
				"$comment": "group:lock",
				"default": 10000
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"domain": {
				"title": "Domain",
				"description": "The user domain",
				"type": "string",
				"$comment": "group:security"
			},
			"password": {
				"title": "Password",
				"description": "The password to access the share",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "The username required to access the share",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"shuffle": {
				"title": "Shuffle",
				"description": "To shuffle the list of files (sort in random order)",
				"type": "boolean",
				"$comment": "group:sort"
			},
			"sortBy": {
				"title": "Sort By",
				"description": "Built-in sort by using the File Language. Supports nested sorts, so you can have a sort by file name and as a 2nd group sort by modified date.",
				"type": "string",
				"$comment": "group:sort"
			},
			"sorter": {
				"title": "Sorter",
				"description": "Pluggable sorter as a java.util.Comparator class.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:java.util.Comparator<org.apache.camel.component.file.GenericFile<com.hierynomus.msfscc.fileinformation.FileIdBothDirectoryInformation>>"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"hostname",
			"shareName"
		]
	},
	"smooks": {
		"properties": {
			"smooksConfig": {
				"title": "Smooks Config",
				"description": "Path to the Smooks configuration file",
				"type": "string",
				"$comment": "group:producer"
			},
			"reportPath": {
				"title": "Report Path",
				"description": "File path to place the generated HTML execution report. The report is a useful tool in the developers arsenal for diagnosing issues or comprehending a transformation. Do not set in production since this is a major performance drain",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"allowExecutionContextFromHeader": {
				"title": "Allow Execution Context From Header",
				"description": "Allow execution context to be set from the CamelSmooksExecutionContext header",
				"type": "boolean",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"smooksConfig"
		]
	},
	"smpp": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname for the SMSC server to use.",
				"type": "string",
				"$comment": "group:common",
				"default": "localhost"
			},
			"port": {
				"title": "Port",
				"description": "Port number for the SMSC server to use.",
				"type": "integer",
				"$comment": "group:common",
				"default": "2775"
			},
			"initialReconnectDelay": {
				"title": "Initial Reconnect Delay",
				"description": "Defines the initial delay in milliseconds after the consumer/producer tries to reconnect to the SMSC, after the connection was lost.",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"maxReconnect": {
				"title": "Max Reconnect",
				"description": "Defines the maximum number of attempts to reconnect to the SMSC, if SMSC returns a negative bind response",
				"type": "integer",
				"$comment": "group:common",
				"default": 2147483647
			},
			"reconnectDelay": {
				"title": "Reconnect Delay",
				"description": "Defines the interval in milliseconds between the reconnect attempts, if the connection to the SMSC was lost and the previous was not succeed.",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"splittingPolicy": {
				"title": "Splitting Policy",
				"description": "You can specify a policy for handling long messages: ALLOW - the default, long messages are split to 140 bytes per message TRUNCATE - long messages are split and only the first fragment will be sent to the SMSC. Some carriers drop subsequent fragments so this reduces load on the SMPP connection sending parts of a message that will never be delivered. REJECT - if a message would need to be split, it is rejected with an SMPP NegativeResponseException and the reason code signifying the message is too long.",
				"type": "string",
				"enum": [
					"ALLOW",
					"REJECT",
					"TRUNCATE"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.smpp.SmppSplittingPolicy",
				"default": "ALLOW"
			},
			"systemType": {
				"title": "System Type",
				"description": "This parameter is used to categorize the type of ESME (External Short Message Entity) that is binding to the SMSC (max. 13 characters).",
				"type": "string",
				"$comment": "group:common"
			},
			"addressRange": {
				"title": "Address Range",
				"description": "You can specify the address range for the SmppConsumer as defined in section 5.2.7 of the SMPP 3.4 specification. The SmppConsumer will receive messages only from SMSC's which target an address (MSISDN or IP address) within this range.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"destAddr": {
				"title": "Dest Addr",
				"description": "Defines the destination SME address. For mobile terminated messages, this is the directory number of the recipient MS. Only for SubmitSm, SubmitMulti, CancelSm and DataSm.",
				"type": "string",
				"$comment": "group:producer",
				"default": "1717"
			},
			"destAddrNpi": {
				"title": "Dest Addr Npi",
				"description": "Defines the type of number (TON) to be used in the SME destination address parameters. Only for SubmitSm, SubmitMulti, CancelSm and DataSm. The following NPI values are defined: 0: Unknown 1: ISDN (E163/E164) 2: Data (X.121) 3: Telex (F.69) 6: Land Mobile (E.212) 8: National 9: Private 10: ERMES 13: Internet (IP) 18: WAP Client Id (to be defined by WAP Forum)",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"6",
					"8",
					"9",
					"10",
					"13",
					"18"
				],
				"$comment": "group:producer"
			},
			"destAddrTon": {
				"title": "Dest Addr Ton",
				"description": "Defines the type of number (TON) to be used in the SME destination address parameters. Only for SubmitSm, SubmitMulti, CancelSm and DataSm. The following TON values are defined: 0: Unknown 1: International 2: National 3: Network Specific 4: Subscriber Number 5: Alphanumeric 6: Abbreviated",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"4",
					"5",
					"6"
				],
				"$comment": "group:producer"
			},
			"lazySessionCreation": {
				"title": "Lazy Session Creation",
				"description": "Sessions can be lazily created to avoid exceptions, if the SMSC is not available when the Camel producer is started. Camel will check the in message headers 'CamelSmppSystemId' and 'CamelSmppPassword' of the first exchange. If they are present, Camel will use these data to connect to the SMSC.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"messageReceiverRouteId": {
				"title": "Message Receiver Route Id",
				"description": "Set this on producer in order to benefit from transceiver (TRX) binding type. So once set, you don't need to define an 'SMTPP consumer' endpoint anymore. You would set this to a 'Direct consumer' endpoint instead. DISCALIMER: This feature is only tested with 'Direct consumer' endpoint. The behavior with any other consumer type is unknown and not tested.",
				"type": "string",
				"$comment": "group:producer"
			},
			"numberingPlanIndicator": {
				"title": "Numbering Plan Indicator",
				"description": "Defines the numeric plan indicator (NPI) to be used in the SME. The following NPI values are defined: 0: Unknown 1: ISDN (E163/E164) 2: Data (X.121) 3: Telex (F.69) 6: Land Mobile (E.212) 8: National 9: Private 10: ERMES 13: Internet (IP) 18: WAP Client Id (to be defined by WAP Forum)",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"6",
					"8",
					"9",
					"10",
					"13",
					"18"
				],
				"$comment": "group:producer"
			},
			"priorityFlag": {
				"title": "Priority Flag",
				"description": "Allows the originating SME to assign a priority level to the short message. Only for SubmitSm and SubmitMulti. Four Priority Levels are supported: 0: Level 0 (lowest) priority 1: Level 1 priority 2: Level 2 priority 3: Level 3 (highest) priority",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3"
				],
				"$comment": "group:producer"
			},
			"protocolId": {
				"title": "Protocol Id",
				"description": "The protocol id",
				"type": "integer",
				"$comment": "group:producer"
			},
			"registeredDelivery": {
				"title": "Registered Delivery",
				"description": "Is used to request an SMSC delivery receipt and/or SME originated acknowledgements. The following values are defined: 0: No SMSC delivery receipt requested. 1: SMSC delivery receipt requested where final delivery outcome is success or failure. 2: SMSC delivery receipt requested where the final delivery outcome is delivery failure.",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2"
				],
				"$comment": "group:producer"
			},
			"replaceIfPresentFlag": {
				"title": "Replace If Present Flag",
				"description": "Used to request the SMSC to replace a previously submitted message, that is still pending delivery. The SMSC will replace an existing message provided that the source address, destination address and service type match the same fields in the new message. The following replace if present flag values are defined: 0: Don't replace 1: Replace",
				"type": "integer",
				"enum": [
					"0",
					"1"
				],
				"$comment": "group:producer"
			},
			"serviceType": {
				"title": "Service Type",
				"description": "The service type parameter can be used to indicate the SMS Application service associated with the message. The following generic service_types are defined: CMT: Cellular Messaging CPT: Cellular Paging VMN: Voice Mail Notification VMA: Voice Mail Alerting WAP: Wireless Application Protocol USSD: Unstructured Supplementary Services Data",
				"type": "string",
				"enum": [
					"CMT",
					"CPT",
					"VMN",
					"VMA",
					"WAP",
					"USSD"
				],
				"$comment": "group:producer"
			},
			"sourceAddr": {
				"title": "Source Addr",
				"description": "Defines the address of SME (Short Message Entity) which originated this message.",
				"type": "string",
				"$comment": "group:producer",
				"default": "1616"
			},
			"sourceAddrNpi": {
				"title": "Source Addr Npi",
				"description": "Defines the numeric plan indicator (NPI) to be used in the SME originator address parameters. The following NPI values are defined: 0: Unknown 1: ISDN (E163/E164) 2: Data (X.121) 3: Telex (F.69) 6: Land Mobile (E.212) 8: National 9: Private 10: ERMES 13: Internet (IP) 18: WAP Client Id (to be defined by WAP Forum)",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"6",
					"8",
					"9",
					"10",
					"13",
					"18"
				],
				"$comment": "group:producer"
			},
			"sourceAddrTon": {
				"title": "Source Addr Ton",
				"description": "Defines the type of number (TON) to be used in the SME originator address parameters. The following TON values are defined: 0: Unknown 1: International 2: National 3: Network Specific 4: Subscriber Number 5: Alphanumeric 6: Abbreviated",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"4",
					"5",
					"6"
				],
				"$comment": "group:producer"
			},
			"typeOfNumber": {
				"title": "Type Of Number",
				"description": "Defines the type of number (TON) to be used in the SME. The following TON values are defined: 0: Unknown 1: International 2: National 3: Network Specific 4: Subscriber Number 5: Alphanumeric 6: Abbreviated",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"4",
					"5",
					"6"
				],
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"enquireLinkTimer": {
				"title": "Enquire Link Timer",
				"description": "Defines the interval in milliseconds between the confidence checks. The confidence check is used to test the communication path between an ESME and an SMSC.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "60000"
			},
			"interfaceVersion": {
				"title": "Interface Version",
				"description": "Defines the interface version to be used in the binding request with the SMSC. The following values are allowed, as defined in the SMPP protocol (and the underlying implementation using the jSMPP library, respectively): legacy (0x00), 3.3 (0x33), 3.4 (0x34), and 5.0 (0x50). The default (fallback) value is version 3.4.",
				"type": "string",
				"enum": [
					"legacy",
					"3.3",
					"3.4",
					"5.0"
				],
				"$comment": "group:advanced",
				"default": "3.4"
			},
			"pduProcessorDegree": {
				"title": "Pdu Processor Degree",
				"description": "Sets the number of threads which can read PDU and process them in parallel.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "3"
			},
			"pduProcessorQueueCapacity": {
				"title": "Pdu Processor Queue Capacity",
				"description": "Sets the capacity of the working queue for PDU processing.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "100"
			},
			"sessionStateListener": {
				"title": "Session State Listener",
				"description": "You can refer to a org.jsmpp.session.SessionStateListener in the Registry to receive callbacks when the session state changed.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.jsmpp.session.SessionStateListener"
			},
			"singleDLR": {
				"title": "Single DLR",
				"description": "When true, the SMSC delivery receipt would be requested only for the last segment of a multi-segment (long) message. For short messages, with only 1 segment the behaviour is unchanged.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transactionTimer": {
				"title": "Transaction Timer",
				"description": "Defines the maximum period of inactivity allowed after a transaction, after which an SMPP entity may assume that the session is no longer active. This timer may be active on either communicating SMPP entity (i.e. SMSC or ESME).",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "10000"
			},
			"alphabet": {
				"title": "Alphabet",
				"description": "Defines encoding of data according the SMPP 3.4 specification, section 5.2.19. 0: SMSC Default Alphabet 4: 8 bit Alphabet 8: UCS2 Alphabet",
				"type": "integer",
				"enum": [
					"0",
					"4",
					"8"
				],
				"$comment": "group:codec"
			},
			"dataCoding": {
				"title": "Data Coding",
				"description": "Defines the data coding according the SMPP 3.4 specification, section 5.2.19. Example data encodings are: 0: SMSC Default Alphabet 3: Latin 1 (ISO-8859-1) 4: Octet unspecified (8-bit binary) 8: UCS2 (ISO/IEC-10646) 13: Extended Kanji JIS(X 0212-1990)",
				"type": "integer",
				"$comment": "group:codec"
			},
			"encoding": {
				"title": "Encoding",
				"description": "Defines the encoding scheme of the short message user data. Only for SubmitSm, ReplaceSm and SubmitMulti.",
				"type": "string",
				"$comment": "group:codec",
				"default": "ISO-8859-1"
			},
			"httpProxyHost": {
				"title": "Http Proxy Host",
				"description": "If you need to tunnel SMPP through a HTTP proxy, set this attribute to the hostname or ip address of your HTTP proxy.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPassword": {
				"title": "Http Proxy Password",
				"description": "If your HTTP proxy requires basic authentication, set this attribute to the password required for your HTTP proxy.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPort": {
				"title": "Http Proxy Port",
				"description": "If you need to tunnel SMPP through a HTTP proxy, set this attribute to the port of your HTTP proxy.",
				"type": "integer",
				"$comment": "group:proxy",
				"default": "3128"
			},
			"httpProxyUsername": {
				"title": "Http Proxy Username",
				"description": "If your HTTP proxy requires basic authentication, set this attribute to the username required for your HTTP proxy.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyHeaders": {
				"title": "Proxy Headers",
				"description": "These headers will be passed to the proxy server while establishing the connection.",
				"type": "object",
				"$comment": "group:proxy"
			},
			"password": {
				"title": "Password",
				"description": "The password for connecting to SMSC server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"systemId": {
				"title": "System Id",
				"description": "The system id (username) for connecting to SMSC server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password",
				"default": "smppclient"
			},
			"usingSSL": {
				"title": "Using SSL",
				"description": "Whether using SSL with the smpps protocol",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"smpps": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname for the SMSC server to use.",
				"type": "string",
				"$comment": "group:common",
				"default": "localhost"
			},
			"port": {
				"title": "Port",
				"description": "Port number for the SMSC server to use.",
				"type": "integer",
				"$comment": "group:common",
				"default": "2775"
			},
			"initialReconnectDelay": {
				"title": "Initial Reconnect Delay",
				"description": "Defines the initial delay in milliseconds after the consumer/producer tries to reconnect to the SMSC, after the connection was lost.",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"maxReconnect": {
				"title": "Max Reconnect",
				"description": "Defines the maximum number of attempts to reconnect to the SMSC, if SMSC returns a negative bind response",
				"type": "integer",
				"$comment": "group:common",
				"default": 2147483647
			},
			"reconnectDelay": {
				"title": "Reconnect Delay",
				"description": "Defines the interval in milliseconds between the reconnect attempts, if the connection to the SMSC was lost and the previous was not succeed.",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"splittingPolicy": {
				"title": "Splitting Policy",
				"description": "You can specify a policy for handling long messages: ALLOW - the default, long messages are split to 140 bytes per message TRUNCATE - long messages are split and only the first fragment will be sent to the SMSC. Some carriers drop subsequent fragments so this reduces load on the SMPP connection sending parts of a message that will never be delivered. REJECT - if a message would need to be split, it is rejected with an SMPP NegativeResponseException and the reason code signifying the message is too long.",
				"type": "string",
				"enum": [
					"ALLOW",
					"REJECT",
					"TRUNCATE"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.smpp.SmppSplittingPolicy",
				"default": "ALLOW"
			},
			"systemType": {
				"title": "System Type",
				"description": "This parameter is used to categorize the type of ESME (External Short Message Entity) that is binding to the SMSC (max. 13 characters).",
				"type": "string",
				"$comment": "group:common"
			},
			"addressRange": {
				"title": "Address Range",
				"description": "You can specify the address range for the SmppConsumer as defined in section 5.2.7 of the SMPP 3.4 specification. The SmppConsumer will receive messages only from SMSC's which target an address (MSISDN or IP address) within this range.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"destAddr": {
				"title": "Dest Addr",
				"description": "Defines the destination SME address. For mobile terminated messages, this is the directory number of the recipient MS. Only for SubmitSm, SubmitMulti, CancelSm and DataSm.",
				"type": "string",
				"$comment": "group:producer",
				"default": "1717"
			},
			"destAddrNpi": {
				"title": "Dest Addr Npi",
				"description": "Defines the type of number (TON) to be used in the SME destination address parameters. Only for SubmitSm, SubmitMulti, CancelSm and DataSm. The following NPI values are defined: 0: Unknown 1: ISDN (E163/E164) 2: Data (X.121) 3: Telex (F.69) 6: Land Mobile (E.212) 8: National 9: Private 10: ERMES 13: Internet (IP) 18: WAP Client Id (to be defined by WAP Forum)",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"6",
					"8",
					"9",
					"10",
					"13",
					"18"
				],
				"$comment": "group:producer"
			},
			"destAddrTon": {
				"title": "Dest Addr Ton",
				"description": "Defines the type of number (TON) to be used in the SME destination address parameters. Only for SubmitSm, SubmitMulti, CancelSm and DataSm. The following TON values are defined: 0: Unknown 1: International 2: National 3: Network Specific 4: Subscriber Number 5: Alphanumeric 6: Abbreviated",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"4",
					"5",
					"6"
				],
				"$comment": "group:producer"
			},
			"lazySessionCreation": {
				"title": "Lazy Session Creation",
				"description": "Sessions can be lazily created to avoid exceptions, if the SMSC is not available when the Camel producer is started. Camel will check the in message headers 'CamelSmppSystemId' and 'CamelSmppPassword' of the first exchange. If they are present, Camel will use these data to connect to the SMSC.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"messageReceiverRouteId": {
				"title": "Message Receiver Route Id",
				"description": "Set this on producer in order to benefit from transceiver (TRX) binding type. So once set, you don't need to define an 'SMTPP consumer' endpoint anymore. You would set this to a 'Direct consumer' endpoint instead. DISCALIMER: This feature is only tested with 'Direct consumer' endpoint. The behavior with any other consumer type is unknown and not tested.",
				"type": "string",
				"$comment": "group:producer"
			},
			"numberingPlanIndicator": {
				"title": "Numbering Plan Indicator",
				"description": "Defines the numeric plan indicator (NPI) to be used in the SME. The following NPI values are defined: 0: Unknown 1: ISDN (E163/E164) 2: Data (X.121) 3: Telex (F.69) 6: Land Mobile (E.212) 8: National 9: Private 10: ERMES 13: Internet (IP) 18: WAP Client Id (to be defined by WAP Forum)",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"6",
					"8",
					"9",
					"10",
					"13",
					"18"
				],
				"$comment": "group:producer"
			},
			"priorityFlag": {
				"title": "Priority Flag",
				"description": "Allows the originating SME to assign a priority level to the short message. Only for SubmitSm and SubmitMulti. Four Priority Levels are supported: 0: Level 0 (lowest) priority 1: Level 1 priority 2: Level 2 priority 3: Level 3 (highest) priority",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3"
				],
				"$comment": "group:producer"
			},
			"protocolId": {
				"title": "Protocol Id",
				"description": "The protocol id",
				"type": "integer",
				"$comment": "group:producer"
			},
			"registeredDelivery": {
				"title": "Registered Delivery",
				"description": "Is used to request an SMSC delivery receipt and/or SME originated acknowledgements. The following values are defined: 0: No SMSC delivery receipt requested. 1: SMSC delivery receipt requested where final delivery outcome is success or failure. 2: SMSC delivery receipt requested where the final delivery outcome is delivery failure.",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2"
				],
				"$comment": "group:producer"
			},
			"replaceIfPresentFlag": {
				"title": "Replace If Present Flag",
				"description": "Used to request the SMSC to replace a previously submitted message, that is still pending delivery. The SMSC will replace an existing message provided that the source address, destination address and service type match the same fields in the new message. The following replace if present flag values are defined: 0: Don't replace 1: Replace",
				"type": "integer",
				"enum": [
					"0",
					"1"
				],
				"$comment": "group:producer"
			},
			"serviceType": {
				"title": "Service Type",
				"description": "The service type parameter can be used to indicate the SMS Application service associated with the message. The following generic service_types are defined: CMT: Cellular Messaging CPT: Cellular Paging VMN: Voice Mail Notification VMA: Voice Mail Alerting WAP: Wireless Application Protocol USSD: Unstructured Supplementary Services Data",
				"type": "string",
				"enum": [
					"CMT",
					"CPT",
					"VMN",
					"VMA",
					"WAP",
					"USSD"
				],
				"$comment": "group:producer"
			},
			"sourceAddr": {
				"title": "Source Addr",
				"description": "Defines the address of SME (Short Message Entity) which originated this message.",
				"type": "string",
				"$comment": "group:producer",
				"default": "1616"
			},
			"sourceAddrNpi": {
				"title": "Source Addr Npi",
				"description": "Defines the numeric plan indicator (NPI) to be used in the SME originator address parameters. The following NPI values are defined: 0: Unknown 1: ISDN (E163/E164) 2: Data (X.121) 3: Telex (F.69) 6: Land Mobile (E.212) 8: National 9: Private 10: ERMES 13: Internet (IP) 18: WAP Client Id (to be defined by WAP Forum)",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"6",
					"8",
					"9",
					"10",
					"13",
					"18"
				],
				"$comment": "group:producer"
			},
			"sourceAddrTon": {
				"title": "Source Addr Ton",
				"description": "Defines the type of number (TON) to be used in the SME originator address parameters. The following TON values are defined: 0: Unknown 1: International 2: National 3: Network Specific 4: Subscriber Number 5: Alphanumeric 6: Abbreviated",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"4",
					"5",
					"6"
				],
				"$comment": "group:producer"
			},
			"typeOfNumber": {
				"title": "Type Of Number",
				"description": "Defines the type of number (TON) to be used in the SME. The following TON values are defined: 0: Unknown 1: International 2: National 3: Network Specific 4: Subscriber Number 5: Alphanumeric 6: Abbreviated",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"2",
					"3",
					"4",
					"5",
					"6"
				],
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"enquireLinkTimer": {
				"title": "Enquire Link Timer",
				"description": "Defines the interval in milliseconds between the confidence checks. The confidence check is used to test the communication path between an ESME and an SMSC.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "60000"
			},
			"interfaceVersion": {
				"title": "Interface Version",
				"description": "Defines the interface version to be used in the binding request with the SMSC. The following values are allowed, as defined in the SMPP protocol (and the underlying implementation using the jSMPP library, respectively): legacy (0x00), 3.3 (0x33), 3.4 (0x34), and 5.0 (0x50). The default (fallback) value is version 3.4.",
				"type": "string",
				"enum": [
					"legacy",
					"3.3",
					"3.4",
					"5.0"
				],
				"$comment": "group:advanced",
				"default": "3.4"
			},
			"pduProcessorDegree": {
				"title": "Pdu Processor Degree",
				"description": "Sets the number of threads which can read PDU and process them in parallel.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "3"
			},
			"pduProcessorQueueCapacity": {
				"title": "Pdu Processor Queue Capacity",
				"description": "Sets the capacity of the working queue for PDU processing.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "100"
			},
			"sessionStateListener": {
				"title": "Session State Listener",
				"description": "You can refer to a org.jsmpp.session.SessionStateListener in the Registry to receive callbacks when the session state changed.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.jsmpp.session.SessionStateListener"
			},
			"singleDLR": {
				"title": "Single DLR",
				"description": "When true, the SMSC delivery receipt would be requested only for the last segment of a multi-segment (long) message. For short messages, with only 1 segment the behaviour is unchanged.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"transactionTimer": {
				"title": "Transaction Timer",
				"description": "Defines the maximum period of inactivity allowed after a transaction, after which an SMPP entity may assume that the session is no longer active. This timer may be active on either communicating SMPP entity (i.e. SMSC or ESME).",
				"type": "integer",
				"$comment": "group:advanced",
				"default": "10000"
			},
			"alphabet": {
				"title": "Alphabet",
				"description": "Defines encoding of data according the SMPP 3.4 specification, section 5.2.19. 0: SMSC Default Alphabet 4: 8 bit Alphabet 8: UCS2 Alphabet",
				"type": "integer",
				"enum": [
					"0",
					"4",
					"8"
				],
				"$comment": "group:codec"
			},
			"dataCoding": {
				"title": "Data Coding",
				"description": "Defines the data coding according the SMPP 3.4 specification, section 5.2.19. Example data encodings are: 0: SMSC Default Alphabet 3: Latin 1 (ISO-8859-1) 4: Octet unspecified (8-bit binary) 8: UCS2 (ISO/IEC-10646) 13: Extended Kanji JIS(X 0212-1990)",
				"type": "integer",
				"$comment": "group:codec"
			},
			"encoding": {
				"title": "Encoding",
				"description": "Defines the encoding scheme of the short message user data. Only for SubmitSm, ReplaceSm and SubmitMulti.",
				"type": "string",
				"$comment": "group:codec",
				"default": "ISO-8859-1"
			},
			"httpProxyHost": {
				"title": "Http Proxy Host",
				"description": "If you need to tunnel SMPP through a HTTP proxy, set this attribute to the hostname or ip address of your HTTP proxy.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPassword": {
				"title": "Http Proxy Password",
				"description": "If your HTTP proxy requires basic authentication, set this attribute to the password required for your HTTP proxy.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPort": {
				"title": "Http Proxy Port",
				"description": "If you need to tunnel SMPP through a HTTP proxy, set this attribute to the port of your HTTP proxy.",
				"type": "integer",
				"$comment": "group:proxy",
				"default": "3128"
			},
			"httpProxyUsername": {
				"title": "Http Proxy Username",
				"description": "If your HTTP proxy requires basic authentication, set this attribute to the username required for your HTTP proxy.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyHeaders": {
				"title": "Proxy Headers",
				"description": "These headers will be passed to the proxy server while establishing the connection.",
				"type": "object",
				"$comment": "group:proxy"
			},
			"password": {
				"title": "Password",
				"description": "The password for connecting to SMSC server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"systemId": {
				"title": "System Id",
				"description": "The system id (username) for connecting to SMSC server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password",
				"default": "smppclient"
			},
			"usingSSL": {
				"title": "Using SSL",
				"description": "Whether using SSL with the smpps protocol",
				"type": "boolean",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"smtp": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The mail server host name",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The port number of the mail server",
				"type": "integer",
				"$comment": "group:common"
			},
			"closeFolder": {
				"title": "Close Folder",
				"description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keeps the folder open between polls.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"copyTo": {
				"title": "Copy To",
				"description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"decodeFilename": {
				"title": "Decode Filename",
				"description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"delete": {
				"title": "Delete",
				"description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. You can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether the consumer should disconnect after polling. If enabled, this forces Camel to connect on each poll.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"handleFailedMessage": {
				"title": "Handle Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows handling the caused exception by the consumer's error handler. By enabling the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"mimeDecodeHeaders": {
				"title": "Mime Decode Headers",
				"description": "This option enables transparent MIME decoding and unfolding for mail headers.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveTo": {
				"title": "Move To",
				"description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"peek": {
				"title": "Peek",
				"description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek, the mail will not be eagerly marked as SEEN on the mail server, which allows us to roll back the mail message if there is a processing error in Camel.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"skipFailedMessage": {
				"title": "Skip Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows skipping the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"unseen": {
				"title": "Unseen",
				"description": "Whether to limit by unseen mails only.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"failOnDuplicateFileAttachment": {
				"title": "Fail On Duplicate File Attachment",
				"description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true, then an exception is thrown failing to process the mail message.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"fetchSize": {
				"title": "Fetch Size",
				"description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. The default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": -1
			},
			"folderName": {
				"title": "Folder Name",
				"description": "The folder to poll.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "INBOX"
			},
			"generateMissingAttachmentNames": {
				"title": "Generate Missing Attachment Names",
				"description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"handleDuplicateAttachmentNames": {
				"title": "Handle Duplicate Attachment Names",
				"description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with an uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with an underscore and uuid (filename_uuid.fileextension).",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"mailUidGenerator": {
				"title": "Mail Uid Generator",
				"description": "A pluggable MailUidGenerator that allows to use custom logic to generate UUID of the mail message.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailUidGenerator"
			},
			"mapMailMessage": {
				"title": "Map Mail Message",
				"description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false, then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"postProcessAction": {
				"title": "Post Process Action",
				"description": "Refers to an MailBoxPostProcessAction for doing post processing tasks on the mailbox once the normal processing ended.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailBoxPostProcessAction"
			},
			"bcc": {
				"title": "Bcc",
				"description": "Sets the BCC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"cc": {
				"title": "Cc",
				"description": "Sets the CC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"from": {
				"title": "From",
				"description": "The from email address",
				"type": "string",
				"$comment": "group:producer",
				"default": "camel@localhost"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"subject": {
				"title": "Subject",
				"description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
				"type": "string",
				"$comment": "group:producer"
			},
			"to": {
				"title": "To",
				"description": "Sets the destination email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"javaMailSender": {
				"title": "Java Mail Sender",
				"description": "To use a custom org.apache.camel.component.mail.JavaMailSender for sending emails.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.mail.JavaMailSender"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"additionalJavaMailProperties": {
				"title": "Additional Java Mail Properties",
				"description": "Sets additional java mail properties, that will append/override any default properties that are set based on all the other options. This is useful if you need to add some special options but want to keep the others as is.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"alternativeBodyHeader": {
				"title": "Alternative Body Header",
				"description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "CamelMailAlternativeBody"
			},
			"attachmentsContentTransferEncodingResolver": {
				"title": "Attachments Content Transfer Encoding Resolver",
				"description": "To use a custom AttachmentsContentTransferEncodingResolver to resolve what content-type-encoding to use for attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.AttachmentsContentTransferEncodingResolver"
			},
			"authenticator": {
				"title": "Authenticator",
				"description": "The authenticator for login. If set then the password and username are ignored. It can be used for tokens which can expire and therefore must be read dynamically.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailAuthenticator"
			},
			"binding": {
				"title": "Binding",
				"description": "Sets the binding used to convert from a Camel message to and from a Mail message",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailBinding"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "The connection timeout in milliseconds.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 30000
			},
			"contentType": {
				"title": "Content Type",
				"description": "The mail message content type. Use text/html for HTML mails.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "text/plain"
			},
			"contentTypeResolver": {
				"title": "Content Type Resolver",
				"description": "Resolver to determine Content-Type for file attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.ContentTypeResolver"
			},
			"debugMode": {
				"title": "Debug Mode",
				"description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"ignoreUnsupportedCharset": {
				"title": "Ignore Unsupported Charset",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"ignoreUriScheme": {
				"title": "Ignore Uri Scheme",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"javaMailProperties": {
				"title": "Java Mail Properties",
				"description": "Sets the java mail options. Will clear any default properties and only use the properties provided for this method.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"session": {
				"title": "Session",
				"description": "Specifies the mail session that camel should use for all mail interactions. Useful in scenarios where mail sessions are created and managed by some other resource, such as a JavaEE container. When using a custom mail session, then the hostname and port from the mail session will be used (if configured on the session).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.mail.Session"
			},
			"useInlineAttachments": {
				"title": "Use Inline Attachments",
				"description": "Whether to use disposition inline or attachment.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which allows to cluster consuming from the same mailbox, and let the repository coordinate whether a mail message is valid for the consumer to process. By default no repository is in use.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"idempotentRepositoryRemoveOnCommit": {
				"title": "Idempotent Repository Remove On Commit",
				"description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"searchTerm": {
				"title": "Search Term",
				"description": "Refers to a jakarta.mail.search.SearchTerm which allows to filter mails based on search criteria such as subject, body, from, sent after a certain date etc.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:jakarta.mail.search.SearchTerm"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "60000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "The password for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"username": {
				"title": "Username",
				"description": "The username for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sortTerm": {
				"title": "Sort Term",
				"description": "Sorting order for messages. Only natively supported for IMAP. Emulated to some degree when using POP3 or when IMAP server does not have the SORT capability.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:org.eclipse.angus.mail.imap.SortTerm[]"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"smtps": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The mail server host name",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The port number of the mail server",
				"type": "integer",
				"$comment": "group:common"
			},
			"closeFolder": {
				"title": "Close Folder",
				"description": "Whether the consumer should close the folder after polling. Setting this option to false and having disconnect=false as well, then the consumer keeps the folder open between polls.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"copyTo": {
				"title": "Copy To",
				"description": "After processing a mail message, it can be copied to a mail folder with the given name. You can override this configuration value with a header with the key copyTo, allowing you to copy messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"decodeFilename": {
				"title": "Decode Filename",
				"description": "If set to true, the MimeUtility.decodeText method will be used to decode the filename. This is similar to setting JVM system property mail.mime.encodefilename.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"delete": {
				"title": "Delete",
				"description": "Deletes the messages after they have been processed. This is done by setting the DELETED flag on the mail message. If false, the SEEN flag is set instead. You can override this configuration option by setting a header with the key delete to determine if the mail should be deleted or not.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"disconnect": {
				"title": "Disconnect",
				"description": "Whether the consumer should disconnect after polling. If enabled, this forces Camel to connect on each poll.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"handleFailedMessage": {
				"title": "Handle Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows handling the caused exception by the consumer's error handler. By enabling the bridge error handler on the consumer, then the Camel routing error handler can handle the exception instead. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Specifies the maximum number of messages to gather per poll. By default, no maximum is set. Can be used to set a limit of e.g. 1000 to avoid downloading thousands of files when the server starts up. Set a value of 0 or negative to disable this option.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"mimeDecodeHeaders": {
				"title": "Mime Decode Headers",
				"description": "This option enables transparent MIME decoding and unfolding for mail headers.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"moveTo": {
				"title": "Move To",
				"description": "After processing a mail message, it can be moved to a mail folder with the given name. You can override this configuration value with a header with the key moveTo, allowing you to move messages to folder names configured at runtime.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"peek": {
				"title": "Peek",
				"description": "Will mark the jakarta.mail.Message as peeked before processing the mail message. This applies to IMAPMessage messages types only. By using peek, the mail will not be eagerly marked as SEEN on the mail server, which allows us to roll back the mail message if there is a processing error in Camel.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"skipFailedMessage": {
				"title": "Skip Failed Message",
				"description": "If the mail consumer cannot retrieve a given mail message, then this option allows skipping the message and move on to retrieve the next mail message. The default behavior would be the consumer throws an exception and no mails from the batch would be able to be routed by Camel.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"unseen": {
				"title": "Unseen",
				"description": "Whether to limit by unseen mails only.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"failOnDuplicateFileAttachment": {
				"title": "Fail On Duplicate File Attachment",
				"description": "Whether to fail processing the mail if the mail message contains attachments with duplicate file names. If set to false, then the duplicate attachment is skipped and a WARN is logged. If set to true, then an exception is thrown failing to process the mail message.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"fetchSize": {
				"title": "Fetch Size",
				"description": "Sets the maximum number of messages to consume during a poll. This can be used to avoid overloading a mail server, if a mailbox folder contains a lot of messages. The default value of -1 means no fetch size and all messages will be consumed. Setting the value to 0 is a special corner case, where Camel will not consume any messages at all.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": -1
			},
			"folderName": {
				"title": "Folder Name",
				"description": "The folder to poll.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"default": "INBOX"
			},
			"generateMissingAttachmentNames": {
				"title": "Generate Missing Attachment Names",
				"description": "Set this to 'uuid' to set a UUID for the filename of the attachment if no filename was set",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"handleDuplicateAttachmentNames": {
				"title": "Handle Duplicate Attachment Names",
				"description": "Set the strategy to handle duplicate filenames of attachments never: attachments that have a filename which is already present in the attachments will be ignored unless failOnDuplicateFileAttachment is set to true. uuidPrefix: this will prefix the duplicate attachment filenames each with an uuid and underscore (uuid_filename.fileextension). uuidSuffix: this will suffix the duplicate attachment filenames each with an underscore and uuid (filename_uuid.fileextension).",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"mailUidGenerator": {
				"title": "Mail Uid Generator",
				"description": "A pluggable MailUidGenerator that allows to use custom logic to generate UUID of the mail message.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailUidGenerator"
			},
			"mapMailMessage": {
				"title": "Map Mail Message",
				"description": "Specifies whether Camel should map the received mail message to Camel body/headers/attachments. If set to true, the body of the mail message is mapped to the body of the Camel IN message, the mail headers are mapped to IN headers, and the attachments to Camel IN attachment message. If this option is set to false, then the IN message contains a raw jakarta.mail.Message. You can retrieve this raw message by calling exchange.getIn().getBody(jakarta.mail.Message.class).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"postProcessAction": {
				"title": "Post Process Action",
				"description": "Refers to an MailBoxPostProcessAction for doing post processing tasks on the mailbox once the normal processing ended.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.mail.MailBoxPostProcessAction"
			},
			"bcc": {
				"title": "Bcc",
				"description": "Sets the BCC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"cc": {
				"title": "Cc",
				"description": "Sets the CC email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"from": {
				"title": "From",
				"description": "The from email address",
				"type": "string",
				"$comment": "group:producer",
				"default": "camel@localhost"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "The Reply-To recipients (the receivers of the response mail). Separate multiple email addresses with a comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"subject": {
				"title": "Subject",
				"description": "The Subject of the message being sent. Note: Setting the subject in the header takes precedence over this option.",
				"type": "string",
				"$comment": "group:producer"
			},
			"to": {
				"title": "To",
				"description": "Sets the destination email address. Separate multiple email addresses with comma.",
				"type": "string",
				"$comment": "group:producer"
			},
			"javaMailSender": {
				"title": "Java Mail Sender",
				"description": "To use a custom org.apache.camel.component.mail.JavaMailSender for sending emails.",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.component.mail.JavaMailSender"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"additionalJavaMailProperties": {
				"title": "Additional Java Mail Properties",
				"description": "Sets additional java mail properties, that will append/override any default properties that are set based on all the other options. This is useful if you need to add some special options but want to keep the others as is.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"alternativeBodyHeader": {
				"title": "Alternative Body Header",
				"description": "Specifies the key to an IN message header that contains an alternative email body. For example, if you send emails in text/html format and want to provide an alternative mail body for non-HTML email clients, set the alternative mail body with this key as a header.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "CamelMailAlternativeBody"
			},
			"attachmentsContentTransferEncodingResolver": {
				"title": "Attachments Content Transfer Encoding Resolver",
				"description": "To use a custom AttachmentsContentTransferEncodingResolver to resolve what content-type-encoding to use for attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.AttachmentsContentTransferEncodingResolver"
			},
			"authenticator": {
				"title": "Authenticator",
				"description": "The authenticator for login. If set then the password and username are ignored. It can be used for tokens which can expire and therefore must be read dynamically.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailAuthenticator"
			},
			"binding": {
				"title": "Binding",
				"description": "Sets the binding used to convert from a Camel message to and from a Mail message",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.MailBinding"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "The connection timeout in milliseconds.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 30000
			},
			"contentType": {
				"title": "Content Type",
				"description": "The mail message content type. Use text/html for HTML mails.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "text/plain"
			},
			"contentTypeResolver": {
				"title": "Content Type Resolver",
				"description": "Resolver to determine Content-Type for file attachments.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.mail.ContentTypeResolver"
			},
			"debugMode": {
				"title": "Debug Mode",
				"description": "Enable debug mode on the underlying mail framework. The SUN Mail framework logs the debug messages to System.out by default.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom org.apache.camel.spi.HeaderFilterStrategy to filter headers.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"ignoreUnsupportedCharset": {
				"title": "Ignore Unsupported Charset",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"ignoreUriScheme": {
				"title": "Ignore Uri Scheme",
				"description": "Option to let Camel ignore unsupported charset in the local JVM when sending mails. If the charset is unsupported, then charset=XXX (where XXX represents the unsupported charset) is removed from the content-type, and it relies on the platform default instead.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"javaMailProperties": {
				"title": "Java Mail Properties",
				"description": "Sets the java mail options. Will clear any default properties and only use the properties provided for this method.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"session": {
				"title": "Session",
				"description": "Specifies the mail session that camel should use for all mail interactions. Useful in scenarios where mail sessions are created and managed by some other resource, such as a JavaEE container. When using a custom mail session, then the hostname and port from the mail session will be used (if configured on the session).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:jakarta.mail.Session"
			},
			"useInlineAttachments": {
				"title": "Use Inline Attachments",
				"description": "Whether to use disposition inline or attachment.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"idempotentRepository": {
				"title": "Idempotent Repository",
				"description": "A pluggable repository org.apache.camel.spi.IdempotentRepository which allows to cluster consuming from the same mailbox, and let the repository coordinate whether a mail message is valid for the consumer to process. By default no repository is in use.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.IdempotentRepository"
			},
			"idempotentRepositoryRemoveOnCommit": {
				"title": "Idempotent Repository Remove On Commit",
				"description": "When using idempotent repository, then when the mail message has been successfully processed and is committed, should the message id be removed from the idempotent repository (default) or be kept in the repository. By default its assumed the message id is unique and has no value to be kept in the repository, because the mail message will be marked as seen/moved or deleted to prevent it from being consumed again. And therefore having the message id stored in the idempotent repository has little value. However this option allows to store the message id, for whatever reason you may have.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"searchTerm": {
				"title": "Search Term",
				"description": "Refers to a jakarta.mail.search.SearchTerm which allows to filter mails based on search criteria such as subject, body, from, sent after a certain date etc.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:jakarta.mail.search.SearchTerm"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "60000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "The password for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"username": {
				"title": "Username",
				"description": "The username for login. See also setAuthenticator(MailAuthenticator).",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sortTerm": {
				"title": "Sort Term",
				"description": "Sorting order for messages. Only natively supported for IMAP. Emulated to some degree when using POP3 or when IMAP server does not have the SORT capability.",
				"type": "string",
				"$comment": "group:sort",
				"format": "bean:org.eclipse.angus.mail.imap.SortTerm[]"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"snmp": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname of the SNMP enabled device",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port number of the SNMP enabled device",
				"type": "integer",
				"$comment": "group:common"
			},
			"oids": {
				"title": "Oids",
				"description": "Defines which values you are interested in. Please have a look at the Wikipedia to get a better understanding. You may provide a single OID or a coma separated list of OIDs. Example: oids=1.3.6.1.2.1.1.3.0,1.3.6.1.2.1.25.3.2.1.5.1,1.3.6.1.2.1.25.3.5.1.1.1,1.3.6.1.2.1.43.5.1.1.11.1",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.snmp.OIDList"
			},
			"protocol": {
				"title": "Protocol",
				"description": "Here you can select which protocol to use. You can use either udp or tcp.",
				"type": "string",
				"enum": [
					"tcp",
					"udp"
				],
				"$comment": "group:common",
				"default": "udp"
			},
			"retries": {
				"title": "Retries",
				"description": "Defines how often a retry is made before canceling the request.",
				"type": "integer",
				"$comment": "group:common",
				"default": 2
			},
			"snmpCommunity": {
				"title": "Snmp Community",
				"description": "Sets the community octet string for the snmp request.",
				"type": "string",
				"$comment": "group:common",
				"default": "public"
			},
			"snmpContextEngineId": {
				"title": "Snmp Context Engine Id",
				"description": "Sets the context engine ID field of the scoped PDU.",
				"type": "string",
				"$comment": "group:common"
			},
			"snmpContextName": {
				"title": "Snmp Context Name",
				"description": "Sets the context name field of this scoped PDU.",
				"type": "string",
				"$comment": "group:common"
			},
			"snmpVersion": {
				"title": "Snmp Version",
				"description": "Sets the snmp version for the request. The value 0 means SNMPv1, 1 means SNMPv2c, and the value 3 means SNMPv3",
				"type": "integer",
				"enum": [
					"0",
					"1",
					"3"
				],
				"$comment": "group:common",
				"default": 0
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets the timeout value for the request in millis.",
				"type": "integer",
				"$comment": "group:common",
				"default": 1500
			},
			"type": {
				"title": "Type",
				"description": "Which operation to perform such as poll, trap, etc.",
				"type": "string",
				"enum": [
					"TRAP",
					"POLL",
					"GET_NEXT"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.snmp.SnmpActionType"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "60000"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"treeList": {
				"title": "Tree List",
				"description": "Sets the flag whether the scoped PDU will be displayed as the list if it has child elements in its tree",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"authenticationPassphrase": {
				"title": "Authentication Passphrase",
				"description": "The authentication passphrase. If not null, authenticationProtocol must also be not null. RFC3414 11.2 requires passphrases to have a minimum length of 8 bytes. If the length of authenticationPassphrase is less than 8 bytes an IllegalArgumentException is thrown.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"authenticationProtocol": {
				"title": "Authentication Protocol",
				"description": "Authentication protocol to use if security level is set to enable authentication The possible values are: MD5, SHA1",
				"type": "string",
				"enum": [
					"MD5",
					"SHA1"
				],
				"$comment": "group:security"
			},
			"privacyPassphrase": {
				"title": "Privacy Passphrase",
				"description": "The privacy passphrase. If not null, privacyProtocol must also be not null. RFC3414 11.2 requires passphrases to have a minimum length of 8 bytes. If the length of authenticationPassphrase is less than 8 bytes an IllegalArgumentException is thrown.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"privacyProtocol": {
				"title": "Privacy Protocol",
				"description": "The privacy protocol ID to be associated with this user. If set to null, this user only supports unencrypted messages.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"securityLevel": {
				"title": "Security Level",
				"description": "Sets the security level for this target. The supplied security level must be supported by the security model dependent information associated with the security name set for this target. The value 1 means: No authentication and no encryption. Anyone can create and read messages with this security level The value 2 means: Authentication and no encryption. Only the one with the right authentication key can create messages with this security level, but anyone can read the contents of the message. The value 3 means: Authentication and encryption. Only the one with the right authentication key can create messages with this security level, and only the one with the right encryption/decryption key can read the contents of the message.",
				"type": "integer",
				"enum": [
					"1",
					"2",
					"3"
				],
				"$comment": "group:security",
				"default": 3
			},
			"securityName": {
				"title": "Security Name",
				"description": "Sets the security name to be used with this target.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"port"
		]
	},
	"solr": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The solr instance host name (set to 'default' to use the host name defined on component level)",
				"type": "string",
				"$comment": "group:producer"
			},
			"port": {
				"title": "Port",
				"description": "The solr instance port number",
				"type": "integer",
				"$comment": "group:producer",
				"default": 8983
			},
			"basePath": {
				"title": "Base Path",
				"description": "The solr instance base path (usually /solr)",
				"type": "string",
				"$comment": "group:producer",
				"default": "/solr"
			},
			"async": {
				"title": "Async",
				"description": "Use async request processing (when supported by the solr client)",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"autoCommit": {
				"title": "Auto Commit",
				"description": "If true, each producer insert/delete operation will be automatically performing a commit",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"collection": {
				"title": "Collection",
				"description": "The name of the collection to act against",
				"type": "string",
				"$comment": "group:producer"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "The time in ms to wait before connection will time out.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"deleteByQuery": {
				"title": "Delete By Query",
				"description": "For the delete instruction, interprete body as query/queries instead of id/ids.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"from": {
				"title": "From",
				"description": "Starting index of the response.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "What operation to perform",
				"type": "string",
				"enum": [
					"DELETE",
					"INSERT",
					"PING",
					"SEARCH"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.solr.SolrOperation"
			},
			"requestHandler": {
				"title": "Request Handler",
				"description": "The path of the update request handler (use for update requests / set solr parameter qt for search requests)",
				"type": "string",
				"$comment": "group:producer"
			},
			"requestTimeout": {
				"title": "Request Timeout",
				"description": "The time in ms to wait before the request will time out (former soTimeout).",
				"type": "integer",
				"$comment": "group:producer"
			},
			"size": {
				"title": "Size",
				"description": "Size of the response.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"solrClient": {
				"title": "Solr Client",
				"description": "The solr client to connect to solr. When solrClient bean is provided, all connection properties will be used from that solrClient (host, port, username, password, connectionTimeout, requestTimeout, enableSSL, ...). When not explicitly configured, camel uses the HttpJdkSolrClient.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.solr.client.solrj.SolrClient"
			},
			"certificatePath": {
				"title": "Certificate Path",
				"description": "The certificate that can be used to access the solr host. It can be loaded by default from classpath, but you can prefix with classpath:, file:, or http: to load the resource from different systems.",
				"type": "string",
				"$comment": "group:security"
			},
			"enableSSL": {
				"title": "Enable SSL",
				"description": "Enable SSL",
				"type": "boolean",
				"$comment": "group:security"
			},
			"password": {
				"title": "Password",
				"description": "Password for authenticating",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Basic authenticate user",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"splunk": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name has no purpose",
				"type": "string",
				"$comment": "group:common"
			},
			"app": {
				"title": "App",
				"description": "Splunk app",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionTimeout": {
				"title": "Connection Timeout",
				"description": "Timeout in MS when connecting to Splunk server",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"host": {
				"title": "Host",
				"description": "Splunk host.",
				"type": "string",
				"$comment": "group:common",
				"default": "localhost"
			},
			"owner": {
				"title": "Owner",
				"description": "Splunk owner",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Splunk port",
				"type": "integer",
				"$comment": "group:common",
				"default": 8089
			},
			"scheme": {
				"title": "Scheme",
				"description": "Splunk scheme",
				"type": "string",
				"$comment": "group:common",
				"default": "https"
			},
			"count": {
				"title": "Count",
				"description": "A number that indicates the maximum number of entities to return.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"earliestTime": {
				"title": "Earliest Time",
				"description": "Earliest time of the search time window.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"initEarliestTime": {
				"title": "Init Earliest Time",
				"description": "Initial start offset of the first search",
				"type": "string",
				"$comment": "group:consumer"
			},
			"latestTime": {
				"title": "Latest Time",
				"description": "Latest time of the search time window.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"savedSearch": {
				"title": "Saved Search",
				"description": "The name of the query saved in Splunk to run",
				"type": "string",
				"$comment": "group:consumer"
			},
			"search": {
				"title": "Search",
				"description": "The Splunk query to run",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"streaming": {
				"title": "Streaming",
				"description": "Sets streaming mode. Streaming mode sends exchanges as they are received, rather than in a batch.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"eventHost": {
				"title": "Event Host",
				"description": "Override the default Splunk event host field",
				"type": "string",
				"$comment": "group:producer"
			},
			"index": {
				"title": "Index",
				"description": "Splunk index to write to",
				"type": "string",
				"$comment": "group:producer"
			},
			"raw": {
				"title": "Raw",
				"description": "Should the payload be inserted raw",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"source": {
				"title": "Source",
				"description": "Splunk source argument",
				"type": "string",
				"$comment": "group:producer"
			},
			"sourceType": {
				"title": "Source Type",
				"description": "Splunk sourcetype argument",
				"type": "string",
				"$comment": "group:producer"
			},
			"tcpReceiverLocalPort": {
				"title": "Tcp Receiver Local Port",
				"description": "Splunk tcp receiver port defined locally on splunk server. (For example if splunk port 9997 is mapped to 12345, tcpReceiverLocalPort has to be 9997)",
				"type": "integer",
				"$comment": "group:producer"
			},
			"tcpReceiverPort": {
				"title": "Tcp Receiver Port",
				"description": "Splunk tcp receiver port",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"password": {
				"title": "Password",
				"description": "Password for Splunk",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslProtocol": {
				"title": "Ssl Protocol",
				"description": "Set the ssl protocol to use",
				"type": "string",
				"enum": [
					"TLSv1.2",
					"TLSv1.1",
					"TLSv1",
					"SSLv3"
				],
				"$comment": "group:security",
				"format": "bean:com.splunk.SSLSecurityProtocol",
				"default": "TLSv1.2"
			},
			"token": {
				"title": "Token",
				"description": "User's token for Splunk. This takes precedence over password when both are set",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "Username for Splunk",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"useSunHttpsHandler": {
				"title": "Use Sun Https Handler",
				"description": "Use sun.net.www.protocol.https.Handler Https handler to establish the Splunk Connection. Can be useful when running in application servers to avoid app. server https handling.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"validateCertificates": {
				"title": "Validate Certificates",
				"description": "Sets client's certificate validation mode. Value false makes SSL vulnerable and is not recommended for the production environment.",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"splunk-hec": {
		"properties": {
			"splunkURL": {
				"title": "Splunk URL",
				"description": "Splunk Host and Port (example: my_splunk_server:8089)",
				"type": "string",
				"$comment": "group:producer"
			},
			"bodyOnly": {
				"title": "Body Only",
				"description": "Send only the message body",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"headersOnly": {
				"title": "Headers Only",
				"description": "Send only message headers",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"host": {
				"title": "Host",
				"description": "Splunk host field of the event message. This is not the Splunk host to connect to.",
				"type": "string",
				"$comment": "group:producer"
			},
			"index": {
				"title": "Index",
				"description": "Splunk index to write to",
				"type": "string",
				"$comment": "group:producer",
				"default": "camel"
			},
			"source": {
				"title": "Source",
				"description": "Splunk source argument",
				"type": "string",
				"$comment": "group:producer",
				"default": "camel"
			},
			"sourceType": {
				"title": "Source Type",
				"description": "Splunk sourcetype argument",
				"type": "string",
				"$comment": "group:producer",
				"default": "camel"
			},
			"splunkEndpoint": {
				"title": "Splunk Endpoint",
				"description": "Splunk endpoint Defaults to /services/collector/event To write RAW data like JSON use /services/collector/raw For a list of all endpoints refer to splunk documentation (HTTP Event Collector REST API endpoints) Example for Spunk 8.2.x: https://docs.splunk.com/Documentation/SplunkCloud/8.2.2203/Data/HECRESTendpoints To extract timestamps in Splunk8.0 /services/collector/eventauto_extract_timestamp=true Remember to utilize RAW{} for questionmarks or slashes in parameters.",
				"type": "string",
				"$comment": "group:producer",
				"default": "/services/collector/event"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "SSL configuration",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"time": {
				"title": "Time",
				"description": "Time this even occurred. By default, the time will be when this event hits the splunk server.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"https": {
				"title": "Https",
				"description": "Contact HEC over https.",
				"type": "boolean",
				"$comment": "group:security",
				"default": true
			},
			"skipTlsVerify": {
				"title": "Skip Tls Verify",
				"description": "Splunk HEC TLS verification.",
				"type": "boolean",
				"$comment": "group:security"
			},
			"token": {
				"title": "Token",
				"description": "Splunk HEC token (this is the token created for HEC and not the user's token)",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"splunkURL",
			"token"
		]
	},
	"spring-batch": {
		"properties": {
			"jobName": {
				"title": "Job Name",
				"description": "The name of the Spring Batch job located in the registry.",
				"type": "string",
				"$comment": "group:producer"
			},
			"jobFromHeader": {
				"title": "Job From Header",
				"description": "Explicitly defines if the jobName should be taken from the headers instead of the URI.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"jobLauncher": {
				"title": "Job Launcher",
				"description": "Explicitly specifies a JobLauncher to be used.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.springframework.batch.core.launch.JobLauncher"
			},
			"jobRegistry": {
				"title": "Job Registry",
				"description": "Explicitly specifies a JobRegistry to be used.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.springframework.batch.core.configuration.JobRegistry"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"jobName"
		]
	},
	"spring-event": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of endpoint",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"spring-jdbc": {
		"properties": {
			"dataSourceName": {
				"title": "Data Source Name",
				"description": "Name of DataSource to lookup in the Registry. If the name is dataSource or default, then Camel will attempt to lookup a default DataSource from the registry, meaning if there is a only one instance of DataSource found, then this DataSource will be used.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowNamedParameters": {
				"title": "Allow Named Parameters",
				"description": "Whether to allow using named parameters in the queries.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"outputClass": {
				"title": "Output Class",
				"description": "Specify the full package and class name to use as conversion when outputType=SelectOne or SelectList.",
				"type": "string",
				"$comment": "group:producer"
			},
			"outputType": {
				"title": "Output Type",
				"description": "Determines the output the producer should use.",
				"type": "string",
				"enum": [
					"SelectOne",
					"SelectList",
					"StreamList"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.jdbc.JdbcOutputType",
				"default": "SelectList"
			},
			"parameters": {
				"title": "Parameters",
				"description": "Optional parameters to the java.sql.Statement. For example to set maxRows, fetchSize etc.",
				"type": "object",
				"$comment": "group:producer"
			},
			"readSize": {
				"title": "Read Size",
				"description": "The default maximum number of rows that can be read by a polling query. The default value is 0.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"resetAutoCommit": {
				"title": "Reset Auto Commit",
				"description": "Camel will set the autoCommit on the JDBC connection to be false, commit the change after executed the statement and reset the autoCommit flag of the connection at the end, if the resetAutoCommit is true. If the JDBC connection doesn't support to reset the autoCommit flag, you can set the resetAutoCommit flag to be false, and Camel will not try to reset the autoCommit flag. When used with XA transactions you most likely need to set it to false so that the transaction manager is in charge of committing this tx.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"transacted": {
				"title": "Transacted",
				"description": "Whether transactions are in use.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useGetBytesForBlob": {
				"title": "Use Get Bytes For Blob",
				"description": "To read BLOB columns as bytes instead of string data. This may be needed for certain databases such as Oracle where you must read BLOB columns as bytes.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useHeadersAsParameters": {
				"title": "Use Headers As Parameters",
				"description": "Set this option to true to use the prepareStatementStrategy with named parameters. This allows to define queries with named placeholders, and use headers with the dynamic values for the query placeholders.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useJDBC4ColumnNameAndLabelSemantics": {
				"title": "Use JDBC4 Column Name And Label Semantics",
				"description": "Sets whether to use JDBC 4 or JDBC 3.0 or older semantic when retrieving column name. JDBC 4.0 uses columnLabel to get the column name where as JDBC 3.0 uses both columnName or columnLabel. Unfortunately JDBC drivers behave differently so you can use this option to work out issues around your JDBC driver if you get problem using this component This option is default true.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"beanRowMapper": {
				"title": "Bean Row Mapper",
				"description": "To use a custom org.apache.camel.component.jdbc.BeanRowMapper when using outputClass. The default implementation will lower case the row names and skip underscores, and dashes. For example CUST_ID is mapped as custId.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jdbc.BeanRowMapper"
			},
			"connectionStrategy": {
				"title": "Connection Strategy",
				"description": "To use a custom strategy for working with connections. Do not use a custom strategy when using the spring-jdbc component because a special Spring ConnectionStrategy is used by default to support Spring Transactions.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jdbc.ConnectionStrategy"
			},
			"prepareStatementStrategy": {
				"title": "Prepare Statement Strategy",
				"description": "Allows the plugin to use a custom org.apache.camel.component.jdbc.JdbcPrepareStatementStrategy to control preparation of the query and prepared statement.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.jdbc.JdbcPrepareStatementStrategy"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"dataSourceName"
		]
	},
	"spring-ldap": {
		"properties": {
			"templateName": {
				"title": "Template Name",
				"description": "Name of the Spring LDAP Template bean",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The LDAP operation to be performed.",
				"type": "string",
				"enum": [
					"SEARCH",
					"BIND",
					"UNBIND",
					"AUTHENTICATE",
					"MODIFY_ATTRIBUTES",
					"FUNCTION_DRIVEN"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.springldap.LdapOperation"
			},
			"scope": {
				"title": "Scope",
				"description": "The scope of the search operation.",
				"type": "string",
				"enum": [
					"object",
					"onelevel",
					"subtree"
				],
				"$comment": "group:producer",
				"default": "subtree"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"templateName",
			"operation"
		]
	},
	"spring-rabbitmq": {
		"properties": {
			"exchangeName": {
				"title": "Exchange Name",
				"description": "The exchange name determines the exchange to which the produced messages will be sent to. In the case of consumers, the exchange name determines the exchange the queue will be bound to. Note: to use default exchange then do not use empty name, but use default instead.",
				"type": "string",
				"$comment": "group:common"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "The connection factory to be use. A connection factory must be configured either on the component or endpoint.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.springframework.amqp.rabbit.connection.ConnectionFactory"
			},
			"deadLetterExchange": {
				"title": "Dead Letter Exchange",
				"description": "The name of the dead letter exchange",
				"type": "string",
				"$comment": "group:common"
			},
			"deadLetterExchangeType": {
				"title": "Dead Letter Exchange Type",
				"description": "The type of the dead letter exchange",
				"type": "string",
				"enum": [
					"direct",
					"fanout",
					"headers",
					"topic"
				],
				"$comment": "group:common",
				"default": "direct"
			},
			"deadLetterQueue": {
				"title": "Dead Letter Queue",
				"description": "The name of the dead letter queue",
				"type": "string",
				"$comment": "group:common"
			},
			"deadLetterRoutingKey": {
				"title": "Dead Letter Routing Key",
				"description": "The routing key for the dead letter exchange",
				"type": "string",
				"$comment": "group:common"
			},
			"disableReplyTo": {
				"title": "Disable Reply To",
				"description": "Specifies whether Camel ignores the ReplyTo header in messages. If true, Camel does not send a reply back to the destination specified in the ReplyTo header. You can use this option if you want Camel to consume from a route and you do not want Camel to automatically send back a reply message because another component in your code handles the reply message. You can also use this option if you want to use Camel as a proxy between different message brokers and you want to route message from one system to another.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"queues": {
				"title": "Queues",
				"description": "The queue(s) to use for consuming or producing messages. Multiple queue names can be separated by comma. If none has been configured then Camel will generate an unique id as the queue name.",
				"type": "string",
				"$comment": "group:common"
			},
			"routingKey": {
				"title": "Routing Key",
				"description": "The value of a routing key to use. Default is empty which is not helpful when using the default (or any direct) exchange, but fine if the exchange is a headers exchange for instance.",
				"type": "string",
				"$comment": "group:common"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "Specifies whether to test the connection on startup. This ensures that when Camel starts that all the JMS consumers have a valid connection to the JMS broker. If a connection cannot be granted then Camel throws an exception on startup. This ensures that Camel is not started with failed connections. The JMS producers is tested as well.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"acknowledgeMode": {
				"title": "Acknowledge Mode",
				"description": "Flag controlling the behaviour of the container with respect to message acknowledgement. The most common usage is to let the container handle the acknowledgements (so the listener doesn't need to know about the channel or the message). Set to AcknowledgeMode.MANUAL if the listener will send the acknowledgements itself using Channel.basicAck(long, boolean). Manual acks are consistent with either a transactional or non-transactional channel, but if you are doing no other work on the channel at the same other than receiving a single message then the transaction is probably unnecessary. Set to AcknowledgeMode.NONE to tell the broker not to expect any acknowledgements, and it will assume all messages are acknowledged as soon as they are sent (this is autoack in native Rabbit broker terms). If AcknowledgeMode.NONE then the channel cannot be transactional (so the container will fail on start up if that flag is accidentally set).",
				"type": "string",
				"enum": [
					"NONE",
					"MANUAL",
					"AUTO"
				],
				"$comment": "group:consumer",
				"format": "bean:org.springframework.amqp.core.AcknowledgeMode"
			},
			"asyncConsumer": {
				"title": "Async Consumer",
				"description": "Whether the consumer processes the Exchange asynchronously. If enabled then the consumer may pickup the next message from the queue, while the previous message is being processed asynchronously (by the Asynchronous Routing Engine). This means that messages may be processed not 100% strictly in order. If disabled (as default) then the Exchange is fully processed before the consumer will pickup the next message from the queue.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"autoDeclare": {
				"title": "Auto Declare",
				"description": "Specifies whether the consumer should auto declare binding between exchange, queue and routing key when starting.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"autoStartup": {
				"title": "Auto Startup",
				"description": "Specifies whether the consumer container should auto-startup.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"exchangeType": {
				"title": "Exchange Type",
				"description": "The type of the exchange",
				"type": "string",
				"enum": [
					"direct",
					"fanout",
					"headers",
					"topic"
				],
				"$comment": "group:consumer",
				"default": "direct"
			},
			"exclusive": {
				"title": "Exclusive",
				"description": "Set to true for an exclusive consumer",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"maximumRetryAttempts": {
				"title": "Maximum Retry Attempts",
				"description": "How many times a Rabbitmq consumer will try the same message if Camel failed to process the message (The number of attempts includes the initial try)",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 5
			},
			"noLocal": {
				"title": "No Local",
				"description": "Set to true for an no-local consumer",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"rejectAndDontRequeue": {
				"title": "Reject And Dont Requeue",
				"description": "Whether a Rabbitmq consumer should reject the message without requeuing. This enables failed messages to be sent to a Dead Letter Exchange/Queue, if the broker is so configured.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"retryDelay": {
				"title": "Retry Delay",
				"description": "Delay in millis a Rabbitmq consumer will wait before redelivering a message that Camel failed to process",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1000
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "The number of consumers",
				"type": "integer",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"maxConcurrentConsumers": {
				"title": "Max Concurrent Consumers",
				"description": "The maximum number of consumers (available only with SMLC)",
				"type": "integer",
				"$comment": "group:consumer (advanced)"
			},
			"messageListenerContainerType": {
				"title": "Message Listener Container Type",
				"description": "The type of the MessageListenerContainer",
				"type": "string",
				"enum": [
					"DMLC",
					"SMLC"
				],
				"$comment": "group:consumer (advanced)",
				"default": "DMLC"
			},
			"prefetchCount": {
				"title": "Prefetch Count",
				"description": "Tell the broker how many messages to send in a single request. Often this can be set quite high to improve throughput.",
				"type": "integer",
				"$comment": "group:consumer (advanced)"
			},
			"retry": {
				"title": "Retry",
				"description": "Custom retry configuration to use. If this is configured then the other settings such as maximumRetryAttempts for retry are not in use.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.springframework.retry.interceptor.RetryOperationsInterceptor"
			},
			"allowNullBody": {
				"title": "Allow Null Body",
				"description": "Whether to allow sending messages with no body. If this option is false and the message body is null, then an MessageConversionException is thrown.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"autoDeclareProducer": {
				"title": "Auto Declare Producer",
				"description": "Specifies whether the producer should auto declare binding between exchange, queue and routing key when starting.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"confirm": {
				"title": "Confirm",
				"description": "Controls whether to wait for confirms. The connection factory must be configured for publisher confirms and this method. auto = Camel detects if the connection factory uses confirms or not. disabled = Confirms is disabled. enabled = Confirms is enabled.",
				"type": "string",
				"enum": [
					"auto",
					"enabled",
					"disabled"
				],
				"$comment": "group:producer",
				"default": "auto"
			},
			"confirmTimeout": {
				"title": "Confirm Timeout",
				"description": "Specify the timeout in milliseconds to be used when waiting for a message sent to be confirmed by RabbitMQ when doing send only messaging (InOnly). The default value is 5 seconds. A negative value indicates an indefinite timeout.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "5000"
			},
			"replyTimeout": {
				"title": "Reply Timeout",
				"description": "Specify the timeout in milliseconds to be used when waiting for a reply message when doing request/reply (InOut) messaging. The default value is 30 seconds. A negative value indicates an indefinite timeout (Beware that this will cause a memory leak if a reply is not received).",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "30000"
			},
			"skipBindQueue": {
				"title": "Skip Bind Queue",
				"description": "If true the queue will not be bound to the exchange after declaring it.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"skipDeclareExchange": {
				"title": "Skip Declare Exchange",
				"description": "This can be used if we need to declare the queue but not the exchange.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"skipDeclareQueue": {
				"title": "Skip Declare Queue",
				"description": "If true the producer will not declare and bind a queue. This can be used for directing messages via an existing routing key.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"usePublisherConnection": {
				"title": "Use Publisher Connection",
				"description": "Use a separate connection for publishers and consumers",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"args": {
				"title": "Args",
				"description": "Specify arguments for configuring the different RabbitMQ concepts, a different prefix is required for each element: arg.consumer. arg.exchange. arg.queue. arg.binding. arg.dlq.exchange. arg.dlq.queue. arg.dlq.binding. For example to declare a queue with message ttl argument: args=arg.queue.x-message-ttl=60000",
				"type": "object",
				"$comment": "group:advanced"
			},
			"messageConverter": {
				"title": "Message Converter",
				"description": "To use a custom MessageConverter so you can be in control how to map to/from a org.springframework.amqp.core.Message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.springframework.amqp.support.converter.MessageConverter"
			},
			"messagePropertiesConverter": {
				"title": "Message Properties Converter",
				"description": "To use a custom MessagePropertiesConverter so you can be in control how to map to/from a org.springframework.amqp.core.MessageProperties.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.springrabbit.MessagePropertiesConverter"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"exchangeName"
		]
	},
	"spring-redis": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The host where Redis server is running.",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Redis server port number",
				"type": "integer",
				"$comment": "group:common"
			},
			"channels": {
				"title": "Channels",
				"description": "List of topic names or name patterns to subscribe to. Multiple names can be separated by comma.",
				"type": "string",
				"$comment": "group:common"
			},
			"command": {
				"title": "Command",
				"description": "Default command, which can be overridden by message header. Notice the consumer only supports the following commands: PSUBSCRIBE and SUBSCRIBE",
				"type": "string",
				"enum": [
					"PING",
					"SET",
					"GET",
					"QUIT",
					"EXISTS",
					"DEL",
					"TYPE",
					"FLUSHDB",
					"KEYS",
					"RANDOMKEY",
					"RENAME",
					"RENAMENX",
					"RENAMEX",
					"DBSIZE",
					"EXPIRE",
					"EXPIREAT",
					"TTL",
					"SELECT",
					"MOVE",
					"FLUSHALL",
					"GETSET",
					"MGET",
					"SETNX",
					"SETEX",
					"MSET",
					"MSETNX",
					"DECRBY",
					"DECR",
					"INCRBY",
					"INCR",
					"APPEND",
					"SUBSTR",
					"HSET",
					"HGET",
					"HSETNX",
					"HMSET",
					"HMGET",
					"HINCRBY",
					"HEXISTS",
					"HDEL",
					"HLEN",
					"HKEYS",
					"HVALS",
					"HGETALL",
					"RPUSH",
					"LPUSH",
					"LLEN",
					"LRANGE",
					"LTRIM",
					"LINDEX",
					"LSET",
					"LREM",
					"LPOP",
					"RPOP",
					"RPOPLPUSH",
					"SADD",
					"SMEMBERS",
					"SREM",
					"SPOP",
					"SMOVE",
					"SCARD",
					"SISMEMBER",
					"SINTER",
					"SINTERSTORE",
					"SUNION",
					"SUNIONSTORE",
					"SDIFF",
					"SDIFFSTORE",
					"SRANDMEMBER",
					"ZADD",
					"ZRANGE",
					"ZREM",
					"ZINCRBY",
					"ZRANK",
					"ZREVRANK",
					"ZREVRANGE",
					"ZCARD",
					"ZSCORE",
					"MULTI",
					"DISCARD",
					"EXEC",
					"WATCH",
					"UNWATCH",
					"SORT",
					"BLPOP",
					"BRPOP",
					"AUTH",
					"SUBSCRIBE",
					"PUBLISH",
					"UNSUBSCRIBE",
					"PSUBSCRIBE",
					"PUNSUBSCRIBE",
					"ZCOUNT",
					"ZRANGEBYSCORE",
					"ZREVRANGEBYSCORE",
					"ZREMRANGEBYRANK",
					"ZREMRANGEBYSCORE",
					"ZUNIONSTORE",
					"ZINTERSTORE",
					"SAVE",
					"BGSAVE",
					"BGREWRITEAOF",
					"LASTSAVE",
					"SHUTDOWN",
					"INFO",
					"MONITOR",
					"SLAVEOF",
					"CONFIG",
					"STRLEN",
					"SYNC",
					"LPUSHX",
					"PERSIST",
					"RPUSHX",
					"ECHO",
					"LINSERT",
					"DEBUG",
					"BRPOPLPUSH",
					"SETBIT",
					"GETBIT",
					"SETRANGE",
					"GETRANGE",
					"PEXPIRE",
					"PEXPIREAT",
					"GEOADD",
					"GEODIST",
					"GEOHASH",
					"GEOPOS",
					"GEORADIUS",
					"GEORADIUSBYMEMBER"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.redis.Command",
				"default": "SET"
			},
			"connectionFactory": {
				"title": "Connection Factory",
				"description": "Reference to a pre-configured RedisConnectionFactory instance to use.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.springframework.data.redis.connection.RedisConnectionFactory"
			},
			"redisTemplate": {
				"title": "Redis Template",
				"description": "Reference to a pre-configured RedisTemplate instance to use.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.springframework.data.redis.core.RedisTemplate<java.lang.Object, java.lang.Object>"
			},
			"serializer": {
				"title": "Serializer",
				"description": "Reference to a pre-configured RedisSerializer instance to use.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.springframework.data.redis.serializer.RedisSerializer<java.lang.Object>"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"listenerContainer": {
				"title": "Listener Container",
				"description": "Reference to a pre-configured RedisMessageListenerContainer instance to use.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.springframework.data.redis.listener.RedisMessageListenerContainer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"port"
		]
	},
	"spring-ws": {
		"properties": {
			"type": {
				"title": "Type",
				"description": "Endpoint mapping type if endpoint mapping is used. rootqname - Offers the option to map web service requests based on the qualified name of the root element contained in the message. soapaction - Used to map web service requests based on the SOAP action specified in the header of the message. uri - In order to map web service requests that target a specific URI. xpathresult - Used to map web service requests based on the evaluation of an XPath expression against the incoming message. The result of the evaluation should match the XPath result specified in the endpoint URI. beanname - Allows you to reference an org.apache.camel.component.spring.ws.bean.CamelEndpointDispatcher object in order to integrate with existing (legacy) endpoint mappings like PayloadRootQNameEndpointMapping, SoapActionEndpointMapping, etc",
				"type": "string",
				"enum": [
					"ROOT_QNAME",
					"ACTION",
					"TO",
					"SOAP_ACTION",
					"XPATHRESULT",
					"URI",
					"URI_PATH",
					"BEANNAME"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.spring.ws.type.EndpointMappingType"
			},
			"lookupKey": {
				"title": "Lookup Key",
				"description": "Endpoint mapping key if endpoint mapping is used",
				"type": "string",
				"$comment": "group:consumer"
			},
			"webServiceEndpointUri": {
				"title": "Web Service Endpoint Uri",
				"description": "The default Web Service endpoint uri to use for the producer.",
				"type": "string",
				"$comment": "group:producer"
			},
			"messageFilter": {
				"title": "Message Filter",
				"description": "Option to provide a custom MessageFilter. For example when you want to process your headers or attachments by your own.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.spring.ws.filter.MessageFilter"
			},
			"messageIdStrategy": {
				"title": "Message Id Strategy",
				"description": "Option to provide a custom MessageIdStrategy to control generation of WS-Addressing unique message ids.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.springframework.ws.soap.addressing.messageid.MessageIdStrategy"
			},
			"endpointDispatcher": {
				"title": "Endpoint Dispatcher",
				"description": "Spring org.springframework.ws.server.endpoint.MessageEndpoint for dispatching messages received by Spring-WS to a Camel endpoint, to integrate with existing (legacy) endpoint mappings like PayloadRootQNameEndpointMapping, SoapActionEndpointMapping, etc.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.spring.ws.bean.CamelEndpointDispatcher"
			},
			"endpointMapping": {
				"title": "Endpoint Mapping",
				"description": "Reference to an instance of org.apache.camel.component.spring.ws.bean.CamelEndpointMapping in the Registry/ApplicationContext. Only one bean is required in the registry to serve all Camel/Spring-WS endpoints. This bean is auto-discovered by the MessageDispatcher and used to map requests to Camel endpoints based on characteristics specified on the endpoint (like root QName, SOAP action, etc)",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.spring.ws.bean.CamelSpringWSEndpointMapping"
			},
			"expression": {
				"title": "Expression",
				"description": "The XPath expression to use when option type=xpathresult. Then this option is required to be configured.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"allowResponseAttachmentOverride": {
				"title": "Allow Response Attachment Override",
				"description": "Option to override soap response attachments in in/out exchange with attachments from the actual service layer. If the invoked service appends or rewrites the soap attachments this option when set to true, allows the modified soap attachments to be overwritten in in/out message attachments",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"allowResponseHeaderOverride": {
				"title": "Allow Response Header Override",
				"description": "Option to override soap response header in in/out exchange with header info from the actual service layer. If the invoked service appends or rewrites the soap header this option when set to true, allows the modified soap header to be overwritten in in/out message headers",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"faultAction": {
				"title": "Fault Action",
				"description": "Signifies the value for the faultAction response WS-Addressing Fault Action header that is provided by the method. See org.springframework.ws.soap.addressing.server.annotation.Action annotation for more details.",
				"type": "string",
				"$comment": "group:producer"
			},
			"faultTo": {
				"title": "Fault To",
				"description": "Signifies the value for the faultAction response WS-Addressing FaultTo header that is provided by the method. See org.springframework.ws.soap.addressing.server.annotation.Action annotation for more details.",
				"type": "string",
				"$comment": "group:producer"
			},
			"messageFactory": {
				"title": "Message Factory",
				"description": "Option to provide a custom WebServiceMessageFactory.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.springframework.ws.WebServiceMessageFactory"
			},
			"messageSender": {
				"title": "Message Sender",
				"description": "Option to provide a custom WebServiceMessageSender. For example to perform authentication or use alternative transports",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.springframework.ws.transport.WebServiceMessageSender"
			},
			"outputAction": {
				"title": "Output Action",
				"description": "Signifies the value for the response WS-Addressing Action header that is provided by the method. See org.springframework.ws.soap.addressing.server.annotation.Action annotation for more details.",
				"type": "string",
				"$comment": "group:producer"
			},
			"replyTo": {
				"title": "Reply To",
				"description": "Signifies the value for the replyTo response WS-Addressing ReplyTo header that is provided by the method. See org.springframework.ws.soap.addressing.server.annotation.Action annotation for more details.",
				"type": "string",
				"$comment": "group:producer"
			},
			"soapAction": {
				"title": "Soap Action",
				"description": "SOAP action to include inside a SOAP request when accessing remote web services",
				"type": "string",
				"$comment": "group:producer"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets the socket read timeout (in milliseconds) while invoking a webservice using the producer, see URLConnection.setReadTimeout() and CommonsHttpMessageSender.setReadTimeout(). This option works when using the built-in message sender implementations: CommonsHttpMessageSender and HttpUrlConnectionMessageSender. One of these implementations will be used by default for HTTP based services unless you customize the Spring WS configuration options supplied to the component. If you are using a non-standard sender, it is assumed that you will handle your own timeout configuration. The built-in message sender HttpComponentsMessageSender is considered instead of CommonsHttpMessageSender which has been deprecated, see HttpComponentsMessageSender.setReadTimeout().",
				"type": "integer",
				"$comment": "group:producer"
			},
			"webServiceTemplate": {
				"title": "Web Service Template",
				"description": "Option to provide a custom WebServiceTemplate. This allows for full control over client-side web services handling; like adding a custom interceptor or specifying a fault resolver, message sender or message factory.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.springframework.ws.client.core.WebServiceTemplate"
			},
			"wsAddressingAction": {
				"title": "Ws Addressing Action",
				"description": "WS-Addressing 1.0 action header to include when accessing web services. The To header is set to the address of the web service as specified in the endpoint URI (default Spring-WS behavior).",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object"
	},
	"sql": {
		"properties": {
			"query": {
				"title": "Query",
				"description": "Sets the SQL query to perform. You can externalize the query by using file: or classpath: as prefix and specify the location of the file.",
				"type": "string",
				"$comment": "group:common"
			},
			"allowNamedParameters": {
				"title": "Allow Named Parameters",
				"description": "Whether to allow using named parameters in the queries.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"dataSource": {
				"title": "Data Source",
				"description": "Sets the DataSource to use to communicate with the database at endpoint level.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:javax.sql.DataSource"
			},
			"outputClass": {
				"title": "Output Class",
				"description": "Specify the full package and class name to use as conversion when outputType=SelectOne.",
				"type": "string",
				"$comment": "group:common"
			},
			"outputHeader": {
				"title": "Output Header",
				"description": "Store the query result in a header instead of the message body. By default, outputHeader == null and the query result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the query result and the original message body is preserved.",
				"type": "string",
				"$comment": "group:common"
			},
			"outputType": {
				"title": "Output Type",
				"description": "Make the output of consumer or producer to SelectList as List of Map, or SelectOne as single Java object in the following way: a) If the query has only single column, then that JDBC Column object is returned. (such as SELECT COUNT( ) FROM PROJECT will return a Long object. b) If the query has more than one column, then it will return a Map of that result. c) If the outputClass is set, then it will convert the query result into an Java bean object by calling all the setters that match the column names. It will assume your class has a default constructor to create instance with. d) If the query resulted in more than one rows, it throws an non-unique result exception. StreamList streams the result of the query using an Iterator. This can be used with the Splitter EIP in streaming mode to process the ResultSet in streaming fashion.",
				"type": "string",
				"enum": [
					"SelectOne",
					"SelectList",
					"StreamList"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.sql.SqlOutputType",
				"default": "SelectList"
			},
			"separator": {
				"title": "Separator",
				"description": "The separator to use when parameter values is taken from message body (if the body is a String type), to be inserted at # placeholders. Notice if you use named parameters, then a Map type is used instead. The default value is comma",
				"type": "string",
				"$comment": "group:common",
				"default": ","
			},
			"breakBatchOnConsumeFail": {
				"title": "Break Batch On Consume Fail",
				"description": "Sets whether to break batch if onConsume failed.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"expectedUpdateCount": {
				"title": "Expected Update Count",
				"description": "Sets an expected update count to validate when using onConsume.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": -1
			},
			"maxMessagesPerPoll": {
				"title": "Max Messages Per Poll",
				"description": "Sets the maximum number of messages to poll",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"onConsume": {
				"title": "On Consume",
				"description": "After processing each row then this query can be executed, if the Exchange was processed successfully, for example to mark the row as processed. The query can have parameter.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"onConsumeBatchComplete": {
				"title": "On Consume Batch Complete",
				"description": "After processing the entire batch, this query can be executed to bulk update rows etc. The query cannot have parameters.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"onConsumeFailed": {
				"title": "On Consume Failed",
				"description": "After processing each row then this query can be executed, if the Exchange failed, for example to mark the row as failed. The query can have parameter.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"routeEmptyResultSet": {
				"title": "Route Empty Result Set",
				"description": "Sets whether empty resultset should be allowed to be sent to the next hop. Defaults to false. So the empty resultset will be filtered out.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"transacted": {
				"title": "Transacted",
				"description": "Enables or disables transaction. If enabled then if processing an exchange failed then the consumer breaks out processing any further exchanges to cause a rollback eager.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"useIterator": {
				"title": "Use Iterator",
				"description": "Sets how resultset should be delivered to route. Indicates delivery as either a list or individual object. defaults to true.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"processingStrategy": {
				"title": "Processing Strategy",
				"description": "Allows to plugin to use a custom org.apache.camel.component.sql.SqlProcessingStrategy to execute queries when the consumer has processed the rows/batch.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.component.sql.SqlProcessingStrategy"
			},
			"batch": {
				"title": "Batch",
				"description": "Enables or disables batch mode",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"batchAutoCommitDisabled": {
				"title": "Batch Auto Commit Disabled",
				"description": "Whether to optimize batch by turning off auto-commit which can dramatic improve performance, and instead execute as a manual commit after the entire batch operation is complete",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"noop": {
				"title": "Noop",
				"description": "If set, will ignore the results of the SQL query and use the existing IN message as the OUT message for the continuation of processing",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useMessageBodyForSql": {
				"title": "Use Message Body For Sql",
				"description": "Whether to use the message body as the SQL and then headers for parameters. If this option is enabled then the SQL in the uri is not used. Note that query parameters in the message body are represented by a question mark instead of a # symbol.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"alwaysPopulateStatement": {
				"title": "Always Populate Statement",
				"description": "If enabled then the populateStatement method from org.apache.camel.component.sql.SqlPrepareStatementStrategy is always invoked, also if there is no expected parameters to be prepared. When this is false then the populateStatement is only invoked if there is 1 or more expected parameters to be set; for example this avoids reading the message body/headers for SQL queries with no parameters.",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"fetchSize": {
				"title": "Fetch Size",
				"description": "Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when more rows are needed for ResultSet objects generated by this Statement. If the value specified is zero, then the hint is ignored. The default value is zero. This is important for processing large result sets: Setting this higher than the default value will increase processing speed at the cost of memory consumption; setting this lower can avoid transferring row data that will never be read by the application.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"parametersCount": {
				"title": "Parameters Count",
				"description": "If set greater than zero, then Camel will use this count value of parameters to replace instead of querying via JDBC metadata API. This is useful if the JDBC vendor could not return correct parameters count, then user may override instead.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"placeholder": {
				"title": "Placeholder",
				"description": "Specifies a character that will be replaced to in SQL query. Notice, that it is simple String.replaceAll() operation and no SQL parsing is involved (quoted strings will also change).",
				"type": "string",
				"$comment": "group:advanced",
				"default": "#"
			},
			"prepareStatementStrategy": {
				"title": "Prepare Statement Strategy",
				"description": "Allows to plugin to use a custom org.apache.camel.component.sql.SqlPrepareStatementStrategy to control preparation of the query and prepared statement.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.sql.SqlPrepareStatementStrategy"
			},
			"rowMapperFactory": {
				"title": "Row Mapper Factory",
				"description": "Factory for creating RowMapper",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.sql.RowMapperFactory"
			},
			"templateOptions": {
				"title": "Template Options",
				"description": "Configures the Spring JdbcTemplate with the key/values from the Map",
				"type": "object",
				"$comment": "group:advanced"
			},
			"usePlaceholder": {
				"title": "Use Placeholder",
				"description": "Sets whether to use placeholder and replace all placeholder characters with sign in the SQL queries.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"query"
		]
	},
	"sql-stored": {
		"properties": {
			"template": {
				"title": "Template",
				"description": "Sets the stored procedure template to perform. You can externalize the template by using file: or classpath: as prefix and specify the location of the file.",
				"type": "string",
				"$comment": "group:producer"
			},
			"batch": {
				"title": "Batch",
				"description": "Enables or disables batch mode",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"dataSource": {
				"title": "Data Source",
				"description": "Sets the DataSource to use to communicate with the database.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:javax.sql.DataSource"
			},
			"function": {
				"title": "Function",
				"description": "Whether this call is for a function.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"noop": {
				"title": "Noop",
				"description": "If set, will ignore the results of the stored procedure template and use the existing IN message as the OUT message for the continuation of processing",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"outputHeader": {
				"title": "Output Header",
				"description": "Store the template result in a header instead of the message body. By default, outputHeader == null and the template result is stored in the message body, any existing content in the message body is discarded. If outputHeader is set, the value is used as the name of the header to store the template result and the original message body is preserved.",
				"type": "string",
				"$comment": "group:producer"
			},
			"useMessageBodyForTemplate": {
				"title": "Use Message Body For Template",
				"description": "Whether to use the message body as the stored procedure template and then headers for parameters. If this option is enabled then the template in the uri is not used.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"templateOptions": {
				"title": "Template Options",
				"description": "Configures the Spring JdbcTemplate with the key/values from the Map",
				"type": "object",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"template"
		]
	},
	"ssh": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Sets the hostname of the remote SSH server.",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Sets the port number for the remote SSH server.",
				"type": "integer",
				"$comment": "group:common",
				"default": 22
			},
			"failOnUnknownHost": {
				"title": "Fail On Unknown Host",
				"description": "Specifies whether a connection to an unknown host should fail or not. This value is only checked when the property knownHosts is set.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"knownHostsResource": {
				"title": "Known Hosts Resource",
				"description": "Sets the resource path for a known_hosts file",
				"type": "string",
				"$comment": "group:common"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Sets the timeout in milliseconds to wait in establishing the remote SSH server connection. Defaults to 30000 milliseconds.",
				"type": "integer",
				"$comment": "group:common",
				"default": 30000
			},
			"pollCommand": {
				"title": "Poll Command",
				"description": "Sets the command string to send to the remote SSH server during every poll cycle. Only works with camel-ssh component being used as a consumer, i.e. from(ssh://...) You may need to end your command with a newline, and that must be URL encoded %0A",
				"type": "string",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"channelType": {
				"title": "Channel Type",
				"description": "Sets the channel type to pass to the Channel as part of command execution. Defaults to exec.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "exec"
			},
			"clientBuilder": {
				"title": "Client Builder",
				"description": "Instance of ClientBuilder used by the producer or consumer to create a new SshClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.sshd.client.ClientBuilder"
			},
			"compressions": {
				"title": "Compressions",
				"description": "Whether to use compression, and if so which.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"shellPrompt": {
				"title": "Shell Prompt",
				"description": "Sets the shellPrompt to be dropped when response is read after command execution",
				"type": "string",
				"$comment": "group:advanced"
			},
			"sleepForShellPrompt": {
				"title": "Sleep For Shell Prompt",
				"description": "Sets the sleep period in milliseconds to wait reading response from shell prompt. Defaults to 100 milliseconds.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"certResource": {
				"title": "Cert Resource",
				"description": "Sets the resource path of the certificate to use for Authentication. Will use ResourceHelperKeyPairProvider to resolve file based certificate, and depends on keyType setting.",
				"type": "string",
				"$comment": "group:security"
			},
			"certResourcePassword": {
				"title": "Cert Resource Password",
				"description": "Sets the password to use in loading certResource, if certResource is an encrypted key.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"ciphers": {
				"title": "Ciphers",
				"description": "Comma-separated list of allowed/supported ciphers in their order of preference.",
				"type": "string",
				"$comment": "group:security"
			},
			"kex": {
				"title": "Kex",
				"description": "Comma-separated list of allowed/supported key exchange algorithms in their order of preference.",
				"type": "string",
				"$comment": "group:security"
			},
			"keyPairProvider": {
				"title": "Key Pair Provider",
				"description": "Sets the KeyPairProvider reference to use when connecting using Certificates to the remote SSH Server.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.sshd.common.keyprovider.KeyPairProvider"
			},
			"keyType": {
				"title": "Key Type",
				"description": "Sets the key type to pass to the KeyPairProvider as part of authentication. KeyPairProvider.loadKey(...) will be passed this value. From Camel 3.0.0 / 2.25.0, by default Camel will select the first available KeyPair that is loaded. Prior to this, a KeyType of 'ssh-rsa' was enforced by default.",
				"type": "string",
				"$comment": "group:security"
			},
			"macs": {
				"title": "Macs",
				"description": "Comma-separated list of allowed/supported message authentication code algorithms in their order of preference. The MAC algorithm is used for data integrity protection.",
				"type": "string",
				"$comment": "group:security"
			},
			"password": {
				"title": "Password",
				"description": "Sets the password to use in connecting to remote SSH server. Requires keyPairProvider to be set to null.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"signatures": {
				"title": "Signatures",
				"description": "Comma-separated list of allowed/supported signature algorithms in their order of preference.",
				"type": "string",
				"$comment": "group:security"
			},
			"username": {
				"title": "Username",
				"description": "Sets the username to use in logging into the remote SSH server.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host"
		]
	},
	"stax": {
		"properties": {
			"contentHandlerClass": {
				"title": "Content Handler Class",
				"description": "The FQN class name for the ContentHandler implementation to use.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"contentHandlerClass"
		]
	},
	"stitch": {
		"properties": {
			"tableName": {
				"title": "Table Name",
				"description": "The name of the destination table the data is being pushed to. Table names must be unique in each destination schema, or loading issues will occur. Note: The number of characters in the table name should be within the destination's allowed limits or data will rejected.",
				"type": "string",
				"$comment": "group:producer"
			},
			"keyNames": {
				"title": "Key Names",
				"description": "A collection of comma separated strings representing the Primary Key fields in the source table. Stitch use these Primary Keys to de-dupe data during loading If not provided, the table will be loaded in an append-only manner.",
				"type": "string",
				"$comment": "group:producer"
			},
			"region": {
				"title": "Region",
				"description": "Stitch account region, e.g: europe",
				"type": "string",
				"enum": [
					"NORTH_AMERICA",
					"EUROPE"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.stitch.client.StitchRegion",
				"default": "EUROPE"
			},
			"stitchSchema": {
				"title": "Stitch Schema",
				"description": "A schema that describes the record(s)",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.stitch.client.models.StitchSchema"
			},
			"connectionProvider": {
				"title": "Connection Provider",
				"description": "ConnectionProvider contain configuration for the HttpClient like Maximum connection limit .. etc, you can inject this ConnectionProvider and the StitchClient will initialize HttpClient with this ConnectionProvider",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:reactor.netty.resources.ConnectionProvider"
			},
			"httpClient": {
				"title": "Http Client",
				"description": "Reactor Netty HttpClient, you can injected it if you want to have custom HttpClient",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:reactor.netty.http.client.HttpClient"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"stitchClient": {
				"title": "Stitch Client",
				"description": "Set a custom StitchClient that implements org.apache.camel.component.stitch.client.StitchClient interface",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.stitch.client.StitchClient"
			},
			"token": {
				"title": "Token",
				"description": "Stitch access token for the Stitch Import API",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"token"
		]
	},
	"stomp": {
		"properties": {
			"destination": {
				"title": "Destination",
				"description": "Name of the queue",
				"type": "string",
				"$comment": "group:common"
			},
			"brokerURL": {
				"title": "Broker URL",
				"description": "The URI of the Stomp broker to connect to",
				"type": "string",
				"$comment": "group:common",
				"default": "tcp://localhost:61613"
			},
			"customHeaders": {
				"title": "Custom Headers",
				"description": "To set custom headers",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.util.Properties"
			},
			"host": {
				"title": "Host",
				"description": "The virtual host name",
				"type": "string",
				"$comment": "group:common"
			},
			"version": {
				"title": "Version",
				"description": "The stomp version (1.1, or 1.2)",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"login": {
				"title": "Login",
				"description": "The username",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"passcode": {
				"title": "Passcode",
				"description": "The password",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"destination",
			"brokerURL"
		]
	},
	"stream": {
		"properties": {
			"kind": {
				"title": "Kind",
				"description": "Kind of stream to use such as System.in, System.out, a file, or a http url.",
				"type": "string",
				"enum": [
					"in",
					"out",
					"err",
					"header",
					"file",
					"http"
				],
				"$comment": "group:common"
			},
			"encoding": {
				"title": "Encoding",
				"description": "You can configure the encoding (is a charset name) to use text-based streams (for example, message body is a String object). If not provided, Camel uses the JVM default Charset.",
				"type": "string",
				"$comment": "group:common"
			},
			"fileName": {
				"title": "File Name",
				"description": "When using the stream:file URI format, this option specifies the filename to stream to/from.",
				"type": "string",
				"$comment": "group:common"
			},
			"fileWatcher": {
				"title": "File Watcher",
				"description": "To use JVM file watcher to listen for file change events to support re-loading files that may be overwritten, somewhat like tail --retry",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"groupLines": {
				"title": "Group Lines",
				"description": "To group X number of lines in the consumer. For example to group 10 lines and therefore only spit out an Exchange with 10 lines, instead of 1 Exchange per line.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"groupStrategy": {
				"title": "Group Strategy",
				"description": "Allows to use a custom GroupStrategy to control how to group lines.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.stream.GroupStrategy"
			},
			"httpHeaders": {
				"title": "Http Headers",
				"description": "When using stream:http format, this option specifies optional http headers, such as Accept: application/json. Multiple headers can be separated by comma. The format of headers can be either HEADER=VALUE or HEADER:VALUE. In accordance with the HTTP/1.1 specification, leading and/or trailing whitespace is ignored",
				"type": "string",
				"$comment": "group:consumer"
			},
			"httpUrl": {
				"title": "Http Url",
				"description": "When using stream:http format, this option specifies the http url to stream from.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"initialPromptDelay": {
				"title": "Initial Prompt Delay",
				"description": "Initial delay in milliseconds before showing the message prompt. This delay occurs only once. Can be used during system startup to avoid message prompts being written while other logging is done to the system out.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 2000
			},
			"promptDelay": {
				"title": "Prompt Delay",
				"description": "Optional delay in milliseconds before showing the message prompt.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"promptMessage": {
				"title": "Prompt Message",
				"description": "Message prompt to use when reading from stream:in; for example, you could set this to Enter a command:",
				"type": "string",
				"$comment": "group:consumer"
			},
			"readLine": {
				"title": "Read Line",
				"description": "Whether to read the input stream in line mode (terminate by line breaks). Setting this to false, will instead read the entire stream until EOL.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"retry": {
				"title": "Retry",
				"description": "Will retry opening the stream if it's overwritten, somewhat like tail --retry If reading from files then you should also enable the fileWatcher option, to make it work reliable.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"scanStream": {
				"title": "Scan Stream",
				"description": "To be used for continuously reading a stream such as the unix tail command.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"scanStreamDelay": {
				"title": "Scan Stream Delay",
				"description": "Delay in milliseconds between read attempts when using scanStream.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"appendNewLine": {
				"title": "Append New Line",
				"description": "Whether to append a new line character at end of output.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"autoCloseCount": {
				"title": "Auto Close Count",
				"description": "Number of messages to process before closing stream on Producer side. Never close stream by default (only when Producer is stopped). If more messages are sent, the stream is reopened for another autoCloseCount batch.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"closeOnDone": {
				"title": "Close On Done",
				"description": "This option is used in combination with Splitter and streaming to the same file. The idea is to keep the stream open and only close when the Splitter is done, to improve performance. Mind this requires that you only stream to the same file, and not 2 or more files.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"delay": {
				"title": "Delay",
				"description": "Initial delay in milliseconds before producing the stream.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"readTimeout": {
				"title": "Read Timeout",
				"description": "Sets the read timeout to a specified timeout, in milliseconds. A non-zero value specifies the timeout when reading from Input stream when a connection is established to a resource. If the timeout expires before there is data available for read, a java.net.SocketTimeoutException is raised. A timeout of zero is interpreted as an infinite timeout.",
				"type": "integer",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"kind"
		]
	},
	"string-template": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"delimiterStart": {
				"title": "Delimiter Start",
				"description": "The variable start delimiter",
				"type": "string",
				"$comment": "group:producer",
				"default": "<"
			},
			"delimiterStop": {
				"title": "Delimiter Stop",
				"description": "The variable end delimiter",
				"type": "string",
				"$comment": "group:producer",
				"default": ">"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"stub": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "Name of queue",
				"type": "string",
				"$comment": "group:common"
			},
			"size": {
				"title": "Size",
				"description": "The maximum capacity of the SEDA queue (i.e., the number of messages it can hold). Will by default use the defaultSize set on the SEDA component.",
				"type": "integer",
				"$comment": "group:common",
				"default": 1000
			},
			"concurrentConsumers": {
				"title": "Concurrent Consumers",
				"description": "Number of concurrent threads processing exchanges.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"limitConcurrentConsumers": {
				"title": "Limit Concurrent Consumers",
				"description": "Whether to limit the number of concurrentConsumers to the maximum of 500. By default, an exception will be thrown if an endpoint is configured with a greater number. You can disable that check by turning this option off.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"multipleConsumers": {
				"title": "Multiple Consumers",
				"description": "Specifies whether multiple consumers are allowed. If enabled, you can use SEDA for Publish-Subscribe messaging. That is, you can send a message to the SEDA queue and have each consumer receive a copy of the message. When enabled, this option should be specified on every consumer endpoint.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"pollTimeout": {
				"title": "Poll Timeout",
				"description": "The timeout (in milliseconds) used when polling. When a timeout occurs, the consumer can check whether it is allowed to continue running. Setting a lower value allows the consumer to react more quickly upon shutdown.",
				"type": "integer",
				"$comment": "group:consumer (advanced)",
				"default": 1000
			},
			"purgeWhenStopping": {
				"title": "Purge When Stopping",
				"description": "Whether to purge the task queue when stopping the consumer/route. This allows to stop faster, as any pending messages on the queue is discarded.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"blockWhenFull": {
				"title": "Block When Full",
				"description": "Whether a thread that sends messages to a full SEDA queue will block until the queue's capacity is no longer exhausted. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will instead block and wait until the message can be accepted.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"discardIfNoConsumers": {
				"title": "Discard If No Consumers",
				"description": "Whether the producer should discard the message (do not add the message to the queue), when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"discardWhenFull": {
				"title": "Discard When Full",
				"description": "Whether a thread that sends messages to a full SEDA queue will be discarded. By default, an exception will be thrown stating that the queue is full. By enabling this option, the calling thread will give up sending and continue, meaning that the message was not sent to the SEDA queue.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"failIfNoConsumers": {
				"title": "Fail If No Consumers",
				"description": "Whether the producer should fail by throwing an exception, when sending to a queue with no active consumers. Only one of the options discardIfNoConsumers and failIfNoConsumers can be enabled at the same time.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"offerTimeout": {
				"title": "Offer Timeout",
				"description": "Offer timeout (in milliseconds) can be added to the block case when queue is full. You can disable timeout by using 0 or a negative value.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Timeout (in milliseconds) before a SEDA producer will stop waiting for an asynchronous task to complete. You can disable timeout by using 0 or a negative value.",
				"type": "string",
				"$comment": "group:producer",
				"format": "duration",
				"default": "30000"
			},
			"waitForTaskToComplete": {
				"title": "Wait For Task To Complete",
				"description": "Option to specify whether the caller should wait for the async task to complete or not before continuing. The following three options are supported: Always, Never or IfReplyExpected. The first two values are self-explanatory. The last value, IfReplyExpected, will only wait if the message is Request Reply based. The default option is IfReplyExpected.",
				"type": "string",
				"enum": [
					"Never",
					"IfReplyExpected",
					"Always"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.WaitForTaskToComplete",
				"default": "IfReplyExpected"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"browseLimit": {
				"title": "Browse Limit",
				"description": "Maximum number of messages to keep in memory available for browsing. Use 0 for unlimited.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 100
			},
			"queue": {
				"title": "Queue",
				"description": "Define the queue instance which will be used by the endpoint",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.concurrent.BlockingQueue<org.apache.camel.Exchange>"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"tahu-edge": {
		"properties": {
			"groupId": {
				"title": "Group Id",
				"description": "ID of the group",
				"type": "string",
				"$comment": "group:producer"
			},
			"edgeNode": {
				"title": "Edge Node",
				"description": "ID of the edge node",
				"type": "string",
				"$comment": "group:producer"
			},
			"deviceId": {
				"title": "Device Id",
				"description": "ID of this edge node device",
				"type": "string",
				"$comment": "group:producer (device only)"
			},
			"checkClientIdLength": {
				"title": "Check Client Id Length",
				"description": "MQTT client ID length check enabled",
				"type": "boolean",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "MQTT client ID to use for all server definitions, rather than specifying the same one for each. Note that if neither the 'clientId' parameter nor an 'MqttClientId' are defined for an MQTT Server, a random MQTT Client ID will be generated automatically, prefaced with 'Camel'",
				"type": "string",
				"$comment": "group:common"
			},
			"keepAliveTimeout": {
				"title": "Keep Alive Timeout",
				"description": "MQTT connection keep alive timeout, in seconds",
				"type": "integer",
				"$comment": "group:common",
				"default": 30
			},
			"rebirthDebounceDelay": {
				"title": "Rebirth Debounce Delay",
				"description": "Delay before recurring node rebirth messages will be sent",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"servers": {
				"title": "Servers",
				"description": "MQTT server definitions, given with the following syntax in a comma-separated list: MqttServerName:(MqttClientId:)(tcp/ssl)://hostname(:port),...",
				"type": "string",
				"$comment": "group:common"
			},
			"metricDataTypePayloadMap": {
				"title": "Metric Data Type Payload Map",
				"description": "Tahu SparkplugBPayloadMap to configure metric data types for this edge node or device. Note that this payload is used exclusively as a Sparkplug B spec-compliant configuration for all possible edge node or device metric names, aliases, and data types. This configuration is required to publish proper Sparkplug B NBIRTH and DBIRTH payloads.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.eclipse.tahu.message.model.SparkplugBPayloadMap"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter headers used as Sparkplug metrics. Default value notice: Defaults to sending all Camel Message headers with name prefixes of CamelTahuMetric., including those with null values",
				"type": "string",
				"$comment": "group:producer (advanced)",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"bdSeqManager": {
				"title": "Bd Seq Manager",
				"description": "To use a specific org.eclipse.tahu.message.BdSeqManager implementation to manage edge node birth-death sequence numbers",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.eclipse.tahu.message.BdSeqManager",
				"default": "org.apache.camel.component.tahu.CamelBdSeqManager"
			},
			"bdSeqNumPath": {
				"title": "Bd Seq Num Path",
				"description": "Path for Sparkplug B NBIRTH/NDEATH sequence number persistence files. This path will contain files named as -bdSeqNum and must be writable by the executing process' user",
				"type": "string",
				"$comment": "group:advanced",
				"default": "${sys:java.io.tmpdir}/CamelTahuTemp"
			},
			"useAliases": {
				"title": "Use Aliases",
				"description": "Flag enabling support for metric aliases",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"deviceIds": {
				"title": "Device Ids",
				"description": "ID of each device connected to this edge node, as a comma-separated list",
				"type": "string",
				"$comment": "group:producer (edge node only)"
			},
			"primaryHostId": {
				"title": "Primary Host Id",
				"description": "Host ID of the primary host application for this edge node",
				"type": "string",
				"$comment": "group:producer (edge node only)"
			},
			"password": {
				"title": "Password",
				"description": "Password for MQTT server authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "SSL configuration for MQTT server connections",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"username": {
				"title": "Username",
				"description": "Username for MQTT server authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"groupId",
			"edgeNode",
			"clientId",
			"servers",
			"metricDataTypePayloadMap"
		]
	},
	"tahu-host": {
		"properties": {
			"hostId": {
				"title": "Host Id",
				"description": "ID for the host application",
				"type": "string",
				"$comment": "group:consumer"
			},
			"checkClientIdLength": {
				"title": "Check Client Id Length",
				"description": "MQTT client ID length check enabled",
				"type": "boolean",
				"$comment": "group:common"
			},
			"clientId": {
				"title": "Client Id",
				"description": "MQTT client ID to use for all server definitions, rather than specifying the same one for each. Note that if neither the 'clientId' parameter nor an 'MqttClientId' are defined for an MQTT Server, a random MQTT Client ID will be generated automatically, prefaced with 'Camel'",
				"type": "string",
				"$comment": "group:common"
			},
			"keepAliveTimeout": {
				"title": "Keep Alive Timeout",
				"description": "MQTT connection keep alive timeout, in seconds",
				"type": "integer",
				"$comment": "group:common",
				"default": 30
			},
			"rebirthDebounceDelay": {
				"title": "Rebirth Debounce Delay",
				"description": "Delay before recurring node rebirth messages will be sent",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"servers": {
				"title": "Servers",
				"description": "MQTT server definitions, given with the following syntax in a comma-separated list: MqttServerName:(MqttClientId:)(tcp/ssl)://hostname(:port),...",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"password": {
				"title": "Password",
				"description": "Password for MQTT server authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "SSL configuration for MQTT server connections",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"username": {
				"title": "Username",
				"description": "Username for MQTT server authentication",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"hostId",
			"clientId",
			"servers"
		]
	},
	"telegram": {
		"properties": {
			"type": {
				"title": "Type",
				"description": "The endpoint type. Currently, only the 'bots' type is supported.",
				"type": "string",
				"enum": [
					"bots"
				],
				"$comment": "group:common"
			},
			"limit": {
				"title": "Limit",
				"description": "Limit on the number of updates that can be received in a single polling request.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "100"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Timeout in seconds for long polling. Put 0 for short polling or a bigger number for long polling. Long polling produces shorter response time.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": "30"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"chatId": {
				"title": "Chat Id",
				"description": "The identifier of the chat that will receive the produced messages. Chat ids can be first obtained from incoming messages (eg. when a telegram user starts a conversation with a bot, its client sends automatically a '/start' message containing the chat id). It is an optional parameter, as the chat id can be set dynamically for each outgoing message (using body or headers).",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"baseUri": {
				"title": "Base Uri",
				"description": "Can be used to set an alternative base URI, e.g. when you want to test the component against a mock Telegram API",
				"type": "string",
				"$comment": "group:advanced"
			},
			"bufferSize": {
				"title": "Buffer Size",
				"description": "The initial in-memory buffer size used when transferring data between Camel and AHC Client.",
				"type": "integer",
				"$comment": "group:advanced",
				"default": 1048576
			},
			"client": {
				"title": "Client",
				"description": "To use a custom HttpClient",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.net.http.HttpClient"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "HTTP proxy host which could be used when sending out the message.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "HTTP proxy port which could be used when sending out the message.",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyType": {
				"title": "Proxy Type",
				"description": "HTTP proxy type which could be used when sending out the message.",
				"type": "string",
				"enum": [
					"HTTP",
					"SOCKS4",
					"SOCKS5"
				],
				"$comment": "group:proxy",
				"format": "bean:org.apache.camel.component.telegram.TelegramProxyType",
				"default": "HTTP"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"authorizationToken": {
				"title": "Authorization Token",
				"description": "The authorization token for using the bot (ask the BotFather)",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"type",
			"authorizationToken"
		]
	},
	"tensorflow-serving": {
		"properties": {
			"api": {
				"title": "Api",
				"description": "The TensorFlow Serving API",
				"type": "string",
				"enum": [
					"model-status",
					"model-metadata",
					"classify",
					"regress",
					"predict"
				],
				"$comment": "group:producer"
			},
			"modelName": {
				"title": "Model Name",
				"description": "Required servable name.",
				"type": "string",
				"$comment": "group:common"
			},
			"modelVersion": {
				"title": "Model Version",
				"description": "Optional choice of which version of the model to use. Use this specific version number.",
				"type": "integer",
				"$comment": "group:common"
			},
			"modelVersionLabel": {
				"title": "Model Version Label",
				"description": "Optional choice of which version of the model to use. Use the version associated with the given label.",
				"type": "string",
				"$comment": "group:common"
			},
			"signatureName": {
				"title": "Signature Name",
				"description": "A named signature to evaluate. If unspecified, the default signature will be used.",
				"type": "string",
				"$comment": "group:common"
			},
			"target": {
				"title": "Target",
				"description": "The target URI of the client. See: https://grpc.github.io/grpc-java/javadoc/io/grpc/Grpc.html#newChannelBuilder%28java.lang.String,io.grpc.ChannelCredentials%29",
				"type": "string",
				"$comment": "group:common",
				"default": "localhost:8500"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"credentials": {
				"title": "Credentials",
				"description": "The credentials of the client.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:io.grpc.ChannelCredentials"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"api"
		]
	},
	"thrift": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "The Thrift server host name. This is localhost or 0.0.0.0 (if not defined) when being a consumer or remote server host name when using producer.",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "The Thrift server port",
				"type": "integer",
				"$comment": "group:common"
			},
			"service": {
				"title": "Service",
				"description": "Fully qualified service name from the thrift descriptor file (package dot service definition name)",
				"type": "string",
				"$comment": "group:common"
			},
			"compressionType": {
				"title": "Compression Type",
				"description": "Protocol compression mechanism type",
				"type": "string",
				"enum": [
					"NONE",
					"ZLIB"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.thrift.ThriftCompressionType",
				"default": "NONE"
			},
			"exchangeProtocol": {
				"title": "Exchange Protocol",
				"description": "Exchange protocol serialization type",
				"type": "string",
				"enum": [
					"BINARY",
					"JSON",
					"SJSON",
					"COMPACT"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.thrift.ThriftExchangeProtocol",
				"default": "BINARY"
			},
			"clientTimeout": {
				"title": "Client Timeout",
				"description": "Client timeout for consumers",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"maxPoolSize": {
				"title": "Max Pool Size",
				"description": "The Thrift server consumer max thread pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"poolSize": {
				"title": "Pool Size",
				"description": "The Thrift server consumer initial thread pool size",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"method": {
				"title": "Method",
				"description": "The Thrift invoked method name",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"negotiationType": {
				"title": "Negotiation Type",
				"description": "Security negotiation type",
				"type": "string",
				"enum": [
					"PLAINTEXT",
					"SSL",
					"SASL"
				],
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.thrift.ThriftNegotiationType",
				"default": "PLAINTEXT"
			},
			"sslParameters": {
				"title": "Ssl Parameters",
				"description": "Configuration parameters for SSL/TLS security negotiation",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"port",
			"service"
		]
	},
	"thymeleaf": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"cacheable": {
				"title": "Cacheable",
				"description": "Whether templates have to be considered cacheable or not.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"cacheTimeToLive": {
				"title": "Cache Time To Live",
				"description": "The cache Time To Live for templates, expressed in milliseconds.",
				"type": "integer",
				"$comment": "group:producer"
			},
			"checkExistence": {
				"title": "Check Existence",
				"description": "Whether a template resources will be checked for existence before being returned.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"templateMode": {
				"title": "Template Mode",
				"description": "The template mode to be applied to templates.",
				"type": "string",
				"enum": [
					"HTML",
					"XML",
					"TEXT",
					"JAVASCRIPT",
					"CSS",
					"RAW"
				],
				"$comment": "group:producer",
				"default": "HTML"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"encoding": {
				"title": "Encoding",
				"description": "The character encoding to be used for reading template resources.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"order": {
				"title": "Order",
				"description": "The order in which this template will be resolved as part of the resolver chain.",
				"type": "integer",
				"$comment": "group:advanced"
			},
			"prefix": {
				"title": "Prefix",
				"description": "An optional prefix added to template names to convert them into resource names.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"resolver": {
				"title": "Resolver",
				"description": "The type of resolver to be used by the template engine.",
				"type": "string",
				"enum": [
					"CLASS_LOADER",
					"DEFAULT",
					"FILE",
					"STRING",
					"URL",
					"WEB_APP"
				],
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.thymeleaf.ThymeleafResolverType",
				"default": "CLASS_LOADER"
			},
			"suffix": {
				"title": "Suffix",
				"description": "An optional suffix added to template names to convert them into resource names.",
				"type": "string",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"tika": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "Operation type",
				"type": "string",
				"enum": [
					"parse",
					"detect"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.tika.TikaOperation"
			},
			"tikaParseOutputEncoding": {
				"title": "Tika Parse Output Encoding",
				"description": "Tika Parse Output Encoding",
				"type": "string",
				"$comment": "group:producer"
			},
			"tikaParseOutputFormat": {
				"title": "Tika Parse Output Format",
				"description": "Tika Output Format. Supported output formats. xml: Returns Parsed Content as XML. html: Returns Parsed Content as HTML. text: Returns Parsed Content as Text. textMain: Uses the boilerpipe library to automatically extract the main content from a web page.",
				"type": "string",
				"enum": [
					"xml",
					"html",
					"text",
					"textMain"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.tika.TikaParseOutputFormat",
				"default": "xml"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"tikaConfig": {
				"title": "Tika Config",
				"description": "Tika Config",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.tika.config.TikaConfig"
			},
			"tikaConfigUri": {
				"title": "Tika Config Uri",
				"description": "Tika Config Url",
				"type": "string",
				"$comment": "group:advanced"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation"
		]
	},
	"timer": {
		"properties": {
			"timerName": {
				"title": "Timer Name",
				"description": "The name of the timer",
				"type": "string",
				"$comment": "group:consumer"
			},
			"delay": {
				"title": "Delay",
				"description": "The number of milliseconds to wait before the first event is generated. Should not be used in conjunction with the time option. The default value is 1000.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "1000"
			},
			"fixedRate": {
				"title": "Fixed Rate",
				"description": "Events take place at approximately regular intervals, separated by the specified period.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"includeMetadata": {
				"title": "Include Metadata",
				"description": "Whether to include metadata in the exchange such as fired time, timer name, timer count etc.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"period": {
				"title": "Period",
				"description": "Generate periodic events every period. Must be zero or positive value. The default value is 1000.",
				"type": "string",
				"$comment": "group:consumer",
				"format": "duration",
				"default": "1000"
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit for the number of fires. Therefore, if you set it to 1, the timer will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"daemon": {
				"title": "Daemon",
				"description": "Specifies whether the thread associated with the timer endpoint runs as a daemon. The default value is true.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"pattern": {
				"title": "Pattern",
				"description": "Allows you to specify a custom Date pattern to use for setting the time option using URI syntax.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"synchronous": {
				"title": "Synchronous",
				"description": "Sets whether synchronous processing should be strictly used",
				"type": "boolean",
				"$comment": "group:advanced"
			},
			"time": {
				"title": "Time",
				"description": "A java.util.Date the first event should be generated. If using the URI, the pattern expected is: yyyy-MM-dd HH:mm:ss or yyyy-MM-dd'T'HH:mm:ss.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"timer": {
				"title": "Timer",
				"description": "To use a custom Timer",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Timer"
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"timerName"
		]
	},
	"torchserve": {
		"properties": {
			"api": {
				"title": "Api",
				"description": "The TorchServe API",
				"type": "string",
				"enum": [
					"inference",
					"management",
					"metrics"
				],
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "The API operation",
				"type": "string",
				"enum": [
					"ping",
					"predictions",
					"explanations",
					"register",
					"scale-worker",
					"describe",
					"unregister",
					"list",
					"set-default",
					"metrics"
				],
				"$comment": "group:producer"
			},
			"modelName": {
				"title": "Model Name",
				"description": "The name of model.",
				"type": "string",
				"$comment": "group:common"
			},
			"modelVersion": {
				"title": "Model Version",
				"description": "The version of model.",
				"type": "string",
				"$comment": "group:common"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"inferenceAddress": {
				"title": "Inference Address",
				"description": "The address of the inference API endpoint.",
				"type": "string",
				"$comment": "group:inference"
			},
			"inferencePort": {
				"title": "Inference Port",
				"description": "The port of the inference API endpoint.",
				"type": "integer",
				"$comment": "group:inference",
				"default": 8080
			},
			"listLimit": {
				"title": "List Limit",
				"description": "The maximum number of items to return for the list operation. When this value is present, TorchServe does not return more than the specified number of items, but it might return fewer. This value is optional. If you include a value, it must be between 1 and 1000, inclusive. If you do not include a value, it defaults to 100.",
				"type": "integer",
				"$comment": "group:management",
				"default": 100
			},
			"listNextPageToken": {
				"title": "List Next Page Token",
				"description": "The token to retrieve the next set of results for the list operation. TorchServe provides the token when the response from a previous call has more results than the maximum page size.",
				"type": "string",
				"$comment": "group:management"
			},
			"managementAddress": {
				"title": "Management Address",
				"description": "The address of the management API endpoint.",
				"type": "string",
				"$comment": "group:management"
			},
			"managementPort": {
				"title": "Management Port",
				"description": "The port of the management API endpoint.",
				"type": "integer",
				"$comment": "group:management",
				"default": 8081
			},
			"registerOptions": {
				"title": "Register Options",
				"description": "Additional options for the register operation.",
				"type": "string",
				"$comment": "group:management",
				"format": "bean:org.apache.camel.component.torchserve.client.model.RegisterOptions"
			},
			"scaleWorkerOptions": {
				"title": "Scale Worker Options",
				"description": "Additional options for the scale-worker operation.",
				"type": "string",
				"$comment": "group:management",
				"format": "bean:org.apache.camel.component.torchserve.client.model.ScaleWorkerOptions"
			},
			"unregisterOptions": {
				"title": "Unregister Options",
				"description": "Additional options for the unregister operation.",
				"type": "string",
				"$comment": "group:management",
				"format": "bean:org.apache.camel.component.torchserve.client.model.UnregisterOptions"
			},
			"url": {
				"title": "Url",
				"description": "Model archive download url, support local file or HTTP(s) protocol. For S3, consider using pre-signed url.",
				"type": "string",
				"$comment": "group:management"
			},
			"metricsAddress": {
				"title": "Metrics Address",
				"description": "The address of the metrics API endpoint.",
				"type": "string",
				"$comment": "group:metrics"
			},
			"metricsName": {
				"title": "Metrics Name",
				"description": "Names of metrics to filter.",
				"type": "string",
				"$comment": "group:metrics"
			},
			"metricsPort": {
				"title": "Metrics Port",
				"description": "The port of the metrics API endpoint.",
				"type": "integer",
				"$comment": "group:metrics",
				"default": 8082
			},
			"inferenceKey": {
				"title": "Inference Key",
				"description": "The token authorization key for accessing the inference API.",
				"type": "string",
				"$comment": "group:security"
			},
			"managementKey": {
				"title": "Management Key",
				"description": "The token authorization key for accessing the management API.",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"api",
			"operation"
		]
	},
	"twilio": {
		"properties": {
			"apiName": {
				"title": "Api Name",
				"description": "What kind of operation to perform",
				"type": "string",
				"enum": [
					"ACCOUNT",
					"ADDRESS",
					"APPLICATION",
					"AVAILABLE_PHONE_NUMBER_COUNTRY",
					"CALL",
					"CONFERENCE",
					"CONNECT_APP",
					"INCOMING_PHONE_NUMBER",
					"KEY",
					"MESSAGE",
					"NEW_KEY",
					"NEW_SIGNING_KEY",
					"NOTIFICATION",
					"OUTGOING_CALLER_ID",
					"QUEUE",
					"RECORDING",
					"SHORT_CODE",
					"SIGNING_KEY",
					"TOKEN",
					"TRANSCRIPTION",
					"VALIDATION_REQUEST",
					"ADDRESS_DEPENDENT_PHONE_NUMBER",
					"AVAILABLE_PHONE_NUMBER_COUNTRY_LOCAL",
					"AVAILABLE_PHONE_NUMBER_COUNTRY_MOBILE",
					"AVAILABLE_PHONE_NUMBER_COUNTRY_TOLL_FREE",
					"CALL_NOTIFICATION",
					"CALL_RECORDING",
					"CONFERENCE_PARTICIPANT",
					"INCOMING_PHONE_NUMBER_LOCAL",
					"INCOMING_PHONE_NUMBER_MOBILE",
					"INCOMING_PHONE_NUMBER_TOLL_FREE",
					"MESSAGE_FEEDBACK",
					"MESSAGE_MEDIA",
					"QUEUE_MEMBER",
					"RECORDING_ADD_ON_RESULT",
					"RECORDING_TRANSCRIPTION",
					"RECORDING_ADD_ON_RESULT_PAYLOAD",
					"SIP_CREDENTIAL_LIST",
					"SIP_DOMAIN",
					"SIP_IP_ACCESS_CONTROL_LIST",
					"SIP_CREDENTIAL_LIST_CREDENTIAL",
					"SIP_DOMAIN_CREDENTIAL_LIST_MAPPING",
					"SIP_DOMAIN_IP_ACCESS_CONTROL_LIST_MAPPING",
					"SIP_IP_ACCESS_CONTROL_LIST_IP_ADDRESS",
					"USAGE_RECORD",
					"USAGE_TRIGGER",
					"USAGE_RECORD_ALL_TIME",
					"USAGE_RECORD_DAILY",
					"USAGE_RECORD_LAST_MONTH",
					"USAGE_RECORD_MONTHLY",
					"USAGE_RECORD_THIS_MONTH",
					"USAGE_RECORD_TODAY",
					"USAGE_RECORD_YEARLY",
					"USAGE_RECORD_YESTERDAY"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.twilio.internal.TwilioApiName"
			},
			"methodName": {
				"title": "Method Name",
				"description": "What sub operation to use for the selected operation",
				"type": "string",
				"enum": [
					"create",
					"delete",
					"fetch",
					"read",
					"update"
				],
				"$comment": "group:common"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"apiName",
			"methodName"
		]
	},
	"twitter-directmessage": {
		"properties": {
			"user": {
				"title": "User",
				"description": "The user name to send a direct message. This will be ignored for consumer.",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"type": {
				"title": "Type",
				"description": "Endpoint type to use.",
				"type": "string",
				"enum": [
					"polling",
					"direct"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.twitter.data.EndpointType",
				"default": "polling"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"distanceMetric": {
				"title": "Distance Metric",
				"description": "Used by the geography search, to search by radius using the configured metrics. The unit can either be mi for miles, or km for kilometers. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "string",
				"enum": [
					"km",
					"mi"
				],
				"$comment": "group:consumer (advanced)",
				"default": "km"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"extendedMode": {
				"title": "Extended Mode",
				"description": "Used for enabling full text from twitter (eg receive tweets that contains more than 140 characters).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"latitude": {
				"title": "Latitude",
				"description": "Used by the geography search to search by latitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "number",
				"$comment": "group:consumer (advanced)"
			},
			"locations": {
				"title": "Locations",
				"description": "Bounding boxes, created by pairs of lat/lons. Can be used for filter. A pair is defined as lat,lon. And multiple pairs can be separated by semicolon.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"longitude": {
				"title": "Longitude",
				"description": "Used by the geography search to search by longitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "number",
				"$comment": "group:consumer (advanced)"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"radius": {
				"title": "Radius",
				"description": "Used by the geography search to search by radius. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "number",
				"$comment": "group:consumer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"count": {
				"title": "Count",
				"description": "Limiting number of results per page.",
				"type": "integer",
				"$comment": "group:filter",
				"default": "5"
			},
			"filterOld": {
				"title": "Filter Old",
				"description": "Filter out old tweets, that has previously been polled. This state is stored in memory only, and based on last tweet id.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"lang": {
				"title": "Lang",
				"description": "The lang string ISO_639-1 which will be used for searching",
				"type": "string",
				"$comment": "group:filter"
			},
			"numberOfPages": {
				"title": "Number Of Pages",
				"description": "The number of pages result which you want camel-twitter to consume.",
				"type": "integer",
				"$comment": "group:filter",
				"default": "1"
			},
			"sinceId": {
				"title": "Since Id",
				"description": "The last tweet id which will be used for pulling the tweets. It is useful when the camel route is restarted after a long running.",
				"type": "integer",
				"$comment": "group:filter",
				"default": 1
			},
			"userIds": {
				"title": "User Ids",
				"description": "To filter by user ids for filter. Multiple values can be separated by comma.",
				"type": "string",
				"$comment": "group:filter"
			},
			"httpProxyHost": {
				"title": "Http Proxy Host",
				"description": "The http proxy host which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPassword": {
				"title": "Http Proxy Password",
				"description": "The http proxy password which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPort": {
				"title": "Http Proxy Port",
				"description": "The http proxy port which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"httpProxyUser": {
				"title": "Http Proxy User",
				"description": "The http proxy user which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "30000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "The access token. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"accessTokenSecret": {
				"title": "Access Token Secret",
				"description": "The access secret. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"consumerKey": {
				"title": "Consumer Key",
				"description": "The consumer key. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"consumerSecret": {
				"title": "Consumer Secret",
				"description": "The consumer secret. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sortById": {
				"title": "Sort By Id",
				"description": "Sorts by id, so the oldest are first, and newest last.",
				"type": "boolean",
				"$comment": "group:sort",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"user"
		]
	},
	"twitter-search": {
		"properties": {
			"keywords": {
				"title": "Keywords",
				"description": "The search query, use the keywords AND, OR, - and () to narrow the search results.",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"type": {
				"title": "Type",
				"description": "Endpoint type to use.",
				"type": "string",
				"enum": [
					"polling",
					"direct"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.twitter.data.EndpointType",
				"default": "polling"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"distanceMetric": {
				"title": "Distance Metric",
				"description": "Used by the geography search, to search by radius using the configured metrics. The unit can either be mi for miles, or km for kilometers. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "string",
				"enum": [
					"km",
					"mi"
				],
				"$comment": "group:consumer (advanced)",
				"default": "km"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"extendedMode": {
				"title": "Extended Mode",
				"description": "Used for enabling full text from twitter (eg receive tweets that contains more than 140 characters).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"latitude": {
				"title": "Latitude",
				"description": "Used by the geography search to search by latitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "number",
				"$comment": "group:consumer (advanced)"
			},
			"locations": {
				"title": "Locations",
				"description": "Bounding boxes, created by pairs of lat/lons. Can be used for filter. A pair is defined as lat,lon. And multiple pairs can be separated by semicolon.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"longitude": {
				"title": "Longitude",
				"description": "Used by the geography search to search by longitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "number",
				"$comment": "group:consumer (advanced)"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"radius": {
				"title": "Radius",
				"description": "Used by the geography search to search by radius. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "number",
				"$comment": "group:consumer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"count": {
				"title": "Count",
				"description": "Limiting number of results per page.",
				"type": "integer",
				"$comment": "group:filter",
				"default": "5"
			},
			"filterOld": {
				"title": "Filter Old",
				"description": "Filter out old tweets, that has previously been polled. This state is stored in memory only, and based on last tweet id.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"lang": {
				"title": "Lang",
				"description": "The lang string ISO_639-1 which will be used for searching",
				"type": "string",
				"$comment": "group:filter"
			},
			"numberOfPages": {
				"title": "Number Of Pages",
				"description": "The number of pages result which you want camel-twitter to consume.",
				"type": "integer",
				"$comment": "group:filter",
				"default": "1"
			},
			"sinceId": {
				"title": "Since Id",
				"description": "The last tweet id which will be used for pulling the tweets. It is useful when the camel route is restarted after a long running.",
				"type": "integer",
				"$comment": "group:filter",
				"default": 1
			},
			"userIds": {
				"title": "User Ids",
				"description": "To filter by user ids for filter. Multiple values can be separated by comma.",
				"type": "string",
				"$comment": "group:filter"
			},
			"httpProxyHost": {
				"title": "Http Proxy Host",
				"description": "The http proxy host which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPassword": {
				"title": "Http Proxy Password",
				"description": "The http proxy password which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPort": {
				"title": "Http Proxy Port",
				"description": "The http proxy port which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"httpProxyUser": {
				"title": "Http Proxy User",
				"description": "The http proxy user which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "30000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "The access token. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"accessTokenSecret": {
				"title": "Access Token Secret",
				"description": "The access secret. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"consumerKey": {
				"title": "Consumer Key",
				"description": "The consumer key. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"consumerSecret": {
				"title": "Consumer Secret",
				"description": "The consumer secret. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sortById": {
				"title": "Sort By Id",
				"description": "Sorts by id, so the oldest are first, and newest last.",
				"type": "boolean",
				"$comment": "group:sort",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"keywords"
		]
	},
	"twitter-timeline": {
		"properties": {
			"timelineType": {
				"title": "Timeline Type",
				"description": "The timeline type to produce/consume.",
				"type": "string",
				"enum": [
					"PUBLIC",
					"HOME",
					"USER",
					"MENTIONS",
					"LIST",
					"UNKNOWN"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.twitter.data.TimelineType"
			},
			"list": {
				"title": "List",
				"description": "The list name when using timelineType=list",
				"type": "string",
				"$comment": "group:common"
			},
			"user": {
				"title": "User",
				"description": "The username when using timelineType=user",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"type": {
				"title": "Type",
				"description": "Endpoint type to use.",
				"type": "string",
				"enum": [
					"polling",
					"direct"
				],
				"$comment": "group:consumer",
				"format": "bean:org.apache.camel.component.twitter.data.EndpointType",
				"default": "polling"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"distanceMetric": {
				"title": "Distance Metric",
				"description": "Used by the geography search, to search by radius using the configured metrics. The unit can either be mi for miles, or km for kilometers. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "string",
				"enum": [
					"km",
					"mi"
				],
				"$comment": "group:consumer (advanced)",
				"default": "km"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"extendedMode": {
				"title": "Extended Mode",
				"description": "Used for enabling full text from twitter (eg receive tweets that contains more than 140 characters).",
				"type": "boolean",
				"$comment": "group:consumer (advanced)",
				"default": true
			},
			"latitude": {
				"title": "Latitude",
				"description": "Used by the geography search to search by latitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "number",
				"$comment": "group:consumer (advanced)"
			},
			"locations": {
				"title": "Locations",
				"description": "Bounding boxes, created by pairs of lat/lons. Can be used for filter. A pair is defined as lat,lon. And multiple pairs can be separated by semicolon.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"longitude": {
				"title": "Longitude",
				"description": "Used by the geography search to search by longitude. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "number",
				"$comment": "group:consumer (advanced)"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"radius": {
				"title": "Radius",
				"description": "Used by the geography search to search by radius. You need to configure all the following options: longitude, latitude, radius, and distanceMetric.",
				"type": "number",
				"$comment": "group:consumer (advanced)"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"count": {
				"title": "Count",
				"description": "Limiting number of results per page.",
				"type": "integer",
				"$comment": "group:filter",
				"default": "5"
			},
			"filterOld": {
				"title": "Filter Old",
				"description": "Filter out old tweets, that has previously been polled. This state is stored in memory only, and based on last tweet id.",
				"type": "boolean",
				"$comment": "group:filter",
				"default": true
			},
			"lang": {
				"title": "Lang",
				"description": "The lang string ISO_639-1 which will be used for searching",
				"type": "string",
				"$comment": "group:filter"
			},
			"numberOfPages": {
				"title": "Number Of Pages",
				"description": "The number of pages result which you want camel-twitter to consume.",
				"type": "integer",
				"$comment": "group:filter",
				"default": "1"
			},
			"sinceId": {
				"title": "Since Id",
				"description": "The last tweet id which will be used for pulling the tweets. It is useful when the camel route is restarted after a long running.",
				"type": "integer",
				"$comment": "group:filter",
				"default": 1
			},
			"userIds": {
				"title": "User Ids",
				"description": "To filter by user ids for filter. Multiple values can be separated by comma.",
				"type": "string",
				"$comment": "group:filter"
			},
			"httpProxyHost": {
				"title": "Http Proxy Host",
				"description": "The http proxy host which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPassword": {
				"title": "Http Proxy Password",
				"description": "The http proxy password which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"httpProxyPort": {
				"title": "Http Proxy Port",
				"description": "The http proxy port which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"httpProxyUser": {
				"title": "Http Proxy User",
				"description": "The http proxy user which can be used for the camel-twitter. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:proxy"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "duration",
				"default": "30000"
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"accessToken": {
				"title": "Access Token",
				"description": "The access token. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"accessTokenSecret": {
				"title": "Access Token Secret",
				"description": "The access secret. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"consumerKey": {
				"title": "Consumer Key",
				"description": "The consumer key. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"consumerSecret": {
				"title": "Consumer Secret",
				"description": "The consumer secret. Can also be configured on the TwitterComponent level instead.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"sortById": {
				"title": "Sort By Id",
				"description": "Sorts by id, so the oldest are first, and newest last.",
				"type": "boolean",
				"$comment": "group:sort",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"timelineType"
		]
	},
	"undertow": {
		"properties": {
			"httpURI": {
				"title": "Http URI",
				"description": "The url of the HTTP endpoint to use.",
				"type": "string",
				"$comment": "group:common"
			},
			"useStreaming": {
				"title": "Use Streaming",
				"description": "For HTTP endpoint: if true, text and binary messages will be wrapped as java.io.InputStream before they are passed to an Exchange; otherwise they will be passed as byte. For WebSocket endpoint: if true, text and binary messages will be wrapped as java.io.Reader and java.io.InputStream respectively before they are passed to an Exchange; otherwise they will be passed as String and byte respectively.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"accessLog": {
				"title": "Access Log",
				"description": "Whether or not the consumer should write access log",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"httpMethodRestrict": {
				"title": "Http Method Restrict",
				"description": "Used to only allow consuming if the HttpMethod matches, such as GET/POST/PUT etc. Multiple methods can be specified separated by comma.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"matchOnUriPrefix": {
				"title": "Match On Uri Prefix",
				"description": "Whether or not the consumer should try to find a target consumer by matching the URI prefix if no exact match is found.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"muteException": {
				"title": "Mute Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side the response's body won't contain the exception's stack trace.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"optionsEnabled": {
				"title": "Options Enabled",
				"description": "Specifies whether to enable HTTP OPTIONS for this Servlet consumer. By default OPTIONS is turned off.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side and if the caused Exception was send back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is instead of the HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Java will deserialize the incoming data from the request to Java and that can be a potential security risk.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"handlers": {
				"title": "Handlers",
				"description": "Specifies a comma-delimited set of io.undertow.server.HttpHandler instances to lookup in your Registry. These handlers are added to the Undertow handler chain (for example, to add security). Important: You can not use different handlers with different Undertow endpoints using the same port number. The handlers is associated to the port number. If you need different handlers, then use different port numbers.",
				"type": "string",
				"$comment": "group:consumer (advanced)"
			},
			"cookieHandler": {
				"title": "Cookie Handler",
				"description": "Configure a cookie handler to maintain a HTTP session",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.http.base.cookie.CookieHandler"
			},
			"keepAlive": {
				"title": "Keep Alive",
				"description": "Setting to ensure socket is not closed due to inactivity",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"options": {
				"title": "Options",
				"description": "Sets additional channel options. The options that can be used are defined in org.xnio.Options. To configure from endpoint uri, then prefix each option with option., such as option.close-abort=true&option.send-buffer=8192",
				"type": "object",
				"$comment": "group:producer"
			},
			"preserveHostHeader": {
				"title": "Preserve Host Header",
				"description": "If the option is true, UndertowProducer will set the Host header to the value contained in the current exchange Host header, useful in reverse proxy applications where you want the Host header received by the downstream server to reflect the URL called by the upstream client, this allows applications which use the Host header to generate accurate URL's for a proxied service.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"reuseAddresses": {
				"title": "Reuse Addresses",
				"description": "Setting to facilitate socket multiplexing",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"tcpNoDelay": {
				"title": "Tcp No Delay",
				"description": "Setting to improve TCP protocol performance",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"throwExceptionOnFailure": {
				"title": "Throw Exception On Failure",
				"description": "Option to disable throwing the HttpOperationFailedException in case of failed responses from the remote server. This allows you to get all responses regardless of the HTTP status code.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"accessLogReceiver": {
				"title": "Access Log Receiver",
				"description": "Which Undertow AccessLogReceiver should be used Will use JBossLoggingAccessLogReceiver if not specified",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:io.undertow.server.handlers.accesslog.AccessLogReceiver"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"undertowHttpBinding": {
				"title": "Undertow Http Binding",
				"description": "To use a custom UndertowHttpBinding to control the mapping between Camel message and undertow.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.undertow.UndertowHttpBinding"
			},
			"allowedRoles": {
				"title": "Allowed Roles",
				"description": "Configuration used by UndertowSecurityProvider. Comma separated list of allowed roles.",
				"type": "string",
				"$comment": "group:security"
			},
			"securityConfiguration": {
				"title": "Security Configuration",
				"description": "OConfiguration used by UndertowSecurityProvider. Security configuration object for use from UndertowSecurityProvider. Configuration is UndertowSecurityProvider specific. Each provider decides whether accepts configuration.",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:java.lang.Object"
			},
			"securityProvider": {
				"title": "Security Provider",
				"description": "Security provider allows plug in the provider, which will be used to secure requests. SPI approach could be used too (endpoint then finds security provider using SPI).",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.component.undertow.spi.UndertowSecurityProvider"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			},
			"fireWebSocketChannelEvents": {
				"title": "Fire Web Socket Channel Events",
				"description": "if true, the consumer will post notifications to the route when a new WebSocket peer connects, disconnects, etc. See UndertowConstants.EVENT_TYPE and EventType.",
				"type": "boolean",
				"$comment": "group:websocket"
			},
			"sendTimeout": {
				"title": "Send Timeout",
				"description": "Timeout in milliseconds when sending to a websocket channel. The default timeout is 30000 (30 seconds).",
				"type": "integer",
				"$comment": "group:websocket",
				"default": "30000"
			},
			"sendToAll": {
				"title": "Send To All",
				"description": "To send to all websocket subscribers. Can be used to configure on endpoint level, instead of having to use the UndertowConstants.SEND_TO_ALL header on the message.",
				"type": "boolean",
				"$comment": "group:websocket"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"httpURI"
		]
	},
	"validator": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "URL to a local resource on the classpath, or a reference to lookup a bean in the Registry, or a full URL to a remote resource or resource on the file system which contains the XSD to validate against.",
				"type": "string",
				"$comment": "group:producer"
			},
			"failOnNullBody": {
				"title": "Fail On Null Body",
				"description": "Whether to fail if no body exists.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"failOnNullHeader": {
				"title": "Fail On Null Header",
				"description": "Whether to fail if no header exists when validating against a header.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"headerName": {
				"title": "Header Name",
				"description": "To validate against a header instead of the message body.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"errorHandler": {
				"title": "Error Handler",
				"description": "To use a custom org.apache.camel.processor.validation.ValidatorErrorHandler. The default error handler captures the errors and throws an exception.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.support.processor.validation.ValidatorErrorHandler"
			},
			"resourceResolver": {
				"title": "Resource Resolver",
				"description": "To use a custom LSResourceResolver. Do not use together with resourceResolverFactory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.w3c.dom.ls.LSResourceResolver"
			},
			"resourceResolverFactory": {
				"title": "Resource Resolver Factory",
				"description": "To use a custom LSResourceResolver which depends on a dynamic endpoint resource URI. The default resource resolver factory returns a resource resolver which can read files from the class path and file system. Do not use together with resourceResolver.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.validator.ValidatorResourceResolverFactory"
			},
			"schemaFactory": {
				"title": "Schema Factory",
				"description": "To use a custom javax.xml.validation.SchemaFactory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.validation.SchemaFactory"
			},
			"schemaLanguage": {
				"title": "Schema Language",
				"description": "Configures the W3C XML Schema Namespace URI.",
				"type": "string",
				"$comment": "group:advanced",
				"default": "http://www.w3.org/2001/XMLSchema"
			},
			"useSharedSchema": {
				"title": "Use Shared Schema",
				"description": "Whether the Schema instance should be shared or not. This option is introduced to work around a JDK 1.6.x bug. Xerces should not have this issue.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"velocity": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the resource. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod.",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowContextMapAll": {
				"title": "Allow Context Map All",
				"description": "Sets whether the context map should allow access to all details. By default only the message body and headers can be accessed. This option can be enabled for full access to the current Exchange and CamelContext. Doing so impose a potential security risk as this opens access to the full power of CamelContext API.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Sets whether to use resource content cache or not",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"encoding": {
				"title": "Encoding",
				"description": "Character encoding of the resource content.",
				"type": "string",
				"$comment": "group:producer"
			},
			"loaderCache": {
				"title": "Loader Cache",
				"description": "Enables / disables the velocity resource loader cache which is enabled by default",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"propertiesFile": {
				"title": "Properties File",
				"description": "The URI of the properties file which is used for VelocityEngine initialization.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"vertx": {
		"properties": {
			"address": {
				"title": "Address",
				"description": "Sets the event bus address used to communicate",
				"type": "string",
				"$comment": "group:common"
			},
			"pubSub": {
				"title": "Pub Sub",
				"description": "Whether to use publish/subscribe instead of point to point when sending to a vertx endpoint.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"address"
		]
	},
	"vertx-http": {
		"properties": {
			"httpUri": {
				"title": "Http Uri",
				"description": "The HTTP URI to connect to",
				"type": "string",
				"$comment": "group:producer"
			},
			"connectTimeout": {
				"title": "Connect Timeout",
				"description": "The amount of time in milliseconds until a connection is established. A timeout value of zero is interpreted as an infinite timeout.",
				"type": "integer",
				"$comment": "group:producer",
				"default": 60000
			},
			"cookieStore": {
				"title": "Cookie Store",
				"description": "A custom CookieStore to use when session management is enabled. If this option is not set then an in-memory CookieStore is used",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.vertx.ext.web.client.spi.CookieStore",
				"default": "InMemoryCookieStore"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "A custom org.apache.camel.spi.HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy",
				"default": "VertxHttpHeaderFilterStrategy"
			},
			"httpMethod": {
				"title": "Http Method",
				"description": "The HTTP method to use. The HttpMethod header cannot override this option if set",
				"type": "string",
				"enum": [
					"OPTIONS",
					"GET",
					"HEAD",
					"POST",
					"PUT",
					"DELETE",
					"TRACE",
					"CONNECT",
					"PATCH",
					"PROPFIND",
					"PROPPATCH",
					"MKCOL",
					"COPY",
					"MOVE",
					"LOCK",
					"UNLOCK",
					"MKCALENDAR",
					"VERSION_CONTROL",
					"REPORT",
					"CHECKIN",
					"CHECKOUT",
					"UNCHECKOUT",
					"MKWORKSPACE",
					"UPDATE",
					"LABEL",
					"MERGE",
					"BASELINE_CONTROL",
					"MKACTIVITY",
					"ORDERPATCH",
					"ACL",
					"SEARCH"
				],
				"$comment": "group:producer",
				"format": "bean:io.vertx.core.http.HttpMethod"
			},
			"okStatusCodeRange": {
				"title": "Ok Status Code Range",
				"description": "The status codes which are considered a success response. The values are inclusive. Multiple ranges can be defined, separated by comma, e.g. 200-204,209,301-304. Each range must be a single number or from-to with the dash included",
				"type": "string",
				"$comment": "group:producer",
				"default": "200-299"
			},
			"responsePayloadAsByteArray": {
				"title": "Response Payload As Byte Array",
				"description": "Whether the response body should be byte or as io.vertx.core.buffer.Buffer",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"sessionManagement": {
				"title": "Session Management",
				"description": "Enables session management via WebClientSession. By default the client is configured to use an in-memory CookieStore. The cookieStore option can be used to override this",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"throwExceptionOnFailure": {
				"title": "Throw Exception On Failure",
				"description": "Disable throwing HttpOperationFailedException in case of failed responses from the remote server",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"timeout": {
				"title": "Timeout",
				"description": "The amount of time in milliseconds after which if the request does not return any data within the timeout period a TimeoutException fails the request. Setting zero or a negative value disables the timeout.",
				"type": "integer",
				"$comment": "group:producer",
				"default": -1
			},
			"transferException": {
				"title": "Transfer Exception",
				"description": "If enabled and an Exchange failed processing on the consumer side, and if the caused Exception was sent back serialized in the response as a application/x-java-serialized-object content type. On the producer side the exception will be deserialized and thrown as is, instead of HttpOperationFailedException. The caused exception is required to be serialized. This is by default turned off. If you enable this then be aware that Camel will deserialize the incoming data from the request to a Java object, which can be a potential security risk.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"useCompression": {
				"title": "Use Compression",
				"description": "Set whether compression is enabled to handled compressed (E.g gzipped) responses",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"vertxHttpBinding": {
				"title": "Vertx Http Binding",
				"description": "A custom VertxHttpBinding which can control how to bind between Vert.x and Camel.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.vertx.http.VertxHttpBinding"
			},
			"webClientOptions": {
				"title": "Web Client Options",
				"description": "Sets customized options for configuring the Vert.x WebClient",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.vertx.ext.web.client.WebClientOptions"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"proxyHost": {
				"title": "Proxy Host",
				"description": "The proxy server host address",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPassword": {
				"title": "Proxy Password",
				"description": "The proxy server password if authentication is required",
				"type": "string",
				"$comment": "group:proxy"
			},
			"proxyPort": {
				"title": "Proxy Port",
				"description": "The proxy server port",
				"type": "integer",
				"$comment": "group:proxy"
			},
			"proxyType": {
				"title": "Proxy Type",
				"description": "The proxy server type",
				"type": "string",
				"enum": [
					"HTTP",
					"SOCKS4",
					"SOCKS5"
				],
				"$comment": "group:proxy",
				"format": "bean:io.vertx.core.net.ProxyType"
			},
			"proxyUsername": {
				"title": "Proxy Username",
				"description": "The proxy server username if authentication is required",
				"type": "string",
				"$comment": "group:proxy"
			},
			"basicAuthPassword": {
				"title": "Basic Auth Password",
				"description": "The password to use for basic authentication",
				"type": "string",
				"$comment": "group:security"
			},
			"basicAuthUsername": {
				"title": "Basic Auth Username",
				"description": "The user name to use for basic authentication",
				"type": "string",
				"$comment": "group:security"
			},
			"bearerToken": {
				"title": "Bearer Token",
				"description": "The bearer token to use for bearer token authentication",
				"type": "string",
				"$comment": "group:security"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"httpUri"
		]
	},
	"vertx-websocket": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "WebSocket hostname, such as localhost or a remote host when in client mode.",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "WebSocket port number to use.",
				"type": "integer",
				"$comment": "group:common"
			},
			"path": {
				"title": "Path",
				"description": "WebSocket path to use.",
				"type": "string",
				"$comment": "group:common"
			},
			"allowedOriginPattern": {
				"title": "Allowed Origin Pattern",
				"description": "Regex pattern to match the origin header sent by WebSocket clients",
				"type": "string",
				"$comment": "group:consumer"
			},
			"allowOriginHeader": {
				"title": "Allow Origin Header",
				"description": "Whether the WebSocket client should add the Origin header to the WebSocket handshake request.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"consumeAsClient": {
				"title": "Consume As Client",
				"description": "When set to true, the consumer acts as a WebSocket client, creating exchanges on each received WebSocket event.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"fireWebSocketConnectionEvents": {
				"title": "Fire Web Socket Connection Events",
				"description": "Whether the server consumer will create a message exchange when a new WebSocket peer connects or disconnects",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"handshakeHeaders": {
				"title": "Handshake Headers",
				"description": "Headers to send in the HTTP handshake request. When the endpoint is a consumer, it only works when it consumes a remote host as a client (i.e. consumeAsClient is true).",
				"type": "object",
				"$comment": "group:consumer"
			},
			"maxReconnectAttempts": {
				"title": "Max Reconnect Attempts",
				"description": "When consumeAsClient is set to true this sets the maximum number of allowed reconnection attempts to a previously closed WebSocket. A value of 0 (the default) will attempt to reconnect indefinitely.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 0
			},
			"originHeaderUrl": {
				"title": "Origin Header Url",
				"description": "The value of the Origin header that the WebSocket client should use on the WebSocket handshake request. When not specified, the WebSocket client will automatically determine the value for the Origin from the request URL.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"reconnectInitialDelay": {
				"title": "Reconnect Initial Delay",
				"description": "When consumeAsClient is set to true this sets the initial delay in milliseconds before attempting to reconnect to a previously closed WebSocket.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 0
			},
			"reconnectInterval": {
				"title": "Reconnect Interval",
				"description": "When consumeAsClient is set to true this sets the interval in milliseconds at which reconnecting to a previously closed WebSocket occurs.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 1000
			},
			"router": {
				"title": "Router",
				"description": "To use an existing vertx router for the HTTP server",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:io.vertx.ext.web.Router"
			},
			"serverOptions": {
				"title": "Server Options",
				"description": "Sets customized options for configuring the HTTP server hosting the WebSocket for the consumer",
				"type": "string",
				"$comment": "group:consumer",
				"format": "bean:io.vertx.core.http.HttpServerOptions"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"clientOptions": {
				"title": "Client Options",
				"description": "Sets customized options for configuring the WebSocket client used in the producer",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:io.vertx.core.http.HttpClientOptions"
			},
			"clientSubProtocols": {
				"title": "Client Sub Protocols",
				"description": "Comma separated list of WebSocket subprotocols that the client should use for the Sec-WebSocket-Protocol header",
				"type": "string",
				"$comment": "group:producer"
			},
			"sendToAll": {
				"title": "Send To All",
				"description": "To send to all websocket subscribers. Can be used to configure at the endpoint level, instead of providing the VertxWebsocketConstants.SEND_TO_ALL header on the message. Note that when using this option, the host name specified for the vertx-websocket producer URI must match one used for an existing vertx-websocket consumer. Note that this option only applies when producing messages to endpoints hosted by the vertx-websocket consumer and not to an externally hosted WebSocket.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"sslContextParameters": {
				"title": "Ssl Context Parameters",
				"description": "To configure security using SSLContextParameters",
				"type": "string",
				"$comment": "group:security",
				"format": "bean:org.apache.camel.support.jsse.SSLContextParameters"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"port"
		]
	},
	"wasm": {
		"properties": {
			"functionName": {
				"title": "Function Name",
				"description": "The Function Name",
				"type": "string",
				"$comment": "group:producer"
			},
			"module": {
				"title": "Module",
				"description": "Set the module (the distributable, loadable, and executable unit of code in WebAssembly) resource that provides the producer function.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"functionName",
			"module"
		]
	},
	"weather": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The name value is not used.",
				"type": "string",
				"$comment": "group:common"
			},
			"appid": {
				"title": "Appid",
				"description": "APPID ID used to authenticate the user connected to the API Server",
				"type": "string",
				"$comment": "group:common"
			},
			"headerName": {
				"title": "Header Name",
				"description": "To store the weather result in this header instead of the message body. This is useable if you want to keep current message body as-is.",
				"type": "string",
				"$comment": "group:common"
			},
			"language": {
				"title": "Language",
				"description": "Language of the response.",
				"type": "string",
				"enum": [
					"en",
					"ru",
					"it",
					"es",
					"sp",
					"uk",
					"ua",
					"de",
					"pt",
					"ro",
					"pl",
					"fi",
					"nl",
					"fr",
					"bg",
					"sv",
					"se",
					"zh_tw",
					"zh",
					"zh_cn",
					"tr",
					"hr",
					"ca"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.weather.WeatherLanguage",
				"default": "en"
			},
			"mode": {
				"title": "Mode",
				"description": "The output format of the weather data.",
				"type": "string",
				"enum": [
					"HTML",
					"JSON",
					"XML"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.weather.WeatherMode",
				"default": "JSON"
			},
			"period": {
				"title": "Period",
				"description": "If null, the current weather will be returned, else use values of 5, 7, 14 days. Only the numeric value for the forecast period is actually parsed, so spelling, capitalisation of the time period is up to you (its ignored)",
				"type": "string",
				"$comment": "group:common"
			},
			"units": {
				"title": "Units",
				"description": "The units for temperature measurement.",
				"type": "string",
				"enum": [
					"IMPERIAL",
					"METRIC"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.weather.WeatherUnits"
			},
			"weatherApi": {
				"title": "Weather Api",
				"description": "The API to use (current, forecast/3 hour, forecast daily, station)",
				"type": "string",
				"enum": [
					"Current",
					"Station",
					"Hourly",
					"Daily"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.weather.WeatherApi"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"geoLocationProvider": {
				"title": "Geo Location Provider",
				"description": "A custum geolocation provider to determine the longitude and latitude to use when no location information is set. The default implementaion uses the ipstack API and requires geolocationAccessKey and geolocationRequestHostIP",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.weather.geolocation.GeoLocationProvider"
			},
			"httpClient": {
				"title": "Http Client",
				"description": "To use an existing configured http client (for example with http proxy)",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.client5.http.impl.classic.CloseableHttpClient"
			},
			"cnt": {
				"title": "Cnt",
				"description": "Number of results to be found",
				"type": "integer",
				"$comment": "group:filter"
			},
			"ids": {
				"title": "Ids",
				"description": "List of id's of city/stations. You can separate multiple ids by comma.",
				"type": "string",
				"$comment": "group:filter"
			},
			"lat": {
				"title": "Lat",
				"description": "Latitude of location. You can use lat and lon options instead of location. For boxed queries this is the bottom latitude.",
				"type": "string",
				"$comment": "group:filter"
			},
			"location": {
				"title": "Location",
				"description": "If null Camel will try and determine your current location using the geolocation of your ip address, else specify the city,country. For well known city names, Open Weather Map will determine the best fit, but multiple results may be returned. Hence specifying and country as well will return more accurate data. If you specify current as the location then the component will try to get the current latitude and longitude and use that to get the weather details. You can use lat and lon options instead of location.",
				"type": "string",
				"$comment": "group:filter"
			},
			"lon": {
				"title": "Lon",
				"description": "Longitude of location. You can use lat and lon options instead of location. For boxed queries this is the left longtitude.",
				"type": "string",
				"$comment": "group:filter"
			},
			"rightLon": {
				"title": "Right Lon",
				"description": "For boxed queries this is the right longtitude. Needs to be used in combination with topLat and zoom.",
				"type": "string",
				"$comment": "group:filter"
			},
			"topLat": {
				"title": "Top Lat",
				"description": "For boxed queries this is the top latitude. Needs to be used in combination with rightLon and zoom.",
				"type": "string",
				"$comment": "group:filter"
			},
			"zip": {
				"title": "Zip",
				"description": "Zip-code, e.g. 94040,us",
				"type": "string",
				"$comment": "group:filter"
			},
			"zoom": {
				"title": "Zoom",
				"description": "For boxed queries this is the zoom. Needs to be used in combination with rightLon and topLat.",
				"type": "integer",
				"$comment": "group:filter"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"geolocationAccessKey": {
				"title": "Geolocation Access Key",
				"description": "The geolocation service now needs an accessKey to be used",
				"type": "string",
				"$comment": "group:security"
			},
			"geolocationRequestHostIP": {
				"title": "Geolocation Request Host IP",
				"description": "The geolocation service now needs to specify the IP associated to the accessKey you're using",
				"type": "string",
				"$comment": "group:security"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"appid",
			"geolocationAccessKey",
			"geolocationRequestHostIP"
		]
	},
	"web3j": {
		"properties": {
			"nodeAddress": {
				"title": "Node Address",
				"description": "Sets the node address used to communicate",
				"type": "string",
				"$comment": "group:common"
			},
			"addresses": {
				"title": "Addresses",
				"description": "Contract address or a list of addresses.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:common"
			},
			"fromAddress": {
				"title": "From Address",
				"description": "The address the transaction is send from",
				"type": "string",
				"$comment": "group:common"
			},
			"fromBlock": {
				"title": "From Block",
				"description": "The block number, or the string latest for the last mined block or pending, earliest for not yet mined transactions.",
				"type": "string",
				"$comment": "group:common",
				"default": "latest"
			},
			"fullTransactionObjects": {
				"title": "Full Transaction Objects",
				"description": "If true it returns the full transaction objects, if false only the hashes of the transactions.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"gasLimit": {
				"title": "Gas Limit",
				"description": "The maximum gas allowed in this block.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:java.math.BigInteger"
			},
			"privateFor": {
				"title": "Private For",
				"description": "A transaction privateFor nodes with public keys in a Quorum network",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:common"
			},
			"quorumAPI": {
				"title": "Quorum API",
				"description": "If true, this will support Quorum API.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"toAddress": {
				"title": "To Address",
				"description": "The address the transaction is directed to.",
				"type": "string",
				"$comment": "group:common"
			},
			"toBlock": {
				"title": "To Block",
				"description": "The block number, or the string latest for the last mined block or pending, earliest for not yet mined transactions.",
				"type": "string",
				"$comment": "group:common",
				"default": "latest"
			},
			"topics": {
				"title": "Topics",
				"description": "Topics are order-dependent. Each topic can also be a list of topics. Specify multiple topics separated by comma.",
				"type": "string",
				"$comment": "group:common"
			},
			"web3j": {
				"title": "Web3j",
				"description": "The preconfigured Web3j object.",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.web3j.protocol.Web3j"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"address": {
				"title": "Address",
				"description": "Contract address.",
				"type": "string",
				"$comment": "group:producer"
			},
			"atBlock": {
				"title": "At Block",
				"description": "The block number, or the string latest for the last mined block or pending, earliest for not yet mined transactions.",
				"type": "string",
				"$comment": "group:producer",
				"default": "latest"
			},
			"blockHash": {
				"title": "Block Hash",
				"description": "Hash of the block where this transaction was in.",
				"type": "string",
				"$comment": "group:producer"
			},
			"clientId": {
				"title": "Client Id",
				"description": "A random hexadecimal(32 bytes) ID identifying the client.",
				"type": "string",
				"$comment": "group:producer"
			},
			"data": {
				"title": "Data",
				"description": "The compiled code of a contract OR the hash of the invoked method signature and encoded parameters.",
				"type": "string",
				"$comment": "group:producer"
			},
			"databaseName": {
				"title": "Database Name",
				"description": "The local database name.",
				"type": "string",
				"$comment": "group:producer"
			},
			"filterId": {
				"title": "Filter Id",
				"description": "The filter id to use.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.math.BigInteger"
			},
			"gasPrice": {
				"title": "Gas Price",
				"description": "Gas price used for each paid gas.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.math.BigInteger"
			},
			"hashrate": {
				"title": "Hashrate",
				"description": "A hexadecimal string representation (32 bytes) of the hash rate.",
				"type": "string",
				"$comment": "group:producer"
			},
			"headerPowHash": {
				"title": "Header Pow Hash",
				"description": "The header's pow-hash (256 bits) used for submitting a proof-of-work solution.",
				"type": "string",
				"$comment": "group:producer"
			},
			"index": {
				"title": "Index",
				"description": "The transactions/uncle index position in the block.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.math.BigInteger"
			},
			"keyName": {
				"title": "Key Name",
				"description": "The key name in the database.",
				"type": "string",
				"$comment": "group:producer"
			},
			"mixDigest": {
				"title": "Mix Digest",
				"description": "The mix digest (256 bits) used for submitting a proof-of-work solution.",
				"type": "string",
				"$comment": "group:producer"
			},
			"nonce": {
				"title": "Nonce",
				"description": "The nonce found (64 bits) used for submitting a proof-of-work solution.",
				"type": "string",
				"$comment": "group:producer"
			},
			"operation": {
				"title": "Operation",
				"description": "Operation to use.",
				"type": "string",
				"$comment": "group:producer",
				"default": "transaction"
			},
			"position": {
				"title": "Position",
				"description": "The transaction index position withing a block.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.math.BigInteger"
			},
			"priority": {
				"title": "Priority",
				"description": "The priority of a whisper message.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.math.BigInteger"
			},
			"sha3HashOfDataToSign": {
				"title": "Sha3 Hash Of Data To Sign",
				"description": "Message to sign by calculating an Ethereum specific signature.",
				"type": "string",
				"$comment": "group:producer"
			},
			"signedTransactionData": {
				"title": "Signed Transaction Data",
				"description": "The signed transaction data for a new message call transaction or a contract creation for signed transactions.",
				"type": "string",
				"$comment": "group:producer"
			},
			"sourceCode": {
				"title": "Source Code",
				"description": "The source code to compile.",
				"type": "string",
				"$comment": "group:producer"
			},
			"transactionHash": {
				"title": "Transaction Hash",
				"description": "The information about a transaction requested by transaction hash.",
				"type": "string",
				"$comment": "group:producer"
			},
			"ttl": {
				"title": "Ttl",
				"description": "The time to live in seconds of a whisper message.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.math.BigInteger"
			},
			"value": {
				"title": "Value",
				"description": "The value sent within a transaction.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.math.BigInteger"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"nodeAddress"
		]
	},
	"webhook": {
		"properties": {
			"endpointUri": {
				"title": "Endpoint Uri",
				"description": "The delegate uri. Must belong to a component that supports webhooks.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"webhookAutoRegister": {
				"title": "Webhook Auto Register",
				"description": "Automatically register the webhook at startup and unregister it on shutdown.",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"webhookBasePath": {
				"title": "Webhook Base Path",
				"description": "The first (base) path element where the webhook will be exposed. It's a good practice to set it to a random string, so that it cannot be guessed by unauthorized parties.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"webhookComponentName": {
				"title": "Webhook Component Name",
				"description": "The Camel Rest component to use for the REST transport, such as netty-http.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"webhookExternalUrl": {
				"title": "Webhook External Url",
				"description": "The URL of the current service as seen by the webhook provider",
				"type": "string",
				"$comment": "group:consumer"
			},
			"webhookPath": {
				"title": "Webhook Path",
				"description": "The path where the webhook endpoint will be exposed (relative to basePath, if any)",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"endpointUri"
		]
	},
	"whatsapp": {
		"properties": {
			"phoneNumberId": {
				"title": "Phone Number Id",
				"description": "The phone number ID taken from whatsapp-business dashboard.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "Facebook graph api version.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"baseUri": {
				"title": "Base Uri",
				"description": "Can be used to set an alternative base URI, e.g. when you want to test the component against a mock WhatsApp API",
				"type": "string",
				"$comment": "group:advanced"
			},
			"httpClient": {
				"title": "Http Client",
				"description": "HttpClient implementation",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.net.http.HttpClient"
			},
			"webhookPath": {
				"title": "Webhook Path",
				"description": "Webhook path",
				"type": "string",
				"$comment": "group:advanced",
				"default": "webhook"
			},
			"webhookVerifyToken": {
				"title": "Webhook Verify Token",
				"description": "Webhook verify token",
				"type": "string",
				"$comment": "group:advanced"
			},
			"whatsappService": {
				"title": "Whatsapp Service",
				"description": "WhatsApp service implementation",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.whatsapp.WhatsAppService"
			},
			"authorizationToken": {
				"title": "Authorization Token",
				"description": "The authorization access token taken from whatsapp-business dashboard.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"phoneNumberId",
			"authorizationToken"
		]
	},
	"wordpress": {
		"properties": {
			"operation": {
				"title": "Operation",
				"description": "The endpoint operation.",
				"type": "string",
				"enum": [
					"post",
					"user"
				],
				"$comment": "group:common"
			},
			"operationDetail": {
				"title": "Operation Detail",
				"description": "The second part of an endpoint operation. Needed only when endpoint semantic is not enough, like wordpress:post:delete",
				"type": "string",
				"enum": [
					"delete"
				],
				"$comment": "group:common"
			},
			"apiVersion": {
				"title": "Api Version",
				"description": "The Wordpress REST API version",
				"type": "string",
				"$comment": "group:common",
				"default": "2"
			},
			"criteria": {
				"title": "Criteria",
				"description": "The criteria to use with complex searches.",
				"type": "object",
				"$comment": "group:common"
			},
			"force": {
				"title": "Force",
				"description": "Whether to bypass trash and force deletion.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"id": {
				"title": "Id",
				"description": "The entity ID. Should be passed when the operation performed requires a specific entity, e.g. deleting a post",
				"type": "integer",
				"$comment": "group:common"
			},
			"password": {
				"title": "Password",
				"description": "Password from authorized user",
				"type": "string",
				"$comment": "group:common"
			},
			"searchCriteria": {
				"title": "Search Criteria",
				"description": "Search criteria",
				"type": "string",
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.wordpress.api.model.SearchCriteria"
			},
			"url": {
				"title": "Url",
				"description": "The Wordpress API URL from your site, e.g. http://myblog.com/wp-json/",
				"type": "string",
				"$comment": "group:common"
			},
			"user": {
				"title": "User",
				"description": "Authorized user to perform writing operations",
				"type": "string",
				"$comment": "group:common"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operation",
			"url"
		]
	},
	"workday": {
		"properties": {
			"entity": {
				"title": "Entity",
				"description": "The entity to be requested or subscribed via API.",
				"type": "string",
				"enum": [
					"report",
					"commonAPI"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.workday.WorkdayConfiguration.Entity"
			},
			"path": {
				"title": "Path",
				"description": "The API path to access an entity structure.",
				"type": "string",
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"httpConnectionManager": {
				"title": "Http Connection Manager",
				"description": "Pool connection manager for advanced configuration.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager"
			},
			"reportFormat": {
				"title": "Report Format",
				"description": "Workday Report as a service output format.",
				"type": "string",
				"enum": [
					"json"
				],
				"$comment": "group:format",
				"default": "json"
			},
			"host": {
				"title": "Host",
				"description": "Workday Host name.",
				"type": "string",
				"$comment": "group:host"
			},
			"clientId": {
				"title": "Client Id",
				"description": "Workday client Id generated by API client for integrations.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"clientSecret": {
				"title": "Client Secret",
				"description": "Workday client Secret generated by API client for integrations.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"tokenRefresh": {
				"title": "Token Refresh",
				"description": "Workday token Refresh generated for integrations system user.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"tenant": {
				"title": "Tenant",
				"description": "Workday Tenant name.",
				"type": "string",
				"$comment": "group:tenant"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"entity",
			"path",
			"host",
			"clientId",
			"clientSecret",
			"tokenRefresh",
			"tenant"
		]
	},
	"xchange": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The exchange to connect to",
				"type": "string",
				"$comment": "group:producer"
			},
			"currency": {
				"title": "Currency",
				"description": "The currency",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.knowm.xchange.currency.Currency"
			},
			"currencyPair": {
				"title": "Currency Pair",
				"description": "The currency pair",
				"type": "string",
				"$comment": "group:producer"
			},
			"method": {
				"title": "Method",
				"description": "The method to execute",
				"type": "string",
				"enum": [
					"balances",
					"fundingHistory",
					"wallets",
					"currencies",
					"currencyMetaData",
					"currencyPairs",
					"currencyPairMetaData",
					"ticker"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xchange.XChangeConfiguration.XChangeMethod"
			},
			"service": {
				"title": "Service",
				"description": "The service to call",
				"type": "string",
				"enum": [
					"marketdata",
					"metadata",
					"account"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xchange.XChangeConfiguration.XChangeService"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name",
			"method",
			"service"
		]
	},
	"xj": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowStAX": {
				"title": "Allow StAX",
				"description": "Whether to allow using StAX as the javax.xml.transform.Source. You can enable this if the XSLT library supports StAX such as the Saxon library (camel-saxon). The Xalan library (default in JVM) does not support StAXSource.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Cache for the resource content (the stylesheet file) when it is loaded on startup. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"deleteOutputFile": {
				"title": "Delete Output File",
				"description": "If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"failOnNullBody": {
				"title": "Fail On Null Body",
				"description": "Whether or not to throw an exception if the input body is null.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"output": {
				"title": "Output",
				"description": "Option to specify which output type to use. Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File. For file you must specify the filename in the IN header with the key XsltConstants.XSLT_FILE_NAME which is also CamelXsltFileName. Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.",
				"type": "string",
				"enum": [
					"string",
					"bytes",
					"DOM",
					"file"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xslt.XsltOutput",
				"default": "string"
			},
			"transformDirection": {
				"title": "Transform Direction",
				"description": "Transform direction. Either XML2JSON or JSON2XML",
				"type": "string",
				"enum": [
					"XML2JSON",
					"JSON2XML"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xj.TransformDirection"
			},
			"transformerCacheSize": {
				"title": "Transformer Cache Size",
				"description": "The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().",
				"type": "integer",
				"$comment": "group:producer",
				"default": 0
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"entityResolver": {
				"title": "Entity Resolver",
				"description": "To use a custom org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.xml.sax.EntityResolver"
			},
			"errorListener": {
				"title": "Error Listener",
				"description": "Allows to configure to use a custom javax.xml.transform.ErrorListener. Beware when doing this then the default error listener which captures any errors or fatal errors and store information on the Exchange as properties is not in use. So only use this option for special use-cases.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.ErrorListener"
			},
			"resultHandlerFactory": {
				"title": "Result Handler Factory",
				"description": "Allows you to use a custom org.apache.camel.builder.xml.ResultHandlerFactory which is capable of using custom org.apache.camel.builder.xml.ResultHandler types.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.xslt.ResultHandlerFactory"
			},
			"saxonConfiguration": {
				"title": "Saxon Configuration",
				"description": "To use a custom Saxon configuration",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:net.sf.saxon.Configuration"
			},
			"saxonExtensionFunctions": {
				"title": "Saxon Extension Functions",
				"description": "Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition. You would need to add camel-saxon to the classpath. The function is looked up in the registry, where you can comma to separate multiple values to lookup.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"secureProcessing": {
				"title": "Secure Processing",
				"description": "Feature for XML secure processing (see javax.xml.XMLConstants). This is enabled by default. However, when using Saxon Professional you may need to turn this off to allow Saxon to be able to use Java extension functions.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"transformerFactory": {
				"title": "Transformer Factory",
				"description": "To use a custom XSLT transformer factory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.TransformerFactory"
			},
			"transformerFactoryClass": {
				"title": "Transformer Factory Class",
				"description": "To use a custom XSLT transformer factory, specified as a FQN class name",
				"type": "string",
				"$comment": "group:advanced"
			},
			"transformerFactoryConfigurationStrategy": {
				"title": "Transformer Factory Configuration Strategy",
				"description": "A configuration strategy to apply on freshly created instances of TransformerFactory.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.xslt.TransformerFactoryConfigurationStrategy"
			},
			"uriResolver": {
				"title": "Uri Resolver",
				"description": "To use a custom javax.xml.transform.URIResolver",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.URIResolver"
			},
			"xsltMessageLogger": {
				"title": "Xslt Message Logger",
				"description": "A consumer to messages generated during XSLT transformations.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.xslt.XsltMessageLogger"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri",
			"transformDirection"
		]
	},
	"xmlsecurity-sign": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The name part in the URI can be chosen by the user to distinguish between different signer endpoints within the camel context.",
				"type": "string",
				"$comment": "group:producer"
			},
			"addKeyInfoReference": {
				"title": "Add Key Info Reference",
				"description": "In order to protect the KeyInfo element from tampering you can add a reference to the signed info element so that it is protected via the signature value. The default value is true. Only relevant when a KeyInfo is returned by KeyAccessor. and KeyInfo#getId() is not null.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"baseUri": {
				"title": "Base Uri",
				"description": "You can set a base URI which is used in the URI dereferencing. Relative URIs are then concatenated with the base URI.",
				"type": "string",
				"$comment": "group:producer"
			},
			"canonicalizationMethod": {
				"title": "Canonicalization Method",
				"description": "Canonicalization method used to canonicalize the SignedInfo element before the digest is calculated. You can use the helper methods XmlSignatureHelper.getCanonicalizationMethod(String algorithm) or getCanonicalizationMethod(String algorithm, List inclusiveNamespacePrefixes) to create a canonicalization method.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:javax.xml.crypto.AlgorithmMethod",
				"default": "http://www.w3.org/TR/2001/REC-xml-c14n-20010315"
			},
			"clearHeaders": {
				"title": "Clear Headers",
				"description": "Determines if the XML signature specific headers be cleared after signing and verification. Defaults to true.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"contentObjectId": {
				"title": "Content Object Id",
				"description": "Sets the content object Id attribute value. By default a UUID is generated. If you set the null value, then a new UUID will be generated. Only used in the enveloping case.",
				"type": "string",
				"$comment": "group:producer"
			},
			"contentReferenceType": {
				"title": "Content Reference Type",
				"description": "Type of the content reference. The default value is null. This value can be overwritten by the header XmlSignatureConstants#HEADER_CONTENT_REFERENCE_TYPE.",
				"type": "string",
				"$comment": "group:producer"
			},
			"contentReferenceUri": {
				"title": "Content Reference Uri",
				"description": "Reference URI for the content to be signed. Only used in the enveloped case. If the reference URI contains an ID attribute value, then the resource schema URI ( setSchemaResourceUri(String)) must also be set because the schema validator will then find out which attributes are ID attributes. Will be ignored in the enveloping or detached case.",
				"type": "string",
				"$comment": "group:producer"
			},
			"cryptoContextProperties": {
				"title": "Crypto Context Properties",
				"description": "Sets the crypto context properties. See {link XMLCryptoContext#setProperty(String, Object)}. Possible properties are defined in XMLSignContext an XMLValidateContext (see Supported Properties). The following properties are set by default to the value Boolean#TRUE for the XML validation. If you want to switch these features off you must set the property value to Boolean#FALSE. org.jcp.xml.dsig.validateManifests javax.xml.crypto.dsig.cacheReference",
				"type": "object",
				"$comment": "group:producer"
			},
			"digestAlgorithm": {
				"title": "Digest Algorithm",
				"description": "Digest algorithm URI. Optional parameter. This digest algorithm is used for calculating the digest of the input message. If this digest algorithm is not specified then the digest algorithm is calculated from the signature algorithm. Example: http://www.w3.org/2001/04/xmlenc#sha256",
				"type": "string",
				"$comment": "group:producer"
			},
			"disallowDoctypeDecl": {
				"title": "Disallow Doctype Decl",
				"description": "Disallows that the incoming XML document contains DTD DOCTYPE declaration. The default value is Boolean#TRUE.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"keyAccessor": {
				"title": "Key Accessor",
				"description": "For the signing process, a private key is necessary. You specify a key accessor bean which provides this private key. The key accessor bean must implement the KeyAccessor interface. The package org.apache.camel.component.xmlsecurity.api contains the default implementation class DefaultKeyAccessor which reads the private key from a Java keystore.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xmlsecurity.api.KeyAccessor"
			},
			"omitXmlDeclaration": {
				"title": "Omit Xml Declaration",
				"description": "Indicator whether the XML declaration in the outgoing message body should be omitted. Default value is false. Can be overwritten by the header XmlSignatureConstants#HEADER_OMIT_XML_DECLARATION.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"outputXmlEncoding": {
				"title": "Output Xml Encoding",
				"description": "The character encoding of the resulting signed XML document. If null then the encoding of the original XML document is used.",
				"type": "string",
				"$comment": "group:producer"
			},
			"parentLocalName": {
				"title": "Parent Local Name",
				"description": "Local name of the parent element to which the XML signature element will be added. Only relevant for enveloped XML signature. Alternatively you can also use setParentXpath(XPathFilterParameterSpec). Default value is null. The value must be null for enveloping and detached XML signature. This parameter or the parameter setParentXpath(XPathFilterParameterSpec) for enveloped signature and the parameter setXpathsToIdAttributes(List) for detached signature must not be set in the same configuration. If the parameters parentXpath and parentLocalName are specified in the same configuration then an exception is thrown.",
				"type": "string",
				"$comment": "group:producer"
			},
			"parentNamespace": {
				"title": "Parent Namespace",
				"description": "Namespace of the parent element to which the XML signature element will be added.",
				"type": "string",
				"$comment": "group:producer"
			},
			"parentXpath": {
				"title": "Parent Xpath",
				"description": "Sets the XPath to find the parent node in the enveloped case. Either you specify the parent node via this method or the local name and namespace of the parent with the methods setParentLocalName(String) and setParentNamespace(String). Default value is null. The value must be null for enveloping and detached XML signature. If the parameters parentXpath and parentLocalName are specified in the same configuration then an exception is thrown.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:javax.xml.crypto.dsig.spec.XPathFilterParameterSpec"
			},
			"plainText": {
				"title": "Plain Text",
				"description": "Indicator whether the message body contains plain text. The default value is false, indicating that the message body contains XML. The value can be overwritten by the header XmlSignatureConstants#HEADER_MESSAGE_IS_PLAIN_TEXT.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"plainTextEncoding": {
				"title": "Plain Text Encoding",
				"description": "Encoding of the plain text. Only relevant if the message body is plain text (see parameter plainText. Default value is UTF-8.",
				"type": "string",
				"$comment": "group:producer",
				"default": "UTF-8"
			},
			"prefixForXmlSignatureNamespace": {
				"title": "Prefix For Xml Signature Namespace",
				"description": "Namespace prefix for the XML signature namespace http://www.w3.org/2000/09/xmldsig#. Default value is ds. If null or an empty value is set then no prefix is used for the XML signature namespace. See best practice http://www.w3.org/TR/xmldsig-bestpractices/#signing-xml- without-namespaces",
				"type": "string",
				"$comment": "group:producer",
				"default": "ds"
			},
			"properties": {
				"title": "Properties",
				"description": "For adding additional References and Objects to the XML signature which contain additional properties, you can provide a bean which implements the XmlSignatureProperties interface.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xmlsecurity.api.XmlSignatureProperties"
			},
			"schemaResourceUri": {
				"title": "Schema Resource Uri",
				"description": "Classpath to the XML Schema. Must be specified in the detached XML Signature case for determining the ID attributes, might be set in the enveloped and enveloping case. If set, then the XML document is validated with the specified XML schema. The schema resource URI can be overwritten by the header XmlSignatureConstants#HEADER_SCHEMA_RESOURCE_URI.",
				"type": "string",
				"$comment": "group:producer"
			},
			"signatureAlgorithm": {
				"title": "Signature Algorithm",
				"description": "Signature algorithm. Default value is http://www.w3.org/2000/09/xmldsig#rsa-sha1.",
				"type": "string",
				"$comment": "group:producer",
				"default": "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"
			},
			"signatureId": {
				"title": "Signature Id",
				"description": "Sets the signature Id. If this parameter is not set (null value) then a unique ID is generated for the signature ID (default). If this parameter is set to (empty string) then no Id attribute is created in the signature element.",
				"type": "string",
				"$comment": "group:producer"
			},
			"transformMethods": {
				"title": "Transform Methods",
				"description": "Transforms which are executed on the message body before the digest is calculated. By default, C14n is added and in the case of enveloped signature (see option parentLocalName) also http://www.w3.org/2000/09/xmldsig#enveloped-signature is added at position 0 of the list. Use methods in XmlSignatureHelper to create the transform methods.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:producer"
			},
			"xpathsToIdAttributes": {
				"title": "Xpaths To Id Attributes",
				"description": "Define the elements which are signed in the detached case via XPATH expressions to ID attributes (attributes of type ID). For each element found via the XPATH expression a detached signature is created whose reference URI contains the corresponding attribute value (preceded by '#'). The signature becomes the last sibling of the signed element. Elements with deeper hierarchy level are signed first. You can also set the XPATH list dynamically via the header XmlSignatureConstants#HEADER_XPATHS_TO_ID_ATTRIBUTES. The parameter setParentLocalName(String) or setParentXpath(XPathFilterParameterSpec) for enveloped signature and this parameter for detached signature must not be set in the same configuration.",
				"type": "array",
				"items": {
					"type": "string"
				},
				"$comment": "group:producer"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"uriDereferencer": {
				"title": "Uri Dereferencer",
				"description": "If you want to restrict the remote access via reference URIs, you can set an own dereferencer. Optional parameter. If not set the provider default dereferencer is used which can resolve URI fragments, HTTP, file and XPpointer URIs. Attention: The implementation is provider dependent!",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.crypto.URIDereferencer"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"xmlsecurity-verify": {
		"properties": {
			"name": {
				"title": "Name",
				"description": "The name part in the URI can be chosen by the user to distinguish between different verify endpoints within the camel context.",
				"type": "string",
				"$comment": "group:producer"
			},
			"baseUri": {
				"title": "Base Uri",
				"description": "You can set a base URI which is used in the URI dereferencing. Relative URIs are then concatenated with the base URI.",
				"type": "string",
				"$comment": "group:producer"
			},
			"clearHeaders": {
				"title": "Clear Headers",
				"description": "Determines if the XML signature specific headers be cleared after signing and verification. Defaults to true.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"cryptoContextProperties": {
				"title": "Crypto Context Properties",
				"description": "Sets the crypto context properties. See {link XMLCryptoContext#setProperty(String, Object)}. Possible properties are defined in XMLSignContext an XMLValidateContext (see Supported Properties). The following properties are set by default to the value Boolean#TRUE for the XML validation. If you want to switch these features off you must set the property value to Boolean#FALSE. org.jcp.xml.dsig.validateManifests javax.xml.crypto.dsig.cacheReference",
				"type": "object",
				"$comment": "group:producer"
			},
			"disallowDoctypeDecl": {
				"title": "Disallow Doctype Decl",
				"description": "Disallows that the incoming XML document contains DTD DOCTYPE declaration. The default value is Boolean#TRUE.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"keySelector": {
				"title": "Key Selector",
				"description": "Provides the key for validating the XML signature.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:javax.xml.crypto.KeySelector"
			},
			"omitXmlDeclaration": {
				"title": "Omit Xml Declaration",
				"description": "Indicator whether the XML declaration in the outgoing message body should be omitted. Default value is false. Can be overwritten by the header XmlSignatureConstants#HEADER_OMIT_XML_DECLARATION.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"outputNodeSearch": {
				"title": "Output Node Search",
				"description": "Sets the output node search value for determining the node from the XML signature document which shall be set to the output message body. The class of the value depends on the type of the output node search. The output node search is forwarded to XmlSignature2Message.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:java.lang.Object"
			},
			"outputNodeSearchType": {
				"title": "Output Node Search Type",
				"description": "Determines the search type for determining the output node which is serialized into the output message bodyF. See setOutputNodeSearch(Object). The supported default search types you can find in DefaultXmlSignature2Message.",
				"type": "string",
				"$comment": "group:producer",
				"default": "Default"
			},
			"outputXmlEncoding": {
				"title": "Output Xml Encoding",
				"description": "The character encoding of the resulting signed XML document. If null then the encoding of the original XML document is used.",
				"type": "string",
				"$comment": "group:producer"
			},
			"removeSignatureElements": {
				"title": "Remove Signature Elements",
				"description": "Indicator whether the XML signature elements (elements with local name Signature and namespace http://www.w3.org/2000/09/xmldsig#) shall be removed from the document set to the output message. Normally, this is only necessary, if the XML signature is enveloped. The default value is Boolean#FALSE. This parameter is forwarded to XmlSignature2Message. This indicator has no effect if the output node search is of type DefaultXmlSignature2Message#OUTPUT_NODE_SEARCH_TYPE_DEFAULT.F",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"schemaResourceUri": {
				"title": "Schema Resource Uri",
				"description": "Classpath to the XML Schema. Must be specified in the detached XML Signature case for determining the ID attributes, might be set in the enveloped and enveloping case. If set, then the XML document is validated with the specified XML schema. The schema resource URI can be overwritten by the header XmlSignatureConstants#HEADER_SCHEMA_RESOURCE_URI.",
				"type": "string",
				"$comment": "group:producer"
			},
			"secureValidation": {
				"title": "Secure Validation",
				"description": "Enables secure validation. If true then secure validation is enabled.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"validationFailedHandler": {
				"title": "Validation Failed Handler",
				"description": "Handles the different validation failed situations. The default implementation throws specific exceptions for the different situations (All exceptions have the package name org.apache.camel.component.xmlsecurity.api and are a sub-class of XmlSignatureInvalidException. If the signature value validation fails, a XmlSignatureInvalidValueException is thrown. If a reference validation fails, a XmlSignatureInvalidContentHashException is thrown. For more detailed information, see the JavaDoc.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xmlsecurity.api.ValidationFailedHandler"
			},
			"xmlSignature2Message": {
				"title": "Xml Signature2 Message",
				"description": "Bean which maps the XML signature to the output-message after the validation. How this mapping should be done can be configured by the options outputNodeSearchType, outputNodeSearch, and removeSignatureElements. The default implementation offers three possibilities which are related to the three output node search types Default, ElementName, and XPath. The default implementation determines a node which is then serialized and set to the body of the output message If the search type is ElementName then the output node (which must be in this case an element) is determined by the local name and namespace defined in the search value (see option outputNodeSearch). If the search type is XPath then the output node is determined by the XPath specified in the search value (in this case the output node can be of type Element, TextNode or Document). If the output node search type is Default then the following rules apply: In the enveloped XML signature case (there is a reference with URI= and transform http://www.w3.org/2000/09/xmldsig#enveloped-signature), the incoming XML document without the Signature element is set to the output message body. In the non-enveloped XML signature case, the message body is determined from a referenced Object; this is explained in more detail in chapter Output Node Determination in Enveloping XML Signature Case.",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xmlsecurity.api.XmlSignature2Message"
			},
			"xmlSignatureChecker": {
				"title": "Xml Signature Checker",
				"description": "This interface allows the application to check the XML signature before the validation is executed. This step is recommended in http://www.w3.org/TR/xmldsig-bestpractices/#check-what-is-signed",
				"type": "string",
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xmlsecurity.api.XmlSignatureChecker"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"uriDereferencer": {
				"title": "Uri Dereferencer",
				"description": "If you want to restrict the remote access via reference URIs, you can set an own dereferencer. Optional parameter. If not set the provider default dereferencer is used which can resolve URI fragments, HTTP, file and XPpointer URIs. Attention: The implementation is provider dependent!",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.crypto.URIDereferencer"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"name"
		]
	},
	"xmpp": {
		"properties": {
			"host": {
				"title": "Host",
				"description": "Hostname for the chat server",
				"type": "string",
				"$comment": "group:common"
			},
			"port": {
				"title": "Port",
				"description": "Port number for the chat server",
				"type": "integer",
				"$comment": "group:common"
			},
			"participant": {
				"title": "Participant",
				"description": "JID (Jabber ID) of person to receive messages. room parameter has precedence over participant.",
				"type": "string",
				"$comment": "group:common"
			},
			"login": {
				"title": "Login",
				"description": "Whether to login the user.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"nickname": {
				"title": "Nickname",
				"description": "Use nickname when joining room. If room is specified and nickname is not, user will be used for the nickname.",
				"type": "string",
				"$comment": "group:common"
			},
			"pubsub": {
				"title": "Pubsub",
				"description": "Accept pubsub packets on input, default is false",
				"type": "boolean",
				"$comment": "group:common"
			},
			"room": {
				"title": "Room",
				"description": "If this option is specified, the component will connect to MUC (Multi User Chat). Usually, the domain name for MUC is different from the login domain. For example, if you are supermanjabber.org and want to join the krypton room, then the room URL is kryptonconference.jabber.org. Note the conference part. It is not a requirement to provide the full room JID. If the room parameter does not contain the symbol, the domain part will be discovered and added by Camel",
				"type": "string",
				"$comment": "group:common"
			},
			"serviceName": {
				"title": "Service Name",
				"description": "The name of the service you are connecting to. For Google Talk, this would be gmail.com.",
				"type": "string",
				"$comment": "group:common"
			},
			"testConnectionOnStartup": {
				"title": "Test Connection On Startup",
				"description": "Specifies whether to test the connection on startup. This is used to ensure that the XMPP client has a valid connection to the XMPP server when the route starts. Camel throws an exception on startup if a connection cannot be established. When this option is set to false, Camel will attempt to establish a lazy connection when needed by a producer, and will poll for a consumer connection until the connection is established. Default is true.",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"createAccount": {
				"title": "Create Account",
				"description": "If true, an attempt to create an account will be made. Default is false.",
				"type": "boolean",
				"$comment": "group:common (advanced)"
			},
			"resource": {
				"title": "Resource",
				"description": "XMPP resource. The default is Camel.",
				"type": "string",
				"$comment": "group:common (advanced)",
				"default": "Camel"
			},
			"connectionPollDelay": {
				"title": "Connection Poll Delay",
				"description": "The amount of time in seconds between polls (in seconds) to verify the health of the XMPP connection, or between attempts to establish an initial consumer connection. Camel will try to re-establish a connection if it has become inactive. Default is 10 seconds.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"doc": {
				"title": "Doc",
				"description": "Set a doc header on the IN message containing a Document form of the incoming packet; default is true if presence or pubsub are true, otherwise false",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"connectionConfig": {
				"title": "Connection Config",
				"description": "To use an existing connection configuration. Currently org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration is only supported (XMPP over TCP).",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.jivesoftware.smack.ConnectionConfiguration"
			},
			"headerFilterStrategy": {
				"title": "Header Filter Strategy",
				"description": "To use a custom HeaderFilterStrategy to filter header to and from Camel message.",
				"type": "string",
				"$comment": "group:filter",
				"format": "bean:org.apache.camel.spi.HeaderFilterStrategy"
			},
			"password": {
				"title": "Password",
				"description": "Password for login",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"roomPassword": {
				"title": "Room Password",
				"description": "Password for room",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"user": {
				"title": "User",
				"description": "User name (without server name). If not specified, anonymous login will be attempted.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"host",
			"port"
		]
	},
	"xquery": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "The name of the template to load from classpath or file system",
				"type": "string",
				"$comment": "group:common"
			},
			"allowStAX": {
				"title": "Allow St AX",
				"description": "Whether to allow using StAX mode",
				"type": "boolean",
				"$comment": "group:common"
			},
			"namespacePrefixes": {
				"title": "Namespace Prefixes",
				"description": "Allows to control which namespace prefixes to use for a set of namespace mappings",
				"type": "object",
				"$comment": "group:common"
			},
			"resultsFormat": {
				"title": "Results Format",
				"description": "What output result to use",
				"type": "string",
				"enum": [
					"Bytes",
					"BytesSource",
					"DOM",
					"DOMSource",
					"List",
					"String",
					"StringSource"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.xquery.ResultFormat",
				"default": "DOM"
			},
			"resultType": {
				"title": "Result Type",
				"description": "What output result to use defined as a class",
				"type": "string",
				"$comment": "group:common"
			},
			"source": {
				"title": "Source",
				"description": "Source to use, instead of message body. You can prefix with variable:, header:, or property: to specify kind of source. Otherwise, the source is assumed to be a variable. Use empty or null to use default source, which is the message body.",
				"type": "string",
				"$comment": "group:common"
			},
			"stripsAllWhiteSpace": {
				"title": "Strips All White Space",
				"description": "Whether to strip all whitespaces",
				"type": "boolean",
				"$comment": "group:common",
				"default": true
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"configuration": {
				"title": "Configuration",
				"description": "To use a custom Saxon configuration",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:net.sf.saxon.Configuration"
			},
			"configurationProperties": {
				"title": "Configuration Properties",
				"description": "To set custom Saxon configuration properties",
				"type": "object",
				"$comment": "group:advanced"
			},
			"moduleURIResolver": {
				"title": "Module URIResolver",
				"description": "To use the custom ModuleURIResolver",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:net.sf.saxon.lib.ModuleURIResolver"
			},
			"parameters": {
				"title": "Parameters",
				"description": "Additional parameters",
				"type": "object",
				"$comment": "group:advanced"
			},
			"properties": {
				"title": "Properties",
				"description": "Properties to configure the serialization parameters",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:java.util.Properties"
			},
			"staticQueryContext": {
				"title": "Static Query Context",
				"description": "To use a custom Saxon StaticQueryContext",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:net.sf.saxon.query.StaticQueryContext"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"xslt": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Cache for the resource content (the stylesheet file) when it is loaded on startup. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"deleteOutputFile": {
				"title": "Delete Output File",
				"description": "If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"failOnNullBody": {
				"title": "Fail On Null Body",
				"description": "Whether or not to throw an exception if the input body is null.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"output": {
				"title": "Output",
				"description": "Option to specify which output type to use. Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File. For file you must specify the filename in the IN header with the key XsltConstants.XSLT_FILE_NAME which is also CamelXsltFileName. Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.",
				"type": "string",
				"enum": [
					"string",
					"bytes",
					"DOM",
					"file"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xslt.XsltOutput",
				"default": "string"
			},
			"transformerCacheSize": {
				"title": "Transformer Cache Size",
				"description": "The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().",
				"type": "integer",
				"$comment": "group:producer",
				"default": 0
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"entityResolver": {
				"title": "Entity Resolver",
				"description": "To use a custom org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.xml.sax.EntityResolver"
			},
			"errorListener": {
				"title": "Error Listener",
				"description": "Allows to configure to use a custom javax.xml.transform.ErrorListener. Beware when doing this then the default error listener which captures any errors or fatal errors and store information on the Exchange as properties is not in use. So only use this option for special use-cases.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.ErrorListener"
			},
			"resultHandlerFactory": {
				"title": "Result Handler Factory",
				"description": "Allows you to use a custom org.apache.camel.builder.xml.ResultHandlerFactory which is capable of using custom org.apache.camel.builder.xml.ResultHandler types.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.xslt.ResultHandlerFactory"
			},
			"transformerFactory": {
				"title": "Transformer Factory",
				"description": "To use a custom XSLT transformer factory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.TransformerFactory"
			},
			"transformerFactoryClass": {
				"title": "Transformer Factory Class",
				"description": "To use a custom XSLT transformer factory, specified as a FQN class name",
				"type": "string",
				"$comment": "group:advanced"
			},
			"transformerFactoryConfigurationStrategy": {
				"title": "Transformer Factory Configuration Strategy",
				"description": "A configuration strategy to apply on freshly created instances of TransformerFactory.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.xslt.TransformerFactoryConfigurationStrategy"
			},
			"uriResolver": {
				"title": "Uri Resolver",
				"description": "To use a custom javax.xml.transform.URIResolver",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.URIResolver"
			},
			"xsltMessageLogger": {
				"title": "Xslt Message Logger",
				"description": "A consumer to messages generated during XSLT transformations.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.xslt.XsltMessageLogger"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"xslt-saxon": {
		"properties": {
			"resourceUri": {
				"title": "Resource Uri",
				"description": "Path to the template. The following is supported by the default URIResolver. You can prefix with: classpath, file, http, ref, or bean. classpath, file and http loads the resource using these protocols (classpath is default). ref will lookup the resource in the registry. bean will call a method on a bean to be used as the resource. For bean you can specify the method name after dot, eg bean:myBean.myMethod",
				"type": "string",
				"$comment": "group:producer"
			},
			"allowStAX": {
				"title": "Allow StAX",
				"description": "Whether to allow using StAX as the javax.xml.transform.Source. You can enable this if the XSLT library supports StAX such as the Saxon library (camel-saxon). The Xalan library (default in JVM) does not support StAXSource.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"allowTemplateFromHeader": {
				"title": "Allow Template From Header",
				"description": "Whether to allow to use resource template from header or not (default false). Enabling this allows to specify dynamic templates via message header. However this can be seen as a potential security vulnerability if the header is coming from a malicious user, so use this with care.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"contentCache": {
				"title": "Content Cache",
				"description": "Cache for the resource content (the stylesheet file) when it is loaded on startup. If set to false Camel will reload the stylesheet file on each message processing. This is good for development. A cached stylesheet can be forced to reload at runtime via JMX using the clearCachedStylesheet operation.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"deleteOutputFile": {
				"title": "Delete Output File",
				"description": "If you have output=file then this option dictates whether or not the output file should be deleted when the Exchange is done processing. For example suppose the output file is a temporary file, then it can be a good idea to delete it after use.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"failOnNullBody": {
				"title": "Fail On Null Body",
				"description": "Whether or not to throw an exception if the input body is null.",
				"type": "boolean",
				"$comment": "group:producer",
				"default": true
			},
			"output": {
				"title": "Output",
				"description": "Option to specify which output type to use. Possible values are: string, bytes, DOM, file. The first three options are all in memory based, where as file is streamed directly to a java.io.File. For file you must specify the filename in the IN header with the key XsltConstants.XSLT_FILE_NAME which is also CamelXsltFileName. Also any paths leading to the filename must be created beforehand, otherwise an exception is thrown at runtime.",
				"type": "string",
				"enum": [
					"string",
					"bytes",
					"DOM",
					"file"
				],
				"$comment": "group:producer",
				"format": "bean:org.apache.camel.component.xslt.XsltOutput",
				"default": "string"
			},
			"transformerCacheSize": {
				"title": "Transformer Cache Size",
				"description": "The number of javax.xml.transform.Transformer object that are cached for reuse to avoid calls to Template.newTransformer().",
				"type": "integer",
				"$comment": "group:producer",
				"default": 0
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"entityResolver": {
				"title": "Entity Resolver",
				"description": "To use a custom org.xml.sax.EntityResolver with javax.xml.transform.sax.SAXSource.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.xml.sax.EntityResolver"
			},
			"errorListener": {
				"title": "Error Listener",
				"description": "Allows to configure to use a custom javax.xml.transform.ErrorListener. Beware when doing this then the default error listener which captures any errors or fatal errors and store information on the Exchange as properties is not in use. So only use this option for special use-cases.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.ErrorListener"
			},
			"resultHandlerFactory": {
				"title": "Result Handler Factory",
				"description": "Allows you to use a custom org.apache.camel.builder.xml.ResultHandlerFactory which is capable of using custom org.apache.camel.builder.xml.ResultHandler types.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.xslt.ResultHandlerFactory"
			},
			"saxonConfiguration": {
				"title": "Saxon Configuration",
				"description": "To use a custom Saxon configuration",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:net.sf.saxon.Configuration"
			},
			"saxonExtensionFunctions": {
				"title": "Saxon Extension Functions",
				"description": "Allows you to use a custom net.sf.saxon.lib.ExtensionFunctionDefinition. You would need to add camel-saxon to the classpath. The function is looked up in the registry, where you can comma to separate multiple values to lookup.",
				"type": "string",
				"$comment": "group:advanced"
			},
			"secureProcessing": {
				"title": "Secure Processing",
				"description": "Feature for XML secure processing (see javax.xml.XMLConstants). This is enabled by default. However, when using Saxon Professional you may need to turn this off to allow Saxon to be able to use Java extension functions.",
				"type": "boolean",
				"$comment": "group:advanced",
				"default": true
			},
			"transformerFactory": {
				"title": "Transformer Factory",
				"description": "To use a custom XSLT transformer factory",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.TransformerFactory"
			},
			"transformerFactoryClass": {
				"title": "Transformer Factory Class",
				"description": "To use a custom XSLT transformer factory, specified as a FQN class name",
				"type": "string",
				"$comment": "group:advanced"
			},
			"transformerFactoryConfigurationStrategy": {
				"title": "Transformer Factory Configuration Strategy",
				"description": "A configuration strategy to apply on freshly created instances of TransformerFactory.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.xslt.TransformerFactoryConfigurationStrategy"
			},
			"uriResolver": {
				"title": "Uri Resolver",
				"description": "To use a custom javax.xml.transform.URIResolver",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:javax.xml.transform.URIResolver"
			},
			"xsltMessageLogger": {
				"title": "Xslt Message Logger",
				"description": "A consumer to messages generated during XSLT transformations.",
				"type": "string",
				"$comment": "group:advanced",
				"format": "bean:org.apache.camel.component.xslt.XsltMessageLogger"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"resourceUri"
		]
	},
	"zeebe": {
		"properties": {
			"operationName": {
				"title": "Operation Name",
				"description": "The operation to use",
				"type": "string",
				"enum": [
					"startProcess",
					"cancelProcess",
					"publishMessage",
					"completeJob",
					"failJob",
					"updateJobRetries",
					"worker",
					"throwError",
					"deployResource"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.zeebe.internal.OperationName"
			},
			"formatJSON": {
				"title": "Format JSON",
				"description": "Format the result in the body as JSON.",
				"type": "boolean",
				"$comment": "group:common"
			},
			"jobKey": {
				"title": "Job Key",
				"description": "JobKey for the job worker.",
				"type": "string",
				"$comment": "group:consumer"
			},
			"timeout": {
				"title": "Timeout",
				"description": "Timeout for job worker.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 10
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"operationName"
		]
	},
	"zendesk": {
		"properties": {
			"methodName": {
				"title": "Method Name",
				"description": "What operation to use",
				"type": "string",
				"enum": [
					"ADD_TAG_TO_ORGANISATIONS",
					"ADD_TAG_TO_TICKET",
					"ADD_TAG_TO_TOPICS",
					"ASSOCIATE_ATTACHMENTS_TO_ARTICLE",
					"CHANGE_USER_PASSWORD",
					"CREATE_ARTICLE",
					"CREATE_ARTICLE_1",
					"CREATE_ARTICLE_TRANSLATION",
					"CREATE_AUTOMATION",
					"CREATE_CATEGORY",
					"CREATE_CATEGORY_TRANSLATION",
					"CREATE_COMMENT",
					"CREATE_CONTENT_TAG",
					"CREATE_DYNAMIC_CONTENT_ITEM",
					"CREATE_DYNAMIC_CONTENT_ITEM_VARIANT",
					"CREATE_FORUM",
					"CREATE_GROUP",
					"CREATE_GROUP_MEMBERSHIP",
					"CREATE_GROUP_MEMBERSHIP_1",
					"CREATE_MACRO",
					"CREATE_OR_UPDATE_ORGANIZATION",
					"CREATE_OR_UPDATE_USER",
					"CREATE_OR_UPDATE_USERS",
					"CREATE_OR_UPDATE_USERS_1",
					"CREATE_OR_UPDATE_USERS_ASYNC",
					"CREATE_ORGANIZATION",
					"CREATE_ORGANIZATION_MEMBERSHIP",
					"CREATE_ORGANIZATION_MEMBERSHIP_1",
					"CREATE_ORGANIZATION_MEMBERSHIPS",
					"CREATE_ORGANIZATION_MEMBERSHIPS_1",
					"CREATE_ORGANIZATION_MEMBERSHIPS_ASYNC",
					"CREATE_ORGANIZATIONS",
					"CREATE_ORGANIZATIONS_1",
					"CREATE_ORGANIZATIONS_ASYNC",
					"CREATE_PERMISSION_GROUP",
					"CREATE_REQUEST",
					"CREATE_SATISFACTION_RATING",
					"CREATE_SATISFACTION_RATING_1",
					"CREATE_SECTION",
					"CREATE_SECTION_TRANSLATION",
					"CREATE_TARGET",
					"CREATE_TICKET",
					"CREATE_TICKET_ASYNC",
					"CREATE_TICKET_FIELD",
					"CREATE_TICKET_FORM",
					"CREATE_TICKET_FROM_TWEET",
					"CREATE_TICKETS",
					"CREATE_TICKETS_1",
					"CREATE_TICKETS_ASYNC",
					"CREATE_TOPIC",
					"CREATE_TRIGGER",
					"CREATE_UPLOAD",
					"CREATE_UPLOAD_1",
					"CREATE_UPLOAD_2",
					"CREATE_UPLOAD_ARTICLE",
					"CREATE_UPLOAD_ARTICLE_1",
					"CREATE_USER",
					"CREATE_USER_IDENTITY",
					"CREATE_USER_IDENTITY_1",
					"CREATE_USER_SEGMENT",
					"CREATE_USERS",
					"CREATE_USERS_1",
					"CREATE_USERS_ASYNC",
					"DELETE_ARTICLE",
					"DELETE_ARTICLE_ATTACHMENT",
					"DELETE_ARTICLE_ATTACHMENT_1",
					"DELETE_ATTACHMENT",
					"DELETE_ATTACHMENT_1",
					"DELETE_AUTOMATION",
					"DELETE_CATEGORY",
					"DELETE_CONTENT_TAG",
					"DELETE_DYNAMIC_CONTENT_ITEM",
					"DELETE_DYNAMIC_CONTENT_ITEM_VARIANT",
					"DELETE_FORUM",
					"DELETE_GROUP",
					"DELETE_GROUP_1",
					"DELETE_GROUP_MEMBERSHIP",
					"DELETE_GROUP_MEMBERSHIP_1",
					"DELETE_GROUP_MEMBERSHIP_2",
					"DELETE_GROUP_MEMBERSHIP_3",
					"DELETE_ORGANIZATION",
					"DELETE_ORGANIZATION_1",
					"DELETE_ORGANIZATION_MEMBERSHIP",
					"DELETE_ORGANIZATION_MEMBERSHIP_1",
					"DELETE_ORGANIZATION_MEMBERSHIP_2",
					"DELETE_ORGANIZATION_MEMBERSHIPS",
					"DELETE_ORGANIZATIONS",
					"DELETE_PERMISSION_GROUP",
					"DELETE_PERMISSION_GROUP_1",
					"DELETE_SECTION",
					"DELETE_SUSPENDED_TICKET",
					"DELETE_SUSPENDED_TICKET_1",
					"DELETE_TARGET",
					"DELETE_TICKET",
					"DELETE_TICKET_1",
					"DELETE_TICKET_FIELD",
					"DELETE_TICKET_FIELD_1",
					"DELETE_TICKET_FORM",
					"DELETE_TICKET_FORM_1",
					"DELETE_TICKETS",
					"DELETE_TOPIC",
					"DELETE_TRANSLATION",
					"DELETE_TRANSLATION_1",
					"DELETE_TRIGGER",
					"DELETE_UPLOAD",
					"DELETE_UPLOAD_1",
					"DELETE_USER",
					"DELETE_USER_1",
					"DELETE_USER_IDENTITY",
					"DELETE_USER_IDENTITY_1",
					"DELETE_USER_IDENTITY_2",
					"DELETE_USER_SEGMENT",
					"DELETE_USER_SEGMENT_1",
					"DELETE_USERS",
					"GET_ACTIVE_TRIGGERS",
					"GET_ARTICLE",
					"GET_ARTICLE_FROM_SEARCH",
					"GET_ARTICLE_FROM_SEARCH_1",
					"GET_ARTICLE_SUBSCRIPTIONS",
					"GET_ARTICLE_SUBSCRIPTIONS_1",
					"GET_ARTICLE_TRANSLATIONS",
					"GET_ARTICLES",
					"GET_ARTICLES_1",
					"GET_ARTICLES_2",
					"GET_ARTICLES_3",
					"GET_ARTICLES_4",
					"GET_ARTICLES_5",
					"GET_ARTICLES_FROM_ALL_LABELS",
					"GET_ARTICLES_FROM_ANY_LABELS",
					"GET_ARTICLES_FROM_PAGE",
					"GET_ARTICLES_INCREMENTALLY",
					"GET_ASSIGNABLE_GROUP_MEMBERSHIPS",
					"GET_ASSIGNABLE_GROUP_MEMBERSHIPS_1",
					"GET_ASSIGNABLE_GROUPS",
					"GET_ASSIGNED_TICKETS_COUNT_FOR_USER",
					"GET_ATTACHMENT",
					"GET_ATTACHMENT_1",
					"GET_ATTACHMENTS_FROM_ARTICLE",
					"GET_AUTHENTICATED_USER",
					"GET_AUTO_COMPLETE_ORGANIZATIONS",
					"GET_AUTOMATION",
					"GET_AUTOMATIONS",
					"GET_BRANDS",
					"GET_CC_REQUESTS",
					"GET_CATEGORIES",
					"GET_CATEGORY",
					"GET_CATEGORY_TRANSLATIONS",
					"GET_CCD_TICKETS_COUNT_FOR_USER",
					"GET_COMPLIANCE_DELETION_STATUSES",
					"GET_CONTENT_TAG",
					"GET_CONTENT_TAGS",
					"GET_CONTENT_TAGS_1",
					"GET_CONTENT_TAGS_2",
					"GET_CURRENT_USER",
					"GET_CUSTOM_AGENT_ROLES",
					"GET_CUSTOM_TICKET_STATUSES",
					"GET_DELETED_TICKETS",
					"GET_DELETED_TICKETS_1",
					"GET_DYNAMIC_CONTENT_ITEM",
					"GET_DYNAMIC_CONTENT_ITEM_VARIANT",
					"GET_DYNAMIC_CONTENT_ITEM_VARIANTS",
					"GET_DYNAMIC_CONTENT_ITEMS",
					"GET_FORUM",
					"GET_FORUMS",
					"GET_FORUMS_1",
					"GET_GROUP",
					"GET_GROUP_MEMBERSHIP",
					"GET_GROUP_MEMBERSHIP_1",
					"GET_GROUP_MEMBERSHIP_BY_USER",
					"GET_GROUP_MEMBERSHIPS",
					"GET_GROUP_MEMBERSHIPS_1",
					"GET_GROUP_ORGANIZATION",
					"GET_GROUP_USERS",
					"GET_GROUPS",
					"GET_HELP_CENTER_LOCALES",
					"GET_HOLIDAYS_FOR_SCHEDULE",
					"GET_HOLIDAYS_FOR_SCHEDULE_1",
					"GET_INCREMENTAL_TICKETS_RESULT",
					"GET_JIRA_LINKS",
					"GET_JOB_STATUS",
					"GET_JOB_STATUS_ASYNC",
					"GET_JOB_STATUSES",
					"GET_JOB_STATUSES_ASYNC",
					"GET_LOCALES",
					"GET_MACRO",
					"GET_MACROS",
					"GET_OPEN_REQUESTS",
					"GET_ORGANIZATION",
					"GET_ORGANIZATION_FIELDS",
					"GET_ORGANIZATION_MEMBERSHIP",
					"GET_ORGANIZATION_MEMBERSHIP_BY_USER",
					"GET_ORGANIZATION_MEMBERSHIP_FOR_USER",
					"GET_ORGANIZATION_MEMBERSHIPS",
					"GET_ORGANIZATION_MEMBERSHIPS_FOR_ORG",
					"GET_ORGANIZATION_MEMBERSHIPS_FOR_USER",
					"GET_ORGANIZATION_REQUESTS",
					"GET_ORGANIZATION_TICKETS",
					"GET_ORGANIZATION_USERS",
					"GET_ORGANIZATIONS",
					"GET_ORGANIZATIONS_1",
					"GET_ORGANIZATIONS_INCREMENTALLY",
					"GET_PERMISSION_GROUP",
					"GET_PERMISSION_GROUPS",
					"GET_RECENT_TICKETS",
					"GET_REQUEST",
					"GET_REQUEST_COMMENT",
					"GET_REQUEST_COMMENT_1",
					"GET_REQUEST_COMMENT_2",
					"GET_REQUEST_COMMENTS",
					"GET_REQUEST_COMMENTS_1",
					"GET_REQUESTS",
					"GET_SATISFACTION_RATING",
					"GET_SATISFACTION_RATINGS",
					"GET_SCHEDULE",
					"GET_SCHEDULE_1",
					"GET_SCHEDULES",
					"GET_SEARCH_TICKET_RESULTS",
					"GET_SECTION",
					"GET_SECTION_SUBSCRIPTIONS",
					"GET_SECTION_SUBSCRIPTIONS_1",
					"GET_SECTION_TRANSLATIONS",
					"GET_SECTIONS",
					"GET_SECTIONS_1",
					"GET_SECTIONS_2",
					"GET_SOLVED_REQUESTS",
					"GET_SUSPENDED_TICKETS",
					"GET_TARGET",
					"GET_TARGETS",
					"GET_TICKET",
					"GET_TICKET_AUDIT",
					"GET_TICKET_AUDIT_1",
					"GET_TICKET_AUDIT_2",
					"GET_TICKET_AUDITS",
					"GET_TICKET_AUDITS_1",
					"GET_TICKET_COLLABORATORS",
					"GET_TICKET_COMMENTS",
					"GET_TICKET_COMMENTS_1",
					"GET_TICKET_FIELD",
					"GET_TICKET_FIELDS",
					"GET_TICKET_FORM",
					"GET_TICKET_FORMS",
					"GET_TICKET_INCIDENTS",
					"GET_TICKET_METRIC",
					"GET_TICKET_METRIC_BY_TICKET",
					"GET_TICKET_METRICS",
					"GET_TICKETS",
					"GET_TICKETS_1",
					"GET_TICKETS_BY_EXTERNAL_ID",
					"GET_TICKETS_BY_EXTERNAL_ID_1",
					"GET_TICKETS_COUNT",
					"GET_TICKETS_COUNT_FOR_ORGANIZATION",
					"GET_TICKETS_FROM_SEARCH",
					"GET_TICKETS_INCREMENTALLY",
					"GET_TICKETS_INCREMENTALLY_1",
					"GET_TIME_ZONES",
					"GET_TOPIC",
					"GET_TOPICS",
					"GET_TOPICS_1",
					"GET_TOPICS_2",
					"GET_TOPICS_3",
					"GET_TOPICS_BY_USER",
					"GET_TRIGGER",
					"GET_TRIGGERS",
					"GET_TRIGGERS_1",
					"GET_TWITTER_MONITORS",
					"GET_USER",
					"GET_USER_CCD_TICKETS",
					"GET_USER_FIELDS",
					"GET_USER_IDENTITIES",
					"GET_USER_IDENTITIES_1",
					"GET_USER_IDENTITY",
					"GET_USER_IDENTITY_1",
					"GET_USER_IDENTITY_2",
					"GET_USER_RELATED_INFO",
					"GET_USER_REQUESTED_TICKETS",
					"GET_USER_REQUESTS",
					"GET_USER_REQUESTS_1",
					"GET_USER_SEGMENT",
					"GET_USER_SEGMENTS",
					"GET_USER_SEGMENTS_1",
					"GET_USER_SEGMENTS_APPLICABLE",
					"GET_USER_SUBSCRIPTIONS",
					"GET_USER_SUBSCRIPTIONS_1",
					"GET_USERS",
					"GET_USERS_1",
					"GET_USERS_BY_EXTERNAL_IDS",
					"GET_USERS_BY_EXTERNAL_IDS_1",
					"GET_USERS_BY_ROLE",
					"GET_USERS_INCREMENTALLY",
					"GET_VIEW",
					"GET_VIEWS",
					"IMPORT_TICKET",
					"IMPORT_TOPIC",
					"LIST_HELP_CENTER_LOCALES",
					"LOOKUP_ORGANIZATIONS_BY_EXTERNAL_ID",
					"LOOKUP_USER_BY_EMAIL",
					"LOOKUP_USER_BY_EXTERNAL_ID",
					"MACROS_SHOW_CHANGES_TO_TICKET",
					"MACROS_SHOW_TICKET_AFTER_CHANGES",
					"MAKE_PRIVATE_TICKET_AUDIT",
					"MAKE_PRIVATE_TICKET_AUDIT_1",
					"MAKE_PRIVATE_TICKET_AUDIT_2",
					"MARK_TICKET_AS_SPAM",
					"MARK_TICKET_AS_SPAM_1",
					"MERGE_USERS",
					"NOTIFY_APP",
					"PERMANENTLY_DELETE_TICKET",
					"PERMANENTLY_DELETE_TICKET_1",
					"PERMANENTLY_DELETE_TICKETS",
					"PERMANENTLY_DELETE_USER",
					"PERMANENTLY_DELETE_USER_1",
					"QUEUE_CREATE_TICKET_ASYNC",
					"REMOVE_TAG_FROM_ORGANISATIONS",
					"REMOVE_TAG_FROM_TICKET",
					"REMOVE_TAG_FROM_TOPICS",
					"REQUEST_VERIFY_USER_IDENTITY",
					"REQUEST_VERIFY_USER_IDENTITY_1",
					"REQUEST_VERIFY_USER_IDENTITY_2",
					"RESET_USER_PASSWORD",
					"RESET_USER_PASSWORD_1",
					"SEARCH_TRIGGERS",
					"SEARCH_TRIGGERS_1",
					"SET_GROUP_MEMBERSHIP_AS_DEFAULT",
					"SET_ORGANIZATION_MEMBERSHIP_AS_DEFAULT",
					"SET_TAG_ON_ORGANISATIONS",
					"SET_TAG_ON_TICKET",
					"SET_TAG_ON_TOPICS",
					"SET_USER_PRIMARY_IDENTITY",
					"SET_USER_PRIMARY_IDENTITY_1",
					"SET_USER_PRIMARY_IDENTITY_2",
					"SHOW_ARTICLE_TRANSLATION",
					"SHOW_CATEGORY_TRANSLATION",
					"SHOW_SECTION_TRANSLATION",
					"SUSPEND_USER",
					"TRUST_TICKET_AUDIT",
					"TRUST_TICKET_AUDIT_1",
					"TRUST_TICKET_AUDIT_2",
					"UNASSIGN_ORGANIZATION_MEMBERSHIP",
					"UNSUSPEND_USER",
					"UPDATE_ARTICLE",
					"UPDATE_ARTICLE_TRANSLATION",
					"UPDATE_AUTOMATION",
					"UPDATE_CATEGORY",
					"UPDATE_CATEGORY_TRANSLATION",
					"UPDATE_CONTENT_TAG",
					"UPDATE_DYNAMIC_CONTENT_ITEM",
					"UPDATE_DYNAMIC_CONTENT_ITEM_VARIANT",
					"UPDATE_FORUM",
					"UPDATE_GROUP",
					"UPDATE_INSTALLATION",
					"UPDATE_MACRO",
					"UPDATE_ORGANIZATION",
					"UPDATE_ORGANIZATIONS",
					"UPDATE_ORGANIZATIONS_1",
					"UPDATE_ORGANIZATIONS_ASYNC",
					"UPDATE_PERMISSION_GROUP",
					"UPDATE_REQUEST",
					"UPDATE_SECTION",
					"UPDATE_SECTION_TRANSLATION",
					"UPDATE_TICKET",
					"UPDATE_TICKET_FIELD",
					"UPDATE_TICKET_FORM",
					"UPDATE_TICKETS",
					"UPDATE_TICKETS_1",
					"UPDATE_TICKETS_ASYNC",
					"UPDATE_TOPIC",
					"UPDATE_TRIGGER",
					"UPDATE_USER",
					"UPDATE_USER_IDENTITY",
					"UPDATE_USER_IDENTITY_1",
					"UPDATE_USER_SEGMENT",
					"UPDATE_USERS",
					"UPDATE_USERS_1",
					"UPDATE_USERS_ASYNC",
					"VERIFY_USER_IDENTITY",
					"VERIFY_USER_IDENTITY_1",
					"VERIFY_USER_IDENTITY_2"
				],
				"$comment": "group:common",
				"format": "bean:org.apache.camel.component.zendesk.internal.ZendeskApiMethod"
			},
			"inBody": {
				"title": "In Body",
				"description": "Sets the name of a parameter to be passed in the exchange In Body",
				"type": "string",
				"$comment": "group:common"
			},
			"serverUrl": {
				"title": "Server Url",
				"description": "The server URL to connect.",
				"type": "string",
				"$comment": "group:common"
			},
			"sendEmptyMessageWhenIdle": {
				"title": "Send Empty Message When Idle",
				"description": "If the polling consumer did not poll any files, you can enable this option to send an empty message (no body) instead.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"pollStrategy": {
				"title": "Poll Strategy",
				"description": "A pluggable org.apache.camel.PollingConsumerPollingStrategy allowing you to provide your custom implementation to control error handling usually occurred during the poll operation before an Exchange have been created and being routed in Camel.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.PollingConsumerPollStrategy"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			},
			"backoffErrorThreshold": {
				"title": "Backoff Error Threshold",
				"description": "The number of subsequent error polls (failed due some error) that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffIdleThreshold": {
				"title": "Backoff Idle Threshold",
				"description": "The number of subsequent idle polls that should happen before the backoffMultipler should kick-in.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"backoffMultiplier": {
				"title": "Backoff Multiplier",
				"description": "To let the scheduled polling consumer backoff if there has been a number of subsequent idles/errors in a row. The multiplier is then the number of polls that will be skipped before the next actual attempt is happening again. When this option is in use then backoffIdleThreshold and/or backoffErrorThreshold must also be configured.",
				"type": "integer",
				"$comment": "group:scheduler"
			},
			"delay": {
				"title": "Delay",
				"description": "Milliseconds before the next poll.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 500
			},
			"greedy": {
				"title": "Greedy",
				"description": "If greedy is enabled, then the ScheduledPollConsumer will run immediately again, if the previous run polled 1 or more messages.",
				"type": "boolean",
				"$comment": "group:scheduler"
			},
			"initialDelay": {
				"title": "Initial Delay",
				"description": "Milliseconds before the first poll starts.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 1000
			},
			"repeatCount": {
				"title": "Repeat Count",
				"description": "Specifies a maximum limit of number of fires. So if you set it to 1, the scheduler will only fire once. If you set it to 5, it will only fire five times. A value of zero or negative means fire forever.",
				"type": "integer",
				"$comment": "group:scheduler",
				"default": 0
			},
			"runLoggingLevel": {
				"title": "Run Logging Level",
				"description": "The consumer logs a start/complete log line when it polls. This option allows you to configure the logging level for that.",
				"type": "string",
				"enum": [
					"TRACE",
					"DEBUG",
					"INFO",
					"WARN",
					"ERROR",
					"OFF"
				],
				"$comment": "group:scheduler",
				"format": "bean:org.apache.camel.LoggingLevel",
				"default": "TRACE"
			},
			"scheduledExecutorService": {
				"title": "Scheduled Executor Service",
				"description": "Allows for configuring a custom/shared thread pool to use for the consumer. By default each consumer has its own single threaded thread pool.",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.ScheduledExecutorService"
			},
			"scheduler": {
				"title": "Scheduler",
				"description": "To use a cron scheduler from either camel-spring or camel-quartz component. Use value spring or quartz for built in scheduler",
				"type": "string",
				"$comment": "group:scheduler",
				"format": "bean:java.lang.Object",
				"default": "none"
			},
			"schedulerProperties": {
				"title": "Scheduler Properties",
				"description": "To configure additional properties when using a custom scheduler or any of the Quartz, Spring based scheduler.",
				"type": "object",
				"$comment": "group:scheduler"
			},
			"startScheduler": {
				"title": "Start Scheduler",
				"description": "Whether the scheduler should be auto started.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"timeUnit": {
				"title": "Time Unit",
				"description": "Time unit for initialDelay and delay options.",
				"type": "string",
				"enum": [
					"NANOSECONDS",
					"MICROSECONDS",
					"MILLISECONDS",
					"SECONDS",
					"MINUTES",
					"HOURS",
					"DAYS"
				],
				"$comment": "group:scheduler",
				"format": "bean:java.util.concurrent.TimeUnit",
				"default": "MILLISECONDS"
			},
			"useFixedDelay": {
				"title": "Use Fixed Delay",
				"description": "Controls if fixed delay or fixed rate is used. See ScheduledExecutorService in JDK for details.",
				"type": "boolean",
				"$comment": "group:scheduler",
				"default": true
			},
			"oauthToken": {
				"title": "Oauth Token",
				"description": "The OAuth token.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"password": {
				"title": "Password",
				"description": "The password.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"token": {
				"title": "Token",
				"description": "The security token.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			},
			"username": {
				"title": "Username",
				"description": "The user name.",
				"type": "string",
				"$comment": "group:security",
				"format": "password"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"methodName"
		]
	},
	"zookeeper": {
		"properties": {
			"serverUrls": {
				"title": "Server Urls",
				"description": "The zookeeper server hosts (multiple servers can be separated by comma)",
				"type": "string",
				"$comment": "group:common"
			},
			"path": {
				"title": "Path",
				"description": "The node in the ZooKeeper server (aka znode)",
				"type": "string",
				"$comment": "group:common"
			},
			"listChildren": {
				"title": "List Children",
				"description": "Whether the children of the node should be listed",
				"type": "boolean",
				"$comment": "group:common"
			},
			"timeout": {
				"title": "Timeout",
				"description": "The time interval to wait on connection before timing out.",
				"type": "integer",
				"$comment": "group:common",
				"default": 5000
			},
			"backoff": {
				"title": "Backoff",
				"description": "The time interval to backoff for after an error before retrying.",
				"type": "integer",
				"$comment": "group:consumer",
				"default": 5000
			},
			"repeat": {
				"title": "Repeat",
				"description": "Should changes to the znode be 'watched' and repeatedly processed.",
				"type": "boolean",
				"$comment": "group:consumer"
			},
			"sendEmptyMessageOnDelete": {
				"title": "Send Empty Message On Delete",
				"description": "Upon the delete of a znode, should an empty message be send to the consumer",
				"type": "boolean",
				"$comment": "group:consumer",
				"default": true
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			},
			"create": {
				"title": "Create",
				"description": "Should the endpoint create the node if it does not currently exist.",
				"type": "boolean",
				"$comment": "group:producer"
			},
			"createMode": {
				"title": "Create Mode",
				"description": "The create mode that should be used for the newly created node",
				"type": "string",
				"enum": [
					"PERSISTENT",
					"PERSISTENT_SEQUENTIAL",
					"EPHEMERAL",
					"EPHEMERAL_SEQUENTIAL"
				],
				"$comment": "group:producer",
				"default": "EPHEMERAL"
			},
			"lazyStartProducer": {
				"title": "Lazy Start Producer",
				"description": "Whether the producer should be started lazy (on the first message). By starting lazy you can use this to allow CamelContext and routes to startup in situations where a producer may otherwise fail during starting and cause the route to fail being started. By deferring this startup to be lazy then the startup failure can be handled during routing messages via Camel's routing error handlers. Beware that when the first message is processed then creating and starting the producer may take a little time and prolong the total processing time of the processing.",
				"type": "boolean",
				"$comment": "group:producer (advanced)"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"serverUrls",
			"path"
		]
	},
	"zookeeper-master": {
		"properties": {
			"groupName": {
				"title": "Group Name",
				"description": "The name of the cluster group to use",
				"type": "string",
				"$comment": "group:consumer"
			},
			"consumerEndpointUri": {
				"title": "Consumer Endpoint Uri",
				"description": "The consumer endpoint to use in master/slave mode",
				"type": "string",
				"$comment": "group:consumer"
			},
			"bridgeErrorHandler": {
				"title": "Bridge Error Handler",
				"description": "Allows for bridging the consumer to the Camel routing Error Handler, which mean any exceptions (if possible) occurred while the Camel consumer is trying to pickup incoming messages, or the likes, will now be processed as a message and handled by the routing Error Handler. Important: This is only possible if the 3rd party component allows Camel to be alerted if an exception was thrown. Some components handle this internally only, and therefore bridgeErrorHandler is not possible. In other situations we may improve the Camel component to hook into the 3rd party component and make this possible for future releases. By default the consumer will use the org.apache.camel.spi.ExceptionHandler to deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "boolean",
				"$comment": "group:consumer (advanced)"
			},
			"exceptionHandler": {
				"title": "Exception Handler",
				"description": "To let the consumer use a custom ExceptionHandler. Notice if the option bridgeErrorHandler is enabled then this option is not in use. By default the consumer will deal with exceptions, that will be logged at WARN or ERROR level and ignored.",
				"type": "string",
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.spi.ExceptionHandler"
			},
			"exchangePattern": {
				"title": "Exchange Pattern",
				"description": "Sets the exchange pattern when the consumer creates an exchange.",
				"type": "string",
				"enum": [
					"InOnly",
					"InOut"
				],
				"$comment": "group:consumer (advanced)",
				"format": "bean:org.apache.camel.ExchangePattern"
			}
		},
		"$schema": "http://json-schema.org/draft-07/schema#",
		"type": "object",
		"required": [
			"groupName",
			"consumerEndpointUri"
		]
	}
}